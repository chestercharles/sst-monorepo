import { HttpRequest as __HttpRequest } from "@smithy/protocol-http";
import { collectBody, decorateServiceException as __decorateServiceException, expectNonNull as __expectNonNull, expectString as __expectString, extendedEncodeURIComponent as __extendedEncodeURIComponent, getArrayIfSingleItem as __getArrayIfSingleItem, getValueFromTextNode as __getValueFromTextNode, parseBoolean as __parseBoolean, parseRfc3339DateTimeWithOffset as __parseRfc3339DateTimeWithOffset, strictParseInt32 as __strictParseInt32, withBaseException, } from "@smithy/smithy-client";
import { XMLParser } from "fast-xml-parser";
import { IAMServiceException as __BaseException } from "../models/IAMServiceException";
import { ConcurrentModificationException, CredentialReportExpiredException, CredentialReportNotPresentException, CredentialReportNotReadyException, DeleteConflictException, EntityAlreadyExistsException, EntityTemporarilyUnmodifiableException, InvalidAuthenticationCodeException, InvalidInputException, InvalidUserTypeException, LimitExceededException, MalformedPolicyDocumentException, NoSuchEntityException, PasswordPolicyViolationException, PolicyEvaluationException, PolicyNotAttachableException, ReportGenerationLimitExceededException, ServiceFailureException, ServiceNotSupportedException, UnmodifiableEntityException, UnrecognizedPublicKeyEncodingException, } from "../models/models_0";
import { DuplicateCertificateException, DuplicateSSHPublicKeyException, InvalidCertificateException, InvalidPublicKeyException, KeyPairMismatchException, MalformedCertificateException, } from "../models/models_1";
export const se_AddClientIDToOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddClientIDToOpenIDConnectProviderRequest(input, context),
        Action: "AddClientIDToOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AddRoleToInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddRoleToInstanceProfileRequest(input, context),
        Action: "AddRoleToInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AddUserToGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AddUserToGroupRequest(input, context),
        Action: "AddUserToGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachGroupPolicyRequest(input, context),
        Action: "AttachGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachRolePolicyRequest(input, context),
        Action: "AttachRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_AttachUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AttachUserPolicyRequest(input, context),
        Action: "AttachUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ChangePasswordCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ChangePasswordRequest(input, context),
        Action: "ChangePassword",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAccessKeyRequest(input, context),
        Action: "CreateAccessKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateAccountAliasCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateAccountAliasRequest(input, context),
        Action: "CreateAccountAlias",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateGroupRequest(input, context),
        Action: "CreateGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateInstanceProfileRequest(input, context),
        Action: "CreateInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateLoginProfileRequest(input, context),
        Action: "CreateLoginProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateOpenIDConnectProviderRequest(input, context),
        Action: "CreateOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreatePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreatePolicyRequest(input, context),
        Action: "CreatePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreatePolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreatePolicyVersionRequest(input, context),
        Action: "CreatePolicyVersion",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateRoleRequest(input, context),
        Action: "CreateRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateSAMLProviderRequest(input, context),
        Action: "CreateSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateServiceLinkedRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateServiceLinkedRoleRequest(input, context),
        Action: "CreateServiceLinkedRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateServiceSpecificCredentialRequest(input, context),
        Action: "CreateServiceSpecificCredential",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateUserRequest(input, context),
        Action: "CreateUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_CreateVirtualMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_CreateVirtualMFADeviceRequest(input, context),
        Action: "CreateVirtualMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeactivateMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeactivateMFADeviceRequest(input, context),
        Action: "DeactivateMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAccessKeyRequest(input, context),
        Action: "DeleteAccessKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAccountAliasCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteAccountAliasRequest(input, context),
        Action: "DeleteAccountAlias",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "DeleteAccountPasswordPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteGroupRequest(input, context),
        Action: "DeleteGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteGroupPolicyRequest(input, context),
        Action: "DeleteGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteInstanceProfileRequest(input, context),
        Action: "DeleteInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteLoginProfileRequest(input, context),
        Action: "DeleteLoginProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteOpenIDConnectProviderRequest(input, context),
        Action: "DeleteOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeletePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePolicyRequest(input, context),
        Action: "DeletePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeletePolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeletePolicyVersionRequest(input, context),
        Action: "DeletePolicyVersion",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRoleRequest(input, context),
        Action: "DeleteRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRolePermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRolePermissionsBoundaryRequest(input, context),
        Action: "DeleteRolePermissionsBoundary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteRolePolicyRequest(input, context),
        Action: "DeleteRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSAMLProviderRequest(input, context),
        Action: "DeleteSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServerCertificateRequest(input, context),
        Action: "DeleteServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteServiceLinkedRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServiceLinkedRoleRequest(input, context),
        Action: "DeleteServiceLinkedRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteServiceSpecificCredentialRequest(input, context),
        Action: "DeleteServiceSpecificCredential",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSigningCertificateRequest(input, context),
        Action: "DeleteSigningCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteSSHPublicKeyRequest(input, context),
        Action: "DeleteSSHPublicKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserRequest(input, context),
        Action: "DeleteUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteUserPermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserPermissionsBoundaryRequest(input, context),
        Action: "DeleteUserPermissionsBoundary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteUserPolicyRequest(input, context),
        Action: "DeleteUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DeleteVirtualMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DeleteVirtualMFADeviceRequest(input, context),
        Action: "DeleteVirtualMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachGroupPolicyRequest(input, context),
        Action: "DetachGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachRolePolicyRequest(input, context),
        Action: "DetachRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_DetachUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DetachUserPolicyRequest(input, context),
        Action: "DetachUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_EnableMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_EnableMFADeviceRequest(input, context),
        Action: "EnableMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GenerateCredentialReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "GenerateCredentialReport",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GenerateOrganizationsAccessReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GenerateOrganizationsAccessReportRequest(input, context),
        Action: "GenerateOrganizationsAccessReport",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GenerateServiceLastAccessedDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GenerateServiceLastAccessedDetailsRequest(input, context),
        Action: "GenerateServiceLastAccessedDetails",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAccessKeyLastUsedCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccessKeyLastUsedRequest(input, context),
        Action: "GetAccessKeyLastUsed",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAccountAuthorizationDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccountAuthorizationDetailsRequest(input, context),
        Action: "GetAccountAuthorizationDetails",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "GetAccountPasswordPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetAccountSummaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "GetAccountSummary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetContextKeysForCustomPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetContextKeysForCustomPolicyRequest(input, context),
        Action: "GetContextKeysForCustomPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetContextKeysForPrincipalPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetContextKeysForPrincipalPolicyRequest(input, context),
        Action: "GetContextKeysForPrincipalPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetCredentialReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    const body = buildFormUrlencodedString({
        Action: "GetCredentialReport",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetGroupRequest(input, context),
        Action: "GetGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetGroupPolicyRequest(input, context),
        Action: "GetGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetInstanceProfileRequest(input, context),
        Action: "GetInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetLoginProfileRequest(input, context),
        Action: "GetLoginProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetMFADeviceRequest(input, context),
        Action: "GetMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetOpenIDConnectProviderRequest(input, context),
        Action: "GetOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetOrganizationsAccessReportCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetOrganizationsAccessReportRequest(input, context),
        Action: "GetOrganizationsAccessReport",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPolicyRequest(input, context),
        Action: "GetPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetPolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetPolicyVersionRequest(input, context),
        Action: "GetPolicyVersion",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRoleRequest(input, context),
        Action: "GetRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetRolePolicyRequest(input, context),
        Action: "GetRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSAMLProviderRequest(input, context),
        Action: "GetSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServerCertificateRequest(input, context),
        Action: "GetServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetServiceLastAccessedDetailsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLastAccessedDetailsRequest(input, context),
        Action: "GetServiceLastAccessedDetails",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetServiceLastAccessedDetailsWithEntitiesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLastAccessedDetailsWithEntitiesRequest(input, context),
        Action: "GetServiceLastAccessedDetailsWithEntities",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetServiceLinkedRoleDeletionStatusCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetServiceLinkedRoleDeletionStatusRequest(input, context),
        Action: "GetServiceLinkedRoleDeletionStatus",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSSHPublicKeyRequest(input, context),
        Action: "GetSSHPublicKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetUserRequest(input, context),
        Action: "GetUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_GetUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetUserPolicyRequest(input, context),
        Action: "GetUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAccessKeysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAccessKeysRequest(input, context),
        Action: "ListAccessKeys",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAccountAliasesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAccountAliasesRequest(input, context),
        Action: "ListAccountAliases",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAttachedGroupPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedGroupPoliciesRequest(input, context),
        Action: "ListAttachedGroupPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAttachedRolePoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedRolePoliciesRequest(input, context),
        Action: "ListAttachedRolePolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListAttachedUserPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListAttachedUserPoliciesRequest(input, context),
        Action: "ListAttachedUserPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListEntitiesForPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListEntitiesForPolicyRequest(input, context),
        Action: "ListEntitiesForPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListGroupPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupPoliciesRequest(input, context),
        Action: "ListGroupPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListGroupsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupsRequest(input, context),
        Action: "ListGroups",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListGroupsForUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListGroupsForUserRequest(input, context),
        Action: "ListGroupsForUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListInstanceProfilesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfilesRequest(input, context),
        Action: "ListInstanceProfiles",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListInstanceProfilesForRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfilesForRoleRequest(input, context),
        Action: "ListInstanceProfilesForRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListInstanceProfileTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListInstanceProfileTagsRequest(input, context),
        Action: "ListInstanceProfileTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListMFADevicesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMFADevicesRequest(input, context),
        Action: "ListMFADevices",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListMFADeviceTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListMFADeviceTagsRequest(input, context),
        Action: "ListMFADeviceTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListOpenIDConnectProvidersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListOpenIDConnectProvidersRequest(input, context),
        Action: "ListOpenIDConnectProviders",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListOpenIDConnectProviderTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListOpenIDConnectProviderTagsRequest(input, context),
        Action: "ListOpenIDConnectProviderTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPoliciesRequest(input, context),
        Action: "ListPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListPoliciesGrantingServiceAccessCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPoliciesGrantingServiceAccessRequest(input, context),
        Action: "ListPoliciesGrantingServiceAccess",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListPolicyTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPolicyTagsRequest(input, context),
        Action: "ListPolicyTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListPolicyVersionsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListPolicyVersionsRequest(input, context),
        Action: "ListPolicyVersions",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListRolePoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRolePoliciesRequest(input, context),
        Action: "ListRolePolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListRolesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRolesRequest(input, context),
        Action: "ListRoles",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListRoleTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListRoleTagsRequest(input, context),
        Action: "ListRoleTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListSAMLProvidersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSAMLProvidersRequest(input, context),
        Action: "ListSAMLProviders",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListSAMLProviderTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSAMLProviderTagsRequest(input, context),
        Action: "ListSAMLProviderTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListServerCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServerCertificatesRequest(input, context),
        Action: "ListServerCertificates",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListServerCertificateTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServerCertificateTagsRequest(input, context),
        Action: "ListServerCertificateTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListServiceSpecificCredentialsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListServiceSpecificCredentialsRequest(input, context),
        Action: "ListServiceSpecificCredentials",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListSigningCertificatesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSigningCertificatesRequest(input, context),
        Action: "ListSigningCertificates",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListSSHPublicKeysCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListSSHPublicKeysRequest(input, context),
        Action: "ListSSHPublicKeys",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListUserPoliciesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUserPoliciesRequest(input, context),
        Action: "ListUserPolicies",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListUsersCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUsersRequest(input, context),
        Action: "ListUsers",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListUserTagsCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListUserTagsRequest(input, context),
        Action: "ListUserTags",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ListVirtualMFADevicesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ListVirtualMFADevicesRequest(input, context),
        Action: "ListVirtualMFADevices",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutGroupPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutGroupPolicyRequest(input, context),
        Action: "PutGroupPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutRolePermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutRolePermissionsBoundaryRequest(input, context),
        Action: "PutRolePermissionsBoundary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutRolePolicyRequest(input, context),
        Action: "PutRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutUserPermissionsBoundaryCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutUserPermissionsBoundaryRequest(input, context),
        Action: "PutUserPermissionsBoundary",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_PutUserPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_PutUserPolicyRequest(input, context),
        Action: "PutUserPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveClientIDFromOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveClientIDFromOpenIDConnectProviderRequest(input, context),
        Action: "RemoveClientIDFromOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveRoleFromInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveRoleFromInstanceProfileRequest(input, context),
        Action: "RemoveRoleFromInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_RemoveUserFromGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_RemoveUserFromGroupRequest(input, context),
        Action: "RemoveUserFromGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResetServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResetServiceSpecificCredentialRequest(input, context),
        Action: "ResetServiceSpecificCredential",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_ResyncMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_ResyncMFADeviceRequest(input, context),
        Action: "ResyncMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetDefaultPolicyVersionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetDefaultPolicyVersionRequest(input, context),
        Action: "SetDefaultPolicyVersion",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SetSecurityTokenServicePreferencesCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SetSecurityTokenServicePreferencesRequest(input, context),
        Action: "SetSecurityTokenServicePreferences",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SimulateCustomPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SimulateCustomPolicyRequest(input, context),
        Action: "SimulateCustomPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_SimulatePrincipalPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_SimulatePrincipalPolicyRequest(input, context),
        Action: "SimulatePrincipalPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagInstanceProfileRequest(input, context),
        Action: "TagInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagMFADeviceRequest(input, context),
        Action: "TagMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagOpenIDConnectProviderRequest(input, context),
        Action: "TagOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagPolicyRequest(input, context),
        Action: "TagPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagRoleRequest(input, context),
        Action: "TagRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagSAMLProviderRequest(input, context),
        Action: "TagSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagServerCertificateRequest(input, context),
        Action: "TagServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_TagUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_TagUserRequest(input, context),
        Action: "TagUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagInstanceProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagInstanceProfileRequest(input, context),
        Action: "UntagInstanceProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagMFADeviceCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagMFADeviceRequest(input, context),
        Action: "UntagMFADevice",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagOpenIDConnectProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagOpenIDConnectProviderRequest(input, context),
        Action: "UntagOpenIDConnectProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagPolicyRequest(input, context),
        Action: "UntagPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagRoleRequest(input, context),
        Action: "UntagRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagSAMLProviderRequest(input, context),
        Action: "UntagSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagServerCertificateRequest(input, context),
        Action: "UntagServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UntagUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UntagUserRequest(input, context),
        Action: "UntagUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAccessKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAccessKeyRequest(input, context),
        Action: "UpdateAccessKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAccountPasswordPolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAccountPasswordPolicyRequest(input, context),
        Action: "UpdateAccountPasswordPolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateAssumeRolePolicyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateAssumeRolePolicyRequest(input, context),
        Action: "UpdateAssumeRolePolicy",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateGroupCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateGroupRequest(input, context),
        Action: "UpdateGroup",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateLoginProfileCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateLoginProfileRequest(input, context),
        Action: "UpdateLoginProfile",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateOpenIDConnectProviderThumbprintCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateOpenIDConnectProviderThumbprintRequest(input, context),
        Action: "UpdateOpenIDConnectProviderThumbprint",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateRoleCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateRoleRequest(input, context),
        Action: "UpdateRole",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateRoleDescriptionCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateRoleDescriptionRequest(input, context),
        Action: "UpdateRoleDescription",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateSAMLProviderCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSAMLProviderRequest(input, context),
        Action: "UpdateSAMLProvider",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateServerCertificateRequest(input, context),
        Action: "UpdateServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateServiceSpecificCredentialCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateServiceSpecificCredentialRequest(input, context),
        Action: "UpdateServiceSpecificCredential",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSigningCertificateRequest(input, context),
        Action: "UpdateSigningCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateSSHPublicKeyRequest(input, context),
        Action: "UpdateSSHPublicKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UpdateUserCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UpdateUserRequest(input, context),
        Action: "UpdateUser",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UploadServerCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadServerCertificateRequest(input, context),
        Action: "UploadServerCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UploadSigningCertificateCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadSigningCertificateRequest(input, context),
        Action: "UploadSigningCertificate",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const se_UploadSSHPublicKeyCommand = async (input, context) => {
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_UploadSSHPublicKeyRequest(input, context),
        Action: "UploadSSHPublicKey",
        Version: "2010-05-08",
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const de_AddClientIDToOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddClientIDToOpenIDConnectProviderCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_AddClientIDToOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AddRoleToInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddRoleToInstanceProfileCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_AddRoleToInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AddUserToGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AddUserToGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_AddUserToGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AttachGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachGroupPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_AttachGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AttachRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachRolePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_AttachRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_AttachUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_AttachUserPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_AttachUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ChangePasswordCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ChangePasswordCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_ChangePasswordCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "InvalidUserType":
        case "com.amazonaws.iam#InvalidUserTypeException":
            throw await de_InvalidUserTypeExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PasswordPolicyViolation":
        case "com.amazonaws.iam#PasswordPolicyViolationException":
            throw await de_PasswordPolicyViolationExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAccessKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateAccessKeyResponse(data.CreateAccessKeyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateAccessKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateAccountAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateAccountAliasCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_CreateAccountAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateGroupResponse(data.CreateGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateInstanceProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateInstanceProfileResponse(data.CreateInstanceProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateLoginProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateLoginProfileResponse(data.CreateLoginProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateLoginProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PasswordPolicyViolation":
        case "com.amazonaws.iam#PasswordPolicyViolationException":
            throw await de_PasswordPolicyViolationExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateOpenIDConnectProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateOpenIDConnectProviderResponse(data.CreateOpenIDConnectProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreatePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreatePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePolicyResponse(data.CreatePolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreatePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreatePolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreatePolicyVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreatePolicyVersionResponse(data.CreatePolicyVersionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreatePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateRoleResponse(data.CreateRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateSAMLProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateSAMLProviderResponse(data.CreateSAMLProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateServiceLinkedRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateServiceLinkedRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateServiceLinkedRoleResponse(data.CreateServiceLinkedRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateServiceLinkedRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateServiceSpecificCredentialCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateServiceSpecificCredentialResponse(data.CreateServiceSpecificCredentialResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateServiceSpecificCredentialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "NotSupportedService":
        case "com.amazonaws.iam#ServiceNotSupportedException":
            throw await de_ServiceNotSupportedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateUserResponse(data.CreateUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_CreateVirtualMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_CreateVirtualMFADeviceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateVirtualMFADeviceResponse(data.CreateVirtualMFADeviceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_CreateVirtualMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeactivateMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeactivateMFADeviceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeactivateMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAccessKeyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAccessKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteAccountAliasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAccountAliasCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAccountAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteAccountPasswordPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteAccountPasswordPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteGroupPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteInstanceProfileCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteLoginProfileCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteLoginProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteOpenIDConnectProviderCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeletePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeletePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeletePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeletePolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeletePolicyVersionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeletePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteRoleCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteRolePermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteRolePermissionsBoundaryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteRolePermissionsBoundaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteRolePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteSAMLProviderCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteServerCertificateCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteServiceLinkedRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteServiceLinkedRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DeleteServiceLinkedRoleResponse(data.DeleteServiceLinkedRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_DeleteServiceLinkedRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteServiceSpecificCredentialCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteServiceSpecificCredentialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteSigningCertificateCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteSigningCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteSSHPublicKeyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteSSHPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteUserCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteUserPermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteUserPermissionsBoundaryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteUserPermissionsBoundaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteUserPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DeleteVirtualMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DeleteVirtualMFADeviceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DeleteVirtualMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "DeleteConflict":
        case "com.amazonaws.iam#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DetachGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachGroupPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DetachGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DetachRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachRolePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DetachRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_DetachUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_DetachUserPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_DetachUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_EnableMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_EnableMFADeviceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_EnableMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "InvalidAuthenticationCode":
        case "com.amazonaws.iam#InvalidAuthenticationCodeException":
            throw await de_InvalidAuthenticationCodeExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GenerateCredentialReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateCredentialReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateCredentialReportResponse(data.GenerateCredentialReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GenerateCredentialReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GenerateOrganizationsAccessReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateOrganizationsAccessReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateOrganizationsAccessReportResponse(data.GenerateOrganizationsAccessReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GenerateOrganizationsAccessReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ReportGenerationLimitExceeded":
        case "com.amazonaws.iam#ReportGenerationLimitExceededException":
            throw await de_ReportGenerationLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GenerateServiceLastAccessedDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GenerateServiceLastAccessedDetailsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GenerateServiceLastAccessedDetailsResponse(data.GenerateServiceLastAccessedDetailsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GenerateServiceLastAccessedDetailsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetAccessKeyLastUsedCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccessKeyLastUsedCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccessKeyLastUsedResponse(data.GetAccessKeyLastUsedResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccessKeyLastUsedCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_GetAccountAuthorizationDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccountAuthorizationDetailsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountAuthorizationDetailsResponse(data.GetAccountAuthorizationDetailsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccountAuthorizationDetailsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccountPasswordPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountPasswordPolicyResponse(data.GetAccountPasswordPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccountPasswordPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetAccountSummaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetAccountSummaryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccountSummaryResponse(data.GetAccountSummaryResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetAccountSummaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetContextKeysForCustomPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetContextKeysForCustomPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetContextKeysForPolicyResponse(data.GetContextKeysForCustomPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetContextKeysForCustomPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetContextKeysForPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetContextKeysForPrincipalPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetContextKeysForPolicyResponse(data.GetContextKeysForPrincipalPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetContextKeysForPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetCredentialReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetCredentialReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCredentialReportResponse(data.GetCredentialReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetCredentialReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ReportExpired":
        case "com.amazonaws.iam#CredentialReportExpiredException":
            throw await de_CredentialReportExpiredExceptionRes(parsedOutput, context);
        case "ReportInProgress":
        case "com.amazonaws.iam#CredentialReportNotReadyException":
            throw await de_CredentialReportNotReadyExceptionRes(parsedOutput, context);
        case "ReportNotPresent":
        case "com.amazonaws.iam#CredentialReportNotPresentException":
            throw await de_CredentialReportNotPresentExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetGroupResponse(data.GetGroupResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetGroupPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetGroupPolicyResponse(data.GetGroupPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetInstanceProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetInstanceProfileResponse(data.GetInstanceProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetLoginProfileCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetLoginProfileResponse(data.GetLoginProfileResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetLoginProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetMFADeviceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetMFADeviceResponse(data.GetMFADeviceResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetOpenIDConnectProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOpenIDConnectProviderResponse(data.GetOpenIDConnectProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetOrganizationsAccessReportCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetOrganizationsAccessReportCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetOrganizationsAccessReportResponse(data.GetOrganizationsAccessReportResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetOrganizationsAccessReportCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPolicyResponse(data.GetPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetPolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetPolicyVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetPolicyVersionResponse(data.GetPolicyVersionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRoleResponse(data.GetRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetRolePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetRolePolicyResponse(data.GetRolePolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetSAMLProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSAMLProviderResponse(data.GetSAMLProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServerCertificateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServerCertificateResponse(data.GetServerCertificateResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetServiceLastAccessedDetailsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServiceLastAccessedDetailsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLastAccessedDetailsResponse(data.GetServiceLastAccessedDetailsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetServiceLastAccessedDetailsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetServiceLastAccessedDetailsWithEntitiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServiceLastAccessedDetailsWithEntitiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLastAccessedDetailsWithEntitiesResponse(data.GetServiceLastAccessedDetailsWithEntitiesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetServiceLastAccessedDetailsWithEntitiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetServiceLinkedRoleDeletionStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetServiceLinkedRoleDeletionStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetServiceLinkedRoleDeletionStatusResponse(data.GetServiceLinkedRoleDeletionStatusResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetServiceLinkedRoleDeletionStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetSSHPublicKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSSHPublicKeyResponse(data.GetSSHPublicKeyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetSSHPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "UnrecognizedPublicKeyEncoding":
        case "com.amazonaws.iam#UnrecognizedPublicKeyEncodingException":
            throw await de_UnrecognizedPublicKeyEncodingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetUserResponse(data.GetUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_GetUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_GetUserPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetUserPolicyResponse(data.GetUserPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_GetUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListAccessKeysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAccessKeysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAccessKeysResponse(data.ListAccessKeysResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAccessKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListAccountAliasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAccountAliasesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAccountAliasesResponse(data.ListAccountAliasesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAccountAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListAttachedGroupPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAttachedGroupPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedGroupPoliciesResponse(data.ListAttachedGroupPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAttachedGroupPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListAttachedRolePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAttachedRolePoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedRolePoliciesResponse(data.ListAttachedRolePoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAttachedRolePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListAttachedUserPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListAttachedUserPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListAttachedUserPoliciesResponse(data.ListAttachedUserPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListAttachedUserPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListEntitiesForPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListEntitiesForPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListEntitiesForPolicyResponse(data.ListEntitiesForPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListEntitiesForPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListGroupPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGroupPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupPoliciesResponse(data.ListGroupPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListGroupPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListGroupsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupsResponse(data.ListGroupsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListGroupsForUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListGroupsForUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupsForUserResponse(data.ListGroupsForUserResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListGroupsForUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListInstanceProfilesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListInstanceProfilesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfilesResponse(data.ListInstanceProfilesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListInstanceProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListInstanceProfilesForRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListInstanceProfilesForRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfilesForRoleResponse(data.ListInstanceProfilesForRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListInstanceProfilesForRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListInstanceProfileTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListInstanceProfileTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListInstanceProfileTagsResponse(data.ListInstanceProfileTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListInstanceProfileTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListMFADevicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListMFADevicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMFADevicesResponse(data.ListMFADevicesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListMFADevicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListMFADeviceTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListMFADeviceTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListMFADeviceTagsResponse(data.ListMFADeviceTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListMFADeviceTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListOpenIDConnectProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListOpenIDConnectProvidersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpenIDConnectProvidersResponse(data.ListOpenIDConnectProvidersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListOpenIDConnectProvidersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListOpenIDConnectProviderTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListOpenIDConnectProviderTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListOpenIDConnectProviderTagsResponse(data.ListOpenIDConnectProviderTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListOpenIDConnectProviderTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPoliciesResponse(data.ListPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListPoliciesGrantingServiceAccessCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPoliciesGrantingServiceAccessCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPoliciesGrantingServiceAccessResponse(data.ListPoliciesGrantingServiceAccessResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListPoliciesGrantingServiceAccessCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListPolicyTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPolicyTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPolicyTagsResponse(data.ListPolicyTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListPolicyTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListPolicyVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListPolicyVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListPolicyVersionsResponse(data.ListPolicyVersionsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListPolicyVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListRolePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRolePoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRolePoliciesResponse(data.ListRolePoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListRolePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListRolesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRolesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRolesResponse(data.ListRolesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListRolesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListRoleTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListRoleTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListRoleTagsResponse(data.ListRoleTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListRoleTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListSAMLProvidersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListSAMLProvidersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSAMLProvidersResponse(data.ListSAMLProvidersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListSAMLProvidersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListSAMLProviderTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListSAMLProviderTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSAMLProviderTagsResponse(data.ListSAMLProviderTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListSAMLProviderTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListServerCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListServerCertificatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServerCertificatesResponse(data.ListServerCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListServerCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListServerCertificateTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListServerCertificateTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServerCertificateTagsResponse(data.ListServerCertificateTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListServerCertificateTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListServiceSpecificCredentialsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListServiceSpecificCredentialsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListServiceSpecificCredentialsResponse(data.ListServiceSpecificCredentialsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListServiceSpecificCredentialsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "NotSupportedService":
        case "com.amazonaws.iam#ServiceNotSupportedException":
            throw await de_ServiceNotSupportedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListSigningCertificatesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListSigningCertificatesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSigningCertificatesResponse(data.ListSigningCertificatesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListSigningCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListSSHPublicKeysCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListSSHPublicKeysCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListSSHPublicKeysResponse(data.ListSSHPublicKeysResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListSSHPublicKeysCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListUserPoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListUserPoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUserPoliciesResponse(data.ListUserPoliciesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListUserPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListUsersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListUsersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUsersResponse(data.ListUsersResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListUsersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListUserTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListUserTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUserTagsResponse(data.ListUserTagsResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListUserTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ListVirtualMFADevicesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ListVirtualMFADevicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListVirtualMFADevicesResponse(data.ListVirtualMFADevicesResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ListVirtualMFADevicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode,
    });
};
export const de_PutGroupPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutGroupPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutGroupPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutRolePermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutRolePermissionsBoundaryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutRolePermissionsBoundaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutRolePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutUserPermissionsBoundaryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutUserPermissionsBoundaryCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutUserPermissionsBoundaryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyNotAttachable":
        case "com.amazonaws.iam#PolicyNotAttachableException":
            throw await de_PolicyNotAttachableExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_PutUserPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_PutUserPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_PutUserPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_RemoveClientIDFromOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveClientIDFromOpenIDConnectProviderCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_RemoveClientIDFromOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_RemoveRoleFromInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveRoleFromInstanceProfileCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_RemoveRoleFromInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_RemoveUserFromGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_RemoveUserFromGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_RemoveUserFromGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ResetServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ResetServiceSpecificCredentialCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ResetServiceSpecificCredentialResponse(data.ResetServiceSpecificCredentialResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_ResetServiceSpecificCredentialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_ResyncMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_ResyncMFADeviceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_ResyncMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidAuthenticationCode":
        case "com.amazonaws.iam#InvalidAuthenticationCodeException":
            throw await de_InvalidAuthenticationCodeExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SetDefaultPolicyVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetDefaultPolicyVersionCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_SetDefaultPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SetSecurityTokenServicePreferencesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SetSecurityTokenServicePreferencesCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_SetSecurityTokenServicePreferencesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SimulateCustomPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SimulateCustomPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SimulatePolicyResponse(data.SimulateCustomPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_SimulateCustomPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "PolicyEvaluation":
        case "com.amazonaws.iam#PolicyEvaluationException":
            throw await de_PolicyEvaluationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_SimulatePrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_SimulatePrincipalPolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SimulatePolicyResponse(data.SimulatePrincipalPolicyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_SimulatePrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PolicyEvaluation":
        case "com.amazonaws.iam#PolicyEvaluationException":
            throw await de_PolicyEvaluationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagInstanceProfileCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_TagInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagMFADeviceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_TagMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagOpenIDConnectProviderCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_TagOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_TagPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagRoleCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_TagRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagSAMLProviderCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_TagSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagServerCertificateCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_TagServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_TagUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_TagUserCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_TagUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagInstanceProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagInstanceProfileCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UntagInstanceProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagMFADeviceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagMFADeviceCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UntagMFADeviceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagOpenIDConnectProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagOpenIDConnectProviderCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UntagOpenIDConnectProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UntagPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagRoleCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UntagRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagSAMLProviderCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UntagSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagServerCertificateCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UntagServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UntagUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UntagUserCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UntagUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateAccessKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAccessKeyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateAccessKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateAccountPasswordPolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAccountPasswordPolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateAccountPasswordPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateAssumeRolePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateAssumeRolePolicyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateAssumeRolePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.iam#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateGroupCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateGroupCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateLoginProfileCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateLoginProfileCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateLoginProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "PasswordPolicyViolation":
        case "com.amazonaws.iam#PasswordPolicyViolationException":
            throw await de_PasswordPolicyViolationExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateOpenIDConnectProviderThumbprintCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateOpenIDConnectProviderThumbprintCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateOpenIDConnectProviderThumbprintCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateRoleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateRoleResponse(data.UpdateRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateRoleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateRoleDescriptionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateRoleDescriptionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateRoleDescriptionResponse(data.UpdateRoleDescriptionResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateRoleDescriptionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        case "UnmodifiableEntity":
        case "com.amazonaws.iam#UnmodifiableEntityException":
            throw await de_UnmodifiableEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateSAMLProviderCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateSAMLProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateSAMLProviderResponse(data.UpdateSAMLProviderResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UpdateSAMLProviderCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateServerCertificateCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateServiceSpecificCredentialCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateServiceSpecificCredentialCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateServiceSpecificCredentialCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateSigningCertificateCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateSigningCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateSSHPublicKeyCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateSSHPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UpdateUserCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UpdateUserCommandError(output, context);
    }
    await collectBody(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output),
    };
    return response;
};
const de_UpdateUserCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "EntityTemporarilyUnmodifiable":
        case "com.amazonaws.iam#EntityTemporarilyUnmodifiableException":
            throw await de_EntityTemporarilyUnmodifiableExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UploadServerCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UploadServerCertificateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadServerCertificateResponse(data.UploadServerCertificateResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UploadServerCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidInput":
        case "com.amazonaws.iam#InvalidInputException":
            throw await de_InvalidInputExceptionRes(parsedOutput, context);
        case "KeyPairMismatch":
        case "com.amazonaws.iam#KeyPairMismatchException":
            throw await de_KeyPairMismatchExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedCertificate":
        case "com.amazonaws.iam#MalformedCertificateException":
            throw await de_MalformedCertificateExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UploadSigningCertificateCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UploadSigningCertificateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadSigningCertificateResponse(data.UploadSigningCertificateResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UploadSigningCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModification":
        case "com.amazonaws.iam#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "DuplicateCertificate":
        case "com.amazonaws.iam#DuplicateCertificateException":
            throw await de_DuplicateCertificateExceptionRes(parsedOutput, context);
        case "EntityAlreadyExists":
        case "com.amazonaws.iam#EntityAlreadyExistsException":
            throw await de_EntityAlreadyExistsExceptionRes(parsedOutput, context);
        case "InvalidCertificate":
        case "com.amazonaws.iam#InvalidCertificateException":
            throw await de_InvalidCertificateExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "MalformedCertificate":
        case "com.amazonaws.iam#MalformedCertificateException":
            throw await de_MalformedCertificateExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "ServiceFailure":
        case "com.amazonaws.iam#ServiceFailureException":
            throw await de_ServiceFailureExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
export const de_UploadSSHPublicKeyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return de_UploadSSHPublicKeyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UploadSSHPublicKeyResponse(data.UploadSSHPublicKeyResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return response;
};
const de_UploadSSHPublicKeyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DuplicateSSHPublicKey":
        case "com.amazonaws.iam#DuplicateSSHPublicKeyException":
            throw await de_DuplicateSSHPublicKeyExceptionRes(parsedOutput, context);
        case "InvalidPublicKey":
        case "com.amazonaws.iam#InvalidPublicKeyException":
            throw await de_InvalidPublicKeyExceptionRes(parsedOutput, context);
        case "LimitExceeded":
        case "com.amazonaws.iam#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NoSuchEntity":
        case "com.amazonaws.iam#NoSuchEntityException":
            throw await de_NoSuchEntityExceptionRes(parsedOutput, context);
        case "UnrecognizedPublicKeyEncoding":
        case "com.amazonaws.iam#UnrecognizedPublicKeyEncodingException":
            throw await de_UnrecognizedPublicKeyEncodingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode,
            });
    }
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ConcurrentModificationException(body.Error, context);
    const exception = new ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CredentialReportExpiredExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportExpiredException(body.Error, context);
    const exception = new CredentialReportExpiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CredentialReportNotPresentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportNotPresentException(body.Error, context);
    const exception = new CredentialReportNotPresentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_CredentialReportNotReadyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_CredentialReportNotReadyException(body.Error, context);
    const exception = new CredentialReportNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DeleteConflictExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DeleteConflictException(body.Error, context);
    const exception = new DeleteConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateCertificateException(body.Error, context);
    const exception = new DuplicateCertificateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_DuplicateSSHPublicKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_DuplicateSSHPublicKeyException(body.Error, context);
    const exception = new DuplicateSSHPublicKeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EntityAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EntityAlreadyExistsException(body.Error, context);
    const exception = new EntityAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_EntityTemporarilyUnmodifiableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_EntityTemporarilyUnmodifiableException(body.Error, context);
    const exception = new EntityTemporarilyUnmodifiableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidAuthenticationCodeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthenticationCodeException(body.Error, context);
    const exception = new InvalidAuthenticationCodeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidCertificateException(body.Error, context);
    const exception = new InvalidCertificateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidInputExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidInputException(body.Error, context);
    const exception = new InvalidInputException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidPublicKeyExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidPublicKeyException(body.Error, context);
    const exception = new InvalidPublicKeyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_InvalidUserTypeExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_InvalidUserTypeException(body.Error, context);
    const exception = new InvalidUserTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_KeyPairMismatchExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_KeyPairMismatchException(body.Error, context);
    const exception = new KeyPairMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_LimitExceededException(body.Error, context);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MalformedCertificateExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedCertificateException(body.Error, context);
    const exception = new MalformedCertificateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_NoSuchEntityExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_NoSuchEntityException(body.Error, context);
    const exception = new NoSuchEntityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PasswordPolicyViolationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PasswordPolicyViolationException(body.Error, context);
    const exception = new PasswordPolicyViolationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PolicyEvaluationExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PolicyEvaluationException(body.Error, context);
    const exception = new PolicyEvaluationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_PolicyNotAttachableExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_PolicyNotAttachableException(body.Error, context);
    const exception = new PolicyNotAttachableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ReportGenerationLimitExceededExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ReportGenerationLimitExceededException(body.Error, context);
    const exception = new ReportGenerationLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceFailureExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceFailureException(body.Error, context);
    const exception = new ServiceFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_ServiceNotSupportedExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_ServiceNotSupportedException(body.Error, context);
    const exception = new ServiceNotSupportedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnmodifiableEntityExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnmodifiableEntityException(body.Error, context);
    const exception = new UnmodifiableEntityException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const de_UnrecognizedPublicKeyEncodingExceptionRes = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = de_UnrecognizedPublicKeyEncodingException(body.Error, context);
    const exception = new UnrecognizedPublicKeyEncodingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const se_ActionNameListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_AddClientIDToOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.ClientID != null) {
        entries["ClientID"] = input.ClientID;
    }
    return entries;
};
const se_AddRoleToInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_AddUserToGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_AttachGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_AttachRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_AttachUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_ChangePasswordRequest = (input, context) => {
    const entries = {};
    if (input.OldPassword != null) {
        entries["OldPassword"] = input.OldPassword;
    }
    if (input.NewPassword != null) {
        entries["NewPassword"] = input.NewPassword;
    }
    return entries;
};
const se_clientIDListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ContextEntry = (input, context) => {
    const entries = {};
    if (input.ContextKeyName != null) {
        entries["ContextKeyName"] = input.ContextKeyName;
    }
    if (input.ContextKeyValues != null) {
        const memberEntries = se_ContextKeyValueListType(input.ContextKeyValues, context);
        if (input.ContextKeyValues?.length === 0) {
            entries.ContextKeyValues = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextKeyValues.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ContextKeyType != null) {
        entries["ContextKeyType"] = input.ContextKeyType;
    }
    return entries;
};
const se_ContextEntryListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ContextEntry(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_ContextKeyValueListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_CreateAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_CreateAccountAliasRequest = (input, context) => {
    const entries = {};
    if (input.AccountAlias != null) {
        entries["AccountAlias"] = input.AccountAlias;
    }
    return entries;
};
const se_CreateGroupRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    return entries;
};
const se_CreateInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Password != null) {
        entries["Password"] = input.Password;
    }
    if (input.PasswordResetRequired != null) {
        entries["PasswordResetRequired"] = input.PasswordResetRequired;
    }
    return entries;
};
const se_CreateOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.Url != null) {
        entries["Url"] = input.Url;
    }
    if (input.ClientIDList != null) {
        const memberEntries = se_clientIDListType(input.ClientIDList, context);
        if (input.ClientIDList?.length === 0) {
            entries.ClientIDList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ClientIDList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ThumbprintList != null) {
        const memberEntries = se_thumbprintListType(input.ThumbprintList, context);
        if (input.ThumbprintList?.length === 0) {
            entries.ThumbprintList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ThumbprintList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreatePolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreatePolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    if (input.SetAsDefault != null) {
        entries["SetAsDefault"] = input.SetAsDefault;
    }
    return entries;
};
const se_CreateRoleRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.AssumeRolePolicyDocument != null) {
        entries["AssumeRolePolicyDocument"] = input.AssumeRolePolicyDocument;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    if (input.MaxSessionDuration != null) {
        entries["MaxSessionDuration"] = input.MaxSessionDuration;
    }
    if (input.PermissionsBoundary != null) {
        entries["PermissionsBoundary"] = input.PermissionsBoundary;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLMetadataDocument != null) {
        entries["SAMLMetadataDocument"] = input.SAMLMetadataDocument;
    }
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateServiceLinkedRoleRequest = (input, context) => {
    const entries = {};
    if (input.AWSServiceName != null) {
        entries["AWSServiceName"] = input.AWSServiceName;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    if (input.CustomSuffix != null) {
        entries["CustomSuffix"] = input.CustomSuffix;
    }
    return entries;
};
const se_CreateServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceName != null) {
        entries["ServiceName"] = input.ServiceName;
    }
    return entries;
};
const se_CreateUserRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PermissionsBoundary != null) {
        entries["PermissionsBoundary"] = input.PermissionsBoundary;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_CreateVirtualMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.VirtualMFADeviceName != null) {
        entries["VirtualMFADeviceName"] = input.VirtualMFADeviceName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_DeactivateMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    return entries;
};
const se_DeleteAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    return entries;
};
const se_DeleteAccountAliasRequest = (input, context) => {
    const entries = {};
    if (input.AccountAlias != null) {
        entries["AccountAlias"] = input.AccountAlias;
    }
    return entries;
};
const se_DeleteGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_DeleteGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    return entries;
};
const se_DeleteInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    return entries;
};
const se_DeleteLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_DeleteOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    return entries;
};
const se_DeletePolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_DeletePolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.VersionId != null) {
        entries["VersionId"] = input.VersionId;
    }
    return entries;
};
const se_DeleteRolePermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_DeleteRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_DeleteRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_DeleteSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    return entries;
};
const se_DeleteServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    return entries;
};
const se_DeleteServiceLinkedRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_DeleteServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceSpecificCredentialId != null) {
        entries["ServiceSpecificCredentialId"] = input.ServiceSpecificCredentialId;
    }
    return entries;
};
const se_DeleteSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.CertificateId != null) {
        entries["CertificateId"] = input.CertificateId;
    }
    return entries;
};
const se_DeleteSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SSHPublicKeyId != null) {
        entries["SSHPublicKeyId"] = input.SSHPublicKeyId;
    }
    return entries;
};
const se_DeleteUserPermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_DeleteUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_DeleteUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_DeleteVirtualMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    return entries;
};
const se_DetachGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_DetachRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_DetachUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_EnableMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.AuthenticationCode1 != null) {
        entries["AuthenticationCode1"] = input.AuthenticationCode1;
    }
    if (input.AuthenticationCode2 != null) {
        entries["AuthenticationCode2"] = input.AuthenticationCode2;
    }
    return entries;
};
const se_entityListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_GenerateOrganizationsAccessReportRequest = (input, context) => {
    const entries = {};
    if (input.EntityPath != null) {
        entries["EntityPath"] = input.EntityPath;
    }
    if (input.OrganizationsPolicyId != null) {
        entries["OrganizationsPolicyId"] = input.OrganizationsPolicyId;
    }
    return entries;
};
const se_GenerateServiceLastAccessedDetailsRequest = (input, context) => {
    const entries = {};
    if (input.Arn != null) {
        entries["Arn"] = input.Arn;
    }
    if (input.Granularity != null) {
        entries["Granularity"] = input.Granularity;
    }
    return entries;
};
const se_GetAccessKeyLastUsedRequest = (input, context) => {
    const entries = {};
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    return entries;
};
const se_GetAccountAuthorizationDetailsRequest = (input, context) => {
    const entries = {};
    if (input.Filter != null) {
        const memberEntries = se_entityListType(input.Filter, context);
        if (input.Filter?.length === 0) {
            entries.Filter = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Filter.${key}`;
            entries[loc] = value;
        });
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_GetContextKeysForCustomPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PolicyInputList, context);
        if (input.PolicyInputList?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetContextKeysForPrincipalPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicySourceArn != null) {
        entries["PolicySourceArn"] = input.PolicySourceArn;
    }
    if (input.PolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PolicyInputList, context);
        if (input.PolicyInputList?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_GetGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_GetInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    return entries;
};
const se_GetLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_GetMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_GetOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    return entries;
};
const se_GetOrganizationsAccessReportRequest = (input, context) => {
    const entries = {};
    if (input.JobId != null) {
        entries["JobId"] = input.JobId;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.SortKey != null) {
        entries["SortKey"] = input.SortKey;
    }
    return entries;
};
const se_GetPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    return entries;
};
const se_GetPolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.VersionId != null) {
        entries["VersionId"] = input.VersionId;
    }
    return entries;
};
const se_GetRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_GetRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_GetSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    return entries;
};
const se_GetServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    return entries;
};
const se_GetServiceLastAccessedDetailsRequest = (input, context) => {
    const entries = {};
    if (input.JobId != null) {
        entries["JobId"] = input.JobId;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_GetServiceLastAccessedDetailsWithEntitiesRequest = (input, context) => {
    const entries = {};
    if (input.JobId != null) {
        entries["JobId"] = input.JobId;
    }
    if (input.ServiceNamespace != null) {
        entries["ServiceNamespace"] = input.ServiceNamespace;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_GetServiceLinkedRoleDeletionStatusRequest = (input, context) => {
    const entries = {};
    if (input.DeletionTaskId != null) {
        entries["DeletionTaskId"] = input.DeletionTaskId;
    }
    return entries;
};
const se_GetSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SSHPublicKeyId != null) {
        entries["SSHPublicKeyId"] = input.SSHPublicKeyId;
    }
    if (input.Encoding != null) {
        entries["Encoding"] = input.Encoding;
    }
    return entries;
};
const se_GetUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    return entries;
};
const se_GetUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_ListAccessKeysRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListAccountAliasesRequest = (input, context) => {
    const entries = {};
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListAttachedGroupPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListAttachedRolePoliciesRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListAttachedUserPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListEntitiesForPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.EntityFilter != null) {
        entries["EntityFilter"] = input.EntityFilter;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.PolicyUsageFilter != null) {
        entries["PolicyUsageFilter"] = input.PolicyUsageFilter;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListGroupPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListGroupsForUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListGroupsRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListInstanceProfilesForRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListInstanceProfilesRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListInstanceProfileTagsRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListMFADevicesRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListMFADeviceTagsRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListOpenIDConnectProvidersRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_ListOpenIDConnectProviderTagsRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListPoliciesGrantingServiceAccessRequest = (input, context) => {
    const entries = {};
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.Arn != null) {
        entries["Arn"] = input.Arn;
    }
    if (input.ServiceNamespaces != null) {
        const memberEntries = se_serviceNamespaceListType(input.ServiceNamespaces, context);
        if (input.ServiceNamespaces?.length === 0) {
            entries.ServiceNamespaces = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ServiceNamespaces.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_ListPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.Scope != null) {
        entries["Scope"] = input.Scope;
    }
    if (input.OnlyAttached != null) {
        entries["OnlyAttached"] = input.OnlyAttached;
    }
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.PolicyUsageFilter != null) {
        entries["PolicyUsageFilter"] = input.PolicyUsageFilter;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListPolicyTagsRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListPolicyVersionsRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListRolePoliciesRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListRolesRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListRoleTagsRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListSAMLProvidersRequest = (input, context) => {
    const entries = {};
    return entries;
};
const se_ListSAMLProviderTagsRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListServerCertificatesRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListServerCertificateTagsRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListServiceSpecificCredentialsRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceName != null) {
        entries["ServiceName"] = input.ServiceName;
    }
    return entries;
};
const se_ListSigningCertificatesRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListSSHPublicKeysRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListUserPoliciesRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListUsersRequest = (input, context) => {
    const entries = {};
    if (input.PathPrefix != null) {
        entries["PathPrefix"] = input.PathPrefix;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListUserTagsRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_ListVirtualMFADevicesRequest = (input, context) => {
    const entries = {};
    if (input.AssignmentStatus != null) {
        entries["AssignmentStatus"] = input.AssignmentStatus;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    return entries;
};
const se_PutGroupPolicyRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    return entries;
};
const se_PutRolePermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PermissionsBoundary != null) {
        entries["PermissionsBoundary"] = input.PermissionsBoundary;
    }
    return entries;
};
const se_PutRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    return entries;
};
const se_PutUserPermissionsBoundaryRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PermissionsBoundary != null) {
        entries["PermissionsBoundary"] = input.PermissionsBoundary;
    }
    return entries;
};
const se_PutUserPolicyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.PolicyName != null) {
        entries["PolicyName"] = input.PolicyName;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    return entries;
};
const se_RemoveClientIDFromOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.ClientID != null) {
        entries["ClientID"] = input.ClientID;
    }
    return entries;
};
const se_RemoveRoleFromInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    return entries;
};
const se_RemoveUserFromGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    return entries;
};
const se_ResetServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceSpecificCredentialId != null) {
        entries["ServiceSpecificCredentialId"] = input.ServiceSpecificCredentialId;
    }
    return entries;
};
const se_ResourceNameListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_ResyncMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.AuthenticationCode1 != null) {
        entries["AuthenticationCode1"] = input.AuthenticationCode1;
    }
    if (input.AuthenticationCode2 != null) {
        entries["AuthenticationCode2"] = input.AuthenticationCode2;
    }
    return entries;
};
const se_serviceNamespaceListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_SetDefaultPolicyVersionRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.VersionId != null) {
        entries["VersionId"] = input.VersionId;
    }
    return entries;
};
const se_SetSecurityTokenServicePreferencesRequest = (input, context) => {
    const entries = {};
    if (input.GlobalEndpointTokenVersion != null) {
        entries["GlobalEndpointTokenVersion"] = input.GlobalEndpointTokenVersion;
    }
    return entries;
};
const se_SimulateCustomPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PolicyInputList, context);
        if (input.PolicyInputList?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.PermissionsBoundaryPolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PermissionsBoundaryPolicyInputList, context);
        if (input.PermissionsBoundaryPolicyInputList?.length === 0) {
            entries.PermissionsBoundaryPolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PermissionsBoundaryPolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ActionNames != null) {
        const memberEntries = se_ActionNameListType(input.ActionNames, context);
        if (input.ActionNames?.length === 0) {
            entries.ActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourceArns != null) {
        const memberEntries = se_ResourceNameListType(input.ResourceArns, context);
        if (input.ResourceArns?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourcePolicy != null) {
        entries["ResourcePolicy"] = input.ResourcePolicy;
    }
    if (input.ResourceOwner != null) {
        entries["ResourceOwner"] = input.ResourceOwner;
    }
    if (input.CallerArn != null) {
        entries["CallerArn"] = input.CallerArn;
    }
    if (input.ContextEntries != null) {
        const memberEntries = se_ContextEntryListType(input.ContextEntries, context);
        if (input.ContextEntries?.length === 0) {
            entries.ContextEntries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextEntries.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourceHandlingOption != null) {
        entries["ResourceHandlingOption"] = input.ResourceHandlingOption;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_SimulatePrincipalPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicySourceArn != null) {
        entries["PolicySourceArn"] = input.PolicySourceArn;
    }
    if (input.PolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PolicyInputList, context);
        if (input.PolicyInputList?.length === 0) {
            entries.PolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.PermissionsBoundaryPolicyInputList != null) {
        const memberEntries = se_SimulationPolicyListType(input.PermissionsBoundaryPolicyInputList, context);
        if (input.PermissionsBoundaryPolicyInputList?.length === 0) {
            entries.PermissionsBoundaryPolicyInputList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `PermissionsBoundaryPolicyInputList.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ActionNames != null) {
        const memberEntries = se_ActionNameListType(input.ActionNames, context);
        if (input.ActionNames?.length === 0) {
            entries.ActionNames = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ActionNames.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourceArns != null) {
        const memberEntries = se_ResourceNameListType(input.ResourceArns, context);
        if (input.ResourceArns?.length === 0) {
            entries.ResourceArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ResourceArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourcePolicy != null) {
        entries["ResourcePolicy"] = input.ResourcePolicy;
    }
    if (input.ResourceOwner != null) {
        entries["ResourceOwner"] = input.ResourceOwner;
    }
    if (input.CallerArn != null) {
        entries["CallerArn"] = input.CallerArn;
    }
    if (input.ContextEntries != null) {
        const memberEntries = se_ContextEntryListType(input.ContextEntries, context);
        if (input.ContextEntries?.length === 0) {
            entries.ContextEntries = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ContextEntries.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ResourceHandlingOption != null) {
        entries["ResourceHandlingOption"] = input.ResourceHandlingOption;
    }
    if (input.MaxItems != null) {
        entries["MaxItems"] = input.MaxItems;
    }
    if (input.Marker != null) {
        entries["Marker"] = input.Marker;
    }
    return entries;
};
const se_SimulationPolicyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_Tag = (input, context) => {
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_TagInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_tagKeyListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_tagListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value]) => {
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_TagMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_TagUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_thumbprintListType = (input, context) => {
    const entries = {};
    let counter = 1;
    for (const entry of input) {
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_UntagInstanceProfileRequest = (input, context) => {
    const entries = {};
    if (input.InstanceProfileName != null) {
        entries["InstanceProfileName"] = input.InstanceProfileName;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagMFADeviceRequest = (input, context) => {
    const entries = {};
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagOpenIDConnectProviderRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagPolicyRequest = (input, context) => {
    const entries = {};
    if (input.PolicyArn != null) {
        entries["PolicyArn"] = input.PolicyArn;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UntagUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.TagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TagKeys, context);
        if (input.TagKeys?.length === 0) {
            entries.TagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `TagKeys.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateAccessKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    if (input.Status != null) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const se_UpdateAccountPasswordPolicyRequest = (input, context) => {
    const entries = {};
    if (input.MinimumPasswordLength != null) {
        entries["MinimumPasswordLength"] = input.MinimumPasswordLength;
    }
    if (input.RequireSymbols != null) {
        entries["RequireSymbols"] = input.RequireSymbols;
    }
    if (input.RequireNumbers != null) {
        entries["RequireNumbers"] = input.RequireNumbers;
    }
    if (input.RequireUppercaseCharacters != null) {
        entries["RequireUppercaseCharacters"] = input.RequireUppercaseCharacters;
    }
    if (input.RequireLowercaseCharacters != null) {
        entries["RequireLowercaseCharacters"] = input.RequireLowercaseCharacters;
    }
    if (input.AllowUsersToChangePassword != null) {
        entries["AllowUsersToChangePassword"] = input.AllowUsersToChangePassword;
    }
    if (input.MaxPasswordAge != null) {
        entries["MaxPasswordAge"] = input.MaxPasswordAge;
    }
    if (input.PasswordReusePrevention != null) {
        entries["PasswordReusePrevention"] = input.PasswordReusePrevention;
    }
    if (input.HardExpiry != null) {
        entries["HardExpiry"] = input.HardExpiry;
    }
    return entries;
};
const se_UpdateAssumeRolePolicyRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.PolicyDocument != null) {
        entries["PolicyDocument"] = input.PolicyDocument;
    }
    return entries;
};
const se_UpdateGroupRequest = (input, context) => {
    const entries = {};
    if (input.GroupName != null) {
        entries["GroupName"] = input.GroupName;
    }
    if (input.NewPath != null) {
        entries["NewPath"] = input.NewPath;
    }
    if (input.NewGroupName != null) {
        entries["NewGroupName"] = input.NewGroupName;
    }
    return entries;
};
const se_UpdateLoginProfileRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.Password != null) {
        entries["Password"] = input.Password;
    }
    if (input.PasswordResetRequired != null) {
        entries["PasswordResetRequired"] = input.PasswordResetRequired;
    }
    return entries;
};
const se_UpdateOpenIDConnectProviderThumbprintRequest = (input, context) => {
    const entries = {};
    if (input.OpenIDConnectProviderArn != null) {
        entries["OpenIDConnectProviderArn"] = input.OpenIDConnectProviderArn;
    }
    if (input.ThumbprintList != null) {
        const memberEntries = se_thumbprintListType(input.ThumbprintList, context);
        if (input.ThumbprintList?.length === 0) {
            entries.ThumbprintList = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `ThumbprintList.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UpdateRoleDescriptionRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    return entries;
};
const se_UpdateRoleRequest = (input, context) => {
    const entries = {};
    if (input.RoleName != null) {
        entries["RoleName"] = input.RoleName;
    }
    if (input.Description != null) {
        entries["Description"] = input.Description;
    }
    if (input.MaxSessionDuration != null) {
        entries["MaxSessionDuration"] = input.MaxSessionDuration;
    }
    return entries;
};
const se_UpdateSAMLProviderRequest = (input, context) => {
    const entries = {};
    if (input.SAMLMetadataDocument != null) {
        entries["SAMLMetadataDocument"] = input.SAMLMetadataDocument;
    }
    if (input.SAMLProviderArn != null) {
        entries["SAMLProviderArn"] = input.SAMLProviderArn;
    }
    return entries;
};
const se_UpdateServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.NewPath != null) {
        entries["NewPath"] = input.NewPath;
    }
    if (input.NewServerCertificateName != null) {
        entries["NewServerCertificateName"] = input.NewServerCertificateName;
    }
    return entries;
};
const se_UpdateServiceSpecificCredentialRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.ServiceSpecificCredentialId != null) {
        entries["ServiceSpecificCredentialId"] = input.ServiceSpecificCredentialId;
    }
    if (input.Status != null) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const se_UpdateSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.CertificateId != null) {
        entries["CertificateId"] = input.CertificateId;
    }
    if (input.Status != null) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const se_UpdateSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SSHPublicKeyId != null) {
        entries["SSHPublicKeyId"] = input.SSHPublicKeyId;
    }
    if (input.Status != null) {
        entries["Status"] = input.Status;
    }
    return entries;
};
const se_UpdateUserRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.NewPath != null) {
        entries["NewPath"] = input.NewPath;
    }
    if (input.NewUserName != null) {
        entries["NewUserName"] = input.NewUserName;
    }
    return entries;
};
const se_UploadServerCertificateRequest = (input, context) => {
    const entries = {};
    if (input.Path != null) {
        entries["Path"] = input.Path;
    }
    if (input.ServerCertificateName != null) {
        entries["ServerCertificateName"] = input.ServerCertificateName;
    }
    if (input.CertificateBody != null) {
        entries["CertificateBody"] = input.CertificateBody;
    }
    if (input.PrivateKey != null) {
        entries["PrivateKey"] = input.PrivateKey;
    }
    if (input.CertificateChain != null) {
        entries["CertificateChain"] = input.CertificateChain;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value]) => {
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_UploadSigningCertificateRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.CertificateBody != null) {
        entries["CertificateBody"] = input.CertificateBody;
    }
    return entries;
};
const se_UploadSSHPublicKeyRequest = (input, context) => {
    const entries = {};
    if (input.UserName != null) {
        entries["UserName"] = input.UserName;
    }
    if (input.SSHPublicKeyBody != null) {
        entries["SSHPublicKeyBody"] = input.SSHPublicKeyBody;
    }
    return entries;
};
const de_AccessDetail = (output, context) => {
    const contents = {};
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = __expectString(output["ServiceName"]);
    }
    if (output["ServiceNamespace"] !== undefined) {
        contents.ServiceNamespace = __expectString(output["ServiceNamespace"]);
    }
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    if (output["EntityPath"] !== undefined) {
        contents.EntityPath = __expectString(output["EntityPath"]);
    }
    if (output["LastAuthenticatedTime"] !== undefined) {
        contents.LastAuthenticatedTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastAuthenticatedTime"]));
    }
    if (output["TotalAuthenticatedEntities"] !== undefined) {
        contents.TotalAuthenticatedEntities = __strictParseInt32(output["TotalAuthenticatedEntities"]);
    }
    return contents;
};
const de_AccessDetails = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessDetail(entry, context);
    });
};
const de_AccessKey = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["AccessKeyId"] !== undefined) {
        contents.AccessKeyId = __expectString(output["AccessKeyId"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["SecretAccessKey"] !== undefined) {
        contents.SecretAccessKey = __expectString(output["SecretAccessKey"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    return contents;
};
const de_AccessKeyLastUsed = (output, context) => {
    const contents = {};
    if (output["LastUsedDate"] !== undefined) {
        contents.LastUsedDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastUsedDate"]));
    }
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = __expectString(output["ServiceName"]);
    }
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    return contents;
};
const de_AccessKeyMetadata = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["AccessKeyId"] !== undefined) {
        contents.AccessKeyId = __expectString(output["AccessKeyId"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    return contents;
};
const de_accessKeyMetadataListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AccessKeyMetadata(entry, context);
    });
};
const de_accountAliasListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ArnListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_AttachedPermissionsBoundary = (output, context) => {
    const contents = {};
    if (output["PermissionsBoundaryType"] !== undefined) {
        contents.PermissionsBoundaryType = __expectString(output["PermissionsBoundaryType"]);
    }
    if (output["PermissionsBoundaryArn"] !== undefined) {
        contents.PermissionsBoundaryArn = __expectString(output["PermissionsBoundaryArn"]);
    }
    return contents;
};
const de_attachedPoliciesListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AttachedPolicy(entry, context);
    });
};
const de_AttachedPolicy = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyArn"] !== undefined) {
        contents.PolicyArn = __expectString(output["PolicyArn"]);
    }
    return contents;
};
const de_certificateListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SigningCertificate(entry, context);
    });
};
const de_CertificationMapType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_clientIDListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_ConcurrentModificationException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ContextKeyNamesResultListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_CreateAccessKeyResponse = (output, context) => {
    const contents = {};
    if (output["AccessKey"] !== undefined) {
        contents.AccessKey = de_AccessKey(output["AccessKey"], context);
    }
    return contents;
};
const de_CreateGroupResponse = (output, context) => {
    const contents = {};
    if (output["Group"] !== undefined) {
        contents.Group = de_Group(output["Group"], context);
    }
    return contents;
};
const de_CreateInstanceProfileResponse = (output, context) => {
    const contents = {};
    if (output["InstanceProfile"] !== undefined) {
        contents.InstanceProfile = de_InstanceProfile(output["InstanceProfile"], context);
    }
    return contents;
};
const de_CreateLoginProfileResponse = (output, context) => {
    const contents = {};
    if (output["LoginProfile"] !== undefined) {
        contents.LoginProfile = de_LoginProfile(output["LoginProfile"], context);
    }
    return contents;
};
const de_CreateOpenIDConnectProviderResponse = (output, context) => {
    const contents = {};
    if (output["OpenIDConnectProviderArn"] !== undefined) {
        contents.OpenIDConnectProviderArn = __expectString(output["OpenIDConnectProviderArn"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_CreatePolicyResponse = (output, context) => {
    const contents = {};
    if (output["Policy"] !== undefined) {
        contents.Policy = de_Policy(output["Policy"], context);
    }
    return contents;
};
const de_CreatePolicyVersionResponse = (output, context) => {
    const contents = {};
    if (output["PolicyVersion"] !== undefined) {
        contents.PolicyVersion = de_PolicyVersion(output["PolicyVersion"], context);
    }
    return contents;
};
const de_CreateRoleResponse = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = de_Role(output["Role"], context);
    }
    return contents;
};
const de_CreateSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output["SAMLProviderArn"] !== undefined) {
        contents.SAMLProviderArn = __expectString(output["SAMLProviderArn"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_CreateServiceLinkedRoleResponse = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = de_Role(output["Role"], context);
    }
    return contents;
};
const de_CreateServiceSpecificCredentialResponse = (output, context) => {
    const contents = {};
    if (output["ServiceSpecificCredential"] !== undefined) {
        contents.ServiceSpecificCredential = de_ServiceSpecificCredential(output["ServiceSpecificCredential"], context);
    }
    return contents;
};
const de_CreateUserResponse = (output, context) => {
    const contents = {};
    if (output["User"] !== undefined) {
        contents.User = de_User(output["User"], context);
    }
    return contents;
};
const de_CreateVirtualMFADeviceResponse = (output, context) => {
    const contents = {};
    if (output["VirtualMFADevice"] !== undefined) {
        contents.VirtualMFADevice = de_VirtualMFADevice(output["VirtualMFADevice"], context);
    }
    return contents;
};
const de_CredentialReportExpiredException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_CredentialReportNotPresentException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_CredentialReportNotReadyException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_DeleteConflictException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_DeleteServiceLinkedRoleResponse = (output, context) => {
    const contents = {};
    if (output["DeletionTaskId"] !== undefined) {
        contents.DeletionTaskId = __expectString(output["DeletionTaskId"]);
    }
    return contents;
};
const de_DeletionTaskFailureReasonType = (output, context) => {
    const contents = {};
    if (output["Reason"] !== undefined) {
        contents.Reason = __expectString(output["Reason"]);
    }
    if (output.RoleUsageList === "") {
        contents.RoleUsageList = [];
    }
    else if (output["RoleUsageList"] !== undefined && output["RoleUsageList"]["member"] !== undefined) {
        contents.RoleUsageList = de_RoleUsageListType(__getArrayIfSingleItem(output["RoleUsageList"]["member"]), context);
    }
    return contents;
};
const de_DuplicateCertificateException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_DuplicateSSHPublicKeyException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_EntityAlreadyExistsException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_EntityDetails = (output, context) => {
    const contents = {};
    if (output["EntityInfo"] !== undefined) {
        contents.EntityInfo = de_EntityInfo(output["EntityInfo"], context);
    }
    if (output["LastAuthenticated"] !== undefined) {
        contents.LastAuthenticated = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastAuthenticated"]));
    }
    return contents;
};
const de_entityDetailsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EntityDetails(entry, context);
    });
};
const de_EntityInfo = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["Name"] !== undefined) {
        contents.Name = __expectString(output["Name"]);
    }
    if (output["Type"] !== undefined) {
        contents.Type = __expectString(output["Type"]);
    }
    if (output["Id"] !== undefined) {
        contents.Id = __expectString(output["Id"]);
    }
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    return contents;
};
const de_EntityTemporarilyUnmodifiableException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ErrorDetails = (output, context) => {
    const contents = {};
    if (output["Message"] !== undefined) {
        contents.Message = __expectString(output["Message"]);
    }
    if (output["Code"] !== undefined) {
        contents.Code = __expectString(output["Code"]);
    }
    return contents;
};
const de_EvalDecisionDetailsType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __expectString(pair["value"]);
        return acc;
    }, {});
};
const de_EvaluationResult = (output, context) => {
    const contents = {};
    if (output["EvalActionName"] !== undefined) {
        contents.EvalActionName = __expectString(output["EvalActionName"]);
    }
    if (output["EvalResourceName"] !== undefined) {
        contents.EvalResourceName = __expectString(output["EvalResourceName"]);
    }
    if (output["EvalDecision"] !== undefined) {
        contents.EvalDecision = __expectString(output["EvalDecision"]);
    }
    if (output.MatchedStatements === "") {
        contents.MatchedStatements = [];
    }
    else if (output["MatchedStatements"] !== undefined && output["MatchedStatements"]["member"] !== undefined) {
        contents.MatchedStatements = de_StatementListType(__getArrayIfSingleItem(output["MatchedStatements"]["member"]), context);
    }
    if (output.MissingContextValues === "") {
        contents.MissingContextValues = [];
    }
    else if (output["MissingContextValues"] !== undefined && output["MissingContextValues"]["member"] !== undefined) {
        contents.MissingContextValues = de_ContextKeyNamesResultListType(__getArrayIfSingleItem(output["MissingContextValues"]["member"]), context);
    }
    if (output["OrganizationsDecisionDetail"] !== undefined) {
        contents.OrganizationsDecisionDetail = de_OrganizationsDecisionDetail(output["OrganizationsDecisionDetail"], context);
    }
    if (output["PermissionsBoundaryDecisionDetail"] !== undefined) {
        contents.PermissionsBoundaryDecisionDetail = de_PermissionsBoundaryDecisionDetail(output["PermissionsBoundaryDecisionDetail"], context);
    }
    if (output.EvalDecisionDetails === "") {
        contents.EvalDecisionDetails = {};
    }
    else if (output["EvalDecisionDetails"] !== undefined && output["EvalDecisionDetails"]["entry"] !== undefined) {
        contents.EvalDecisionDetails = de_EvalDecisionDetailsType(__getArrayIfSingleItem(output["EvalDecisionDetails"]["entry"]), context);
    }
    if (output.ResourceSpecificResults === "") {
        contents.ResourceSpecificResults = [];
    }
    else if (output["ResourceSpecificResults"] !== undefined &&
        output["ResourceSpecificResults"]["member"] !== undefined) {
        contents.ResourceSpecificResults = de_ResourceSpecificResultListType(__getArrayIfSingleItem(output["ResourceSpecificResults"]["member"]), context);
    }
    return contents;
};
const de_EvaluationResultsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_EvaluationResult(entry, context);
    });
};
const de_GenerateCredentialReportResponse = (output, context) => {
    const contents = {};
    if (output["State"] !== undefined) {
        contents.State = __expectString(output["State"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = __expectString(output["Description"]);
    }
    return contents;
};
const de_GenerateOrganizationsAccessReportResponse = (output, context) => {
    const contents = {};
    if (output["JobId"] !== undefined) {
        contents.JobId = __expectString(output["JobId"]);
    }
    return contents;
};
const de_GenerateServiceLastAccessedDetailsResponse = (output, context) => {
    const contents = {};
    if (output["JobId"] !== undefined) {
        contents.JobId = __expectString(output["JobId"]);
    }
    return contents;
};
const de_GetAccessKeyLastUsedResponse = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["AccessKeyLastUsed"] !== undefined) {
        contents.AccessKeyLastUsed = de_AccessKeyLastUsed(output["AccessKeyLastUsed"], context);
    }
    return contents;
};
const de_GetAccountAuthorizationDetailsResponse = (output, context) => {
    const contents = {};
    if (output.UserDetailList === "") {
        contents.UserDetailList = [];
    }
    else if (output["UserDetailList"] !== undefined && output["UserDetailList"]["member"] !== undefined) {
        contents.UserDetailList = de_userDetailListType(__getArrayIfSingleItem(output["UserDetailList"]["member"]), context);
    }
    if (output.GroupDetailList === "") {
        contents.GroupDetailList = [];
    }
    else if (output["GroupDetailList"] !== undefined && output["GroupDetailList"]["member"] !== undefined) {
        contents.GroupDetailList = de_groupDetailListType(__getArrayIfSingleItem(output["GroupDetailList"]["member"]), context);
    }
    if (output.RoleDetailList === "") {
        contents.RoleDetailList = [];
    }
    else if (output["RoleDetailList"] !== undefined && output["RoleDetailList"]["member"] !== undefined) {
        contents.RoleDetailList = de_roleDetailListType(__getArrayIfSingleItem(output["RoleDetailList"]["member"]), context);
    }
    if (output.Policies === "") {
        contents.Policies = [];
    }
    else if (output["Policies"] !== undefined && output["Policies"]["member"] !== undefined) {
        contents.Policies = de_ManagedPolicyDetailListType(__getArrayIfSingleItem(output["Policies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_GetAccountPasswordPolicyResponse = (output, context) => {
    const contents = {};
    if (output["PasswordPolicy"] !== undefined) {
        contents.PasswordPolicy = de_PasswordPolicy(output["PasswordPolicy"], context);
    }
    return contents;
};
const de_GetAccountSummaryResponse = (output, context) => {
    const contents = {};
    if (output.SummaryMap === "") {
        contents.SummaryMap = {};
    }
    else if (output["SummaryMap"] !== undefined && output["SummaryMap"]["entry"] !== undefined) {
        contents.SummaryMap = de_summaryMapType(__getArrayIfSingleItem(output["SummaryMap"]["entry"]), context);
    }
    return contents;
};
const de_GetContextKeysForPolicyResponse = (output, context) => {
    const contents = {};
    if (output.ContextKeyNames === "") {
        contents.ContextKeyNames = [];
    }
    else if (output["ContextKeyNames"] !== undefined && output["ContextKeyNames"]["member"] !== undefined) {
        contents.ContextKeyNames = de_ContextKeyNamesResultListType(__getArrayIfSingleItem(output["ContextKeyNames"]["member"]), context);
    }
    return contents;
};
const de_GetCredentialReportResponse = (output, context) => {
    const contents = {};
    if (output["Content"] !== undefined) {
        contents.Content = context.base64Decoder(output["Content"]);
    }
    if (output["ReportFormat"] !== undefined) {
        contents.ReportFormat = __expectString(output["ReportFormat"]);
    }
    if (output["GeneratedTime"] !== undefined) {
        contents.GeneratedTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["GeneratedTime"]));
    }
    return contents;
};
const de_GetGroupPolicyResponse = (output, context) => {
    const contents = {};
    if (output["GroupName"] !== undefined) {
        contents.GroupName = __expectString(output["GroupName"]);
    }
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyDocument"] !== undefined) {
        contents.PolicyDocument = __expectString(output["PolicyDocument"]);
    }
    return contents;
};
const de_GetGroupResponse = (output, context) => {
    const contents = {};
    if (output["Group"] !== undefined) {
        contents.Group = de_Group(output["Group"], context);
    }
    if (output.Users === "") {
        contents.Users = [];
    }
    else if (output["Users"] !== undefined && output["Users"]["member"] !== undefined) {
        contents.Users = de_userListType(__getArrayIfSingleItem(output["Users"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_GetInstanceProfileResponse = (output, context) => {
    const contents = {};
    if (output["InstanceProfile"] !== undefined) {
        contents.InstanceProfile = de_InstanceProfile(output["InstanceProfile"], context);
    }
    return contents;
};
const de_GetLoginProfileResponse = (output, context) => {
    const contents = {};
    if (output["LoginProfile"] !== undefined) {
        contents.LoginProfile = de_LoginProfile(output["LoginProfile"], context);
    }
    return contents;
};
const de_GetMFADeviceResponse = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["SerialNumber"] !== undefined) {
        contents.SerialNumber = __expectString(output["SerialNumber"]);
    }
    if (output["EnableDate"] !== undefined) {
        contents.EnableDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["EnableDate"]));
    }
    if (output.Certifications === "") {
        contents.Certifications = {};
    }
    else if (output["Certifications"] !== undefined && output["Certifications"]["entry"] !== undefined) {
        contents.Certifications = de_CertificationMapType(__getArrayIfSingleItem(output["Certifications"]["entry"]), context);
    }
    return contents;
};
const de_GetOpenIDConnectProviderResponse = (output, context) => {
    const contents = {};
    if (output["Url"] !== undefined) {
        contents.Url = __expectString(output["Url"]);
    }
    if (output.ClientIDList === "") {
        contents.ClientIDList = [];
    }
    else if (output["ClientIDList"] !== undefined && output["ClientIDList"]["member"] !== undefined) {
        contents.ClientIDList = de_clientIDListType(__getArrayIfSingleItem(output["ClientIDList"]["member"]), context);
    }
    if (output.ThumbprintList === "") {
        contents.ThumbprintList = [];
    }
    else if (output["ThumbprintList"] !== undefined && output["ThumbprintList"]["member"] !== undefined) {
        contents.ThumbprintList = de_thumbprintListType(__getArrayIfSingleItem(output["ThumbprintList"]["member"]), context);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_GetOrganizationsAccessReportResponse = (output, context) => {
    const contents = {};
    if (output["JobStatus"] !== undefined) {
        contents.JobStatus = __expectString(output["JobStatus"]);
    }
    if (output["JobCreationDate"] !== undefined) {
        contents.JobCreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["JobCreationDate"]));
    }
    if (output["JobCompletionDate"] !== undefined) {
        contents.JobCompletionDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["JobCompletionDate"]));
    }
    if (output["NumberOfServicesAccessible"] !== undefined) {
        contents.NumberOfServicesAccessible = __strictParseInt32(output["NumberOfServicesAccessible"]);
    }
    if (output["NumberOfServicesNotAccessed"] !== undefined) {
        contents.NumberOfServicesNotAccessed = __strictParseInt32(output["NumberOfServicesNotAccessed"]);
    }
    if (output.AccessDetails === "") {
        contents.AccessDetails = [];
    }
    else if (output["AccessDetails"] !== undefined && output["AccessDetails"]["member"] !== undefined) {
        contents.AccessDetails = de_AccessDetails(__getArrayIfSingleItem(output["AccessDetails"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    if (output["ErrorDetails"] !== undefined) {
        contents.ErrorDetails = de_ErrorDetails(output["ErrorDetails"], context);
    }
    return contents;
};
const de_GetPolicyResponse = (output, context) => {
    const contents = {};
    if (output["Policy"] !== undefined) {
        contents.Policy = de_Policy(output["Policy"], context);
    }
    return contents;
};
const de_GetPolicyVersionResponse = (output, context) => {
    const contents = {};
    if (output["PolicyVersion"] !== undefined) {
        contents.PolicyVersion = de_PolicyVersion(output["PolicyVersion"], context);
    }
    return contents;
};
const de_GetRolePolicyResponse = (output, context) => {
    const contents = {};
    if (output["RoleName"] !== undefined) {
        contents.RoleName = __expectString(output["RoleName"]);
    }
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyDocument"] !== undefined) {
        contents.PolicyDocument = __expectString(output["PolicyDocument"]);
    }
    return contents;
};
const de_GetRoleResponse = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = de_Role(output["Role"], context);
    }
    return contents;
};
const de_GetSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output["SAMLMetadataDocument"] !== undefined) {
        contents.SAMLMetadataDocument = __expectString(output["SAMLMetadataDocument"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["ValidUntil"] !== undefined) {
        contents.ValidUntil = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["ValidUntil"]));
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_GetServerCertificateResponse = (output, context) => {
    const contents = {};
    if (output["ServerCertificate"] !== undefined) {
        contents.ServerCertificate = de_ServerCertificate(output["ServerCertificate"], context);
    }
    return contents;
};
const de_GetServiceLastAccessedDetailsResponse = (output, context) => {
    const contents = {};
    if (output["JobStatus"] !== undefined) {
        contents.JobStatus = __expectString(output["JobStatus"]);
    }
    if (output["JobType"] !== undefined) {
        contents.JobType = __expectString(output["JobType"]);
    }
    if (output["JobCreationDate"] !== undefined) {
        contents.JobCreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["JobCreationDate"]));
    }
    if (output.ServicesLastAccessed === "") {
        contents.ServicesLastAccessed = [];
    }
    else if (output["ServicesLastAccessed"] !== undefined && output["ServicesLastAccessed"]["member"] !== undefined) {
        contents.ServicesLastAccessed = de_ServicesLastAccessed(__getArrayIfSingleItem(output["ServicesLastAccessed"]["member"]), context);
    }
    if (output["JobCompletionDate"] !== undefined) {
        contents.JobCompletionDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["JobCompletionDate"]));
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    if (output["Error"] !== undefined) {
        contents.Error = de_ErrorDetails(output["Error"], context);
    }
    return contents;
};
const de_GetServiceLastAccessedDetailsWithEntitiesResponse = (output, context) => {
    const contents = {};
    if (output["JobStatus"] !== undefined) {
        contents.JobStatus = __expectString(output["JobStatus"]);
    }
    if (output["JobCreationDate"] !== undefined) {
        contents.JobCreationDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["JobCreationDate"]));
    }
    if (output["JobCompletionDate"] !== undefined) {
        contents.JobCompletionDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["JobCompletionDate"]));
    }
    if (output.EntityDetailsList === "") {
        contents.EntityDetailsList = [];
    }
    else if (output["EntityDetailsList"] !== undefined && output["EntityDetailsList"]["member"] !== undefined) {
        contents.EntityDetailsList = de_entityDetailsListType(__getArrayIfSingleItem(output["EntityDetailsList"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    if (output["Error"] !== undefined) {
        contents.Error = de_ErrorDetails(output["Error"], context);
    }
    return contents;
};
const de_GetServiceLinkedRoleDeletionStatusResponse = (output, context) => {
    const contents = {};
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["Reason"] !== undefined) {
        contents.Reason = de_DeletionTaskFailureReasonType(output["Reason"], context);
    }
    return contents;
};
const de_GetSSHPublicKeyResponse = (output, context) => {
    const contents = {};
    if (output["SSHPublicKey"] !== undefined) {
        contents.SSHPublicKey = de_SSHPublicKey(output["SSHPublicKey"], context);
    }
    return contents;
};
const de_GetUserPolicyResponse = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyDocument"] !== undefined) {
        contents.PolicyDocument = __expectString(output["PolicyDocument"]);
    }
    return contents;
};
const de_GetUserResponse = (output, context) => {
    const contents = {};
    if (output["User"] !== undefined) {
        contents.User = de_User(output["User"], context);
    }
    return contents;
};
const de_Group = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["GroupName"] !== undefined) {
        contents.GroupName = __expectString(output["GroupName"]);
    }
    if (output["GroupId"] !== undefined) {
        contents.GroupId = __expectString(output["GroupId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    return contents;
};
const de_GroupDetail = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["GroupName"] !== undefined) {
        contents.GroupName = __expectString(output["GroupName"]);
    }
    if (output["GroupId"] !== undefined) {
        contents.GroupId = __expectString(output["GroupId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output.GroupPolicyList === "") {
        contents.GroupPolicyList = [];
    }
    else if (output["GroupPolicyList"] !== undefined && output["GroupPolicyList"]["member"] !== undefined) {
        contents.GroupPolicyList = de_policyDetailListType(__getArrayIfSingleItem(output["GroupPolicyList"]["member"]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents.AttachedManagedPolicies = [];
    }
    else if (output["AttachedManagedPolicies"] !== undefined &&
        output["AttachedManagedPolicies"]["member"] !== undefined) {
        contents.AttachedManagedPolicies = de_attachedPoliciesListType(__getArrayIfSingleItem(output["AttachedManagedPolicies"]["member"]), context);
    }
    return contents;
};
const de_groupDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_GroupDetail(entry, context);
    });
};
const de_groupListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Group(entry, context);
    });
};
const de_groupNameListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_InstanceProfile = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["InstanceProfileName"] !== undefined) {
        contents.InstanceProfileName = __expectString(output["InstanceProfileName"]);
    }
    if (output["InstanceProfileId"] !== undefined) {
        contents.InstanceProfileId = __expectString(output["InstanceProfileId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output.Roles === "") {
        contents.Roles = [];
    }
    else if (output["Roles"] !== undefined && output["Roles"]["member"] !== undefined) {
        contents.Roles = de_roleListType(__getArrayIfSingleItem(output["Roles"]["member"]), context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_instanceProfileListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_InstanceProfile(entry, context);
    });
};
const de_InvalidAuthenticationCodeException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_InvalidCertificateException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_InvalidInputException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_InvalidPublicKeyException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_InvalidUserTypeException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_KeyPairMismatchException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_LimitExceededException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ListAccessKeysResponse = (output, context) => {
    const contents = {};
    if (output.AccessKeyMetadata === "") {
        contents.AccessKeyMetadata = [];
    }
    else if (output["AccessKeyMetadata"] !== undefined && output["AccessKeyMetadata"]["member"] !== undefined) {
        contents.AccessKeyMetadata = de_accessKeyMetadataListType(__getArrayIfSingleItem(output["AccessKeyMetadata"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListAccountAliasesResponse = (output, context) => {
    const contents = {};
    if (output.AccountAliases === "") {
        contents.AccountAliases = [];
    }
    else if (output["AccountAliases"] !== undefined && output["AccountAliases"]["member"] !== undefined) {
        contents.AccountAliases = de_accountAliasListType(__getArrayIfSingleItem(output["AccountAliases"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListAttachedGroupPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents.AttachedPolicies = [];
    }
    else if (output["AttachedPolicies"] !== undefined && output["AttachedPolicies"]["member"] !== undefined) {
        contents.AttachedPolicies = de_attachedPoliciesListType(__getArrayIfSingleItem(output["AttachedPolicies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListAttachedRolePoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents.AttachedPolicies = [];
    }
    else if (output["AttachedPolicies"] !== undefined && output["AttachedPolicies"]["member"] !== undefined) {
        contents.AttachedPolicies = de_attachedPoliciesListType(__getArrayIfSingleItem(output["AttachedPolicies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListAttachedUserPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.AttachedPolicies === "") {
        contents.AttachedPolicies = [];
    }
    else if (output["AttachedPolicies"] !== undefined && output["AttachedPolicies"]["member"] !== undefined) {
        contents.AttachedPolicies = de_attachedPoliciesListType(__getArrayIfSingleItem(output["AttachedPolicies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListEntitiesForPolicyResponse = (output, context) => {
    const contents = {};
    if (output.PolicyGroups === "") {
        contents.PolicyGroups = [];
    }
    else if (output["PolicyGroups"] !== undefined && output["PolicyGroups"]["member"] !== undefined) {
        contents.PolicyGroups = de_PolicyGroupListType(__getArrayIfSingleItem(output["PolicyGroups"]["member"]), context);
    }
    if (output.PolicyUsers === "") {
        contents.PolicyUsers = [];
    }
    else if (output["PolicyUsers"] !== undefined && output["PolicyUsers"]["member"] !== undefined) {
        contents.PolicyUsers = de_PolicyUserListType(__getArrayIfSingleItem(output["PolicyUsers"]["member"]), context);
    }
    if (output.PolicyRoles === "") {
        contents.PolicyRoles = [];
    }
    else if (output["PolicyRoles"] !== undefined && output["PolicyRoles"]["member"] !== undefined) {
        contents.PolicyRoles = de_PolicyRoleListType(__getArrayIfSingleItem(output["PolicyRoles"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListGroupPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents.PolicyNames = [];
    }
    else if (output["PolicyNames"] !== undefined && output["PolicyNames"]["member"] !== undefined) {
        contents.PolicyNames = de_policyNameListType(__getArrayIfSingleItem(output["PolicyNames"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListGroupsForUserResponse = (output, context) => {
    const contents = {};
    if (output.Groups === "") {
        contents.Groups = [];
    }
    else if (output["Groups"] !== undefined && output["Groups"]["member"] !== undefined) {
        contents.Groups = de_groupListType(__getArrayIfSingleItem(output["Groups"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListGroupsResponse = (output, context) => {
    const contents = {};
    if (output.Groups === "") {
        contents.Groups = [];
    }
    else if (output["Groups"] !== undefined && output["Groups"]["member"] !== undefined) {
        contents.Groups = de_groupListType(__getArrayIfSingleItem(output["Groups"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListInstanceProfilesForRoleResponse = (output, context) => {
    const contents = {};
    if (output.InstanceProfiles === "") {
        contents.InstanceProfiles = [];
    }
    else if (output["InstanceProfiles"] !== undefined && output["InstanceProfiles"]["member"] !== undefined) {
        contents.InstanceProfiles = de_instanceProfileListType(__getArrayIfSingleItem(output["InstanceProfiles"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListInstanceProfilesResponse = (output, context) => {
    const contents = {};
    if (output.InstanceProfiles === "") {
        contents.InstanceProfiles = [];
    }
    else if (output["InstanceProfiles"] !== undefined && output["InstanceProfiles"]["member"] !== undefined) {
        contents.InstanceProfiles = de_instanceProfileListType(__getArrayIfSingleItem(output["InstanceProfiles"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListInstanceProfileTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListMFADevicesResponse = (output, context) => {
    const contents = {};
    if (output.MFADevices === "") {
        contents.MFADevices = [];
    }
    else if (output["MFADevices"] !== undefined && output["MFADevices"]["member"] !== undefined) {
        contents.MFADevices = de_mfaDeviceListType(__getArrayIfSingleItem(output["MFADevices"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListMFADeviceTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListOpenIDConnectProvidersResponse = (output, context) => {
    const contents = {};
    if (output.OpenIDConnectProviderList === "") {
        contents.OpenIDConnectProviderList = [];
    }
    else if (output["OpenIDConnectProviderList"] !== undefined &&
        output["OpenIDConnectProviderList"]["member"] !== undefined) {
        contents.OpenIDConnectProviderList = de_OpenIDConnectProviderListType(__getArrayIfSingleItem(output["OpenIDConnectProviderList"]["member"]), context);
    }
    return contents;
};
const de_ListOpenIDConnectProviderTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListPoliciesGrantingServiceAccessEntry = (output, context) => {
    const contents = {};
    if (output["ServiceNamespace"] !== undefined) {
        contents.ServiceNamespace = __expectString(output["ServiceNamespace"]);
    }
    if (output.Policies === "") {
        contents.Policies = [];
    }
    else if (output["Policies"] !== undefined && output["Policies"]["member"] !== undefined) {
        contents.Policies = de_policyGrantingServiceAccessListType(__getArrayIfSingleItem(output["Policies"]["member"]), context);
    }
    return contents;
};
const de_ListPoliciesGrantingServiceAccessResponse = (output, context) => {
    const contents = {};
    if (output.PoliciesGrantingServiceAccess === "") {
        contents.PoliciesGrantingServiceAccess = [];
    }
    else if (output["PoliciesGrantingServiceAccess"] !== undefined &&
        output["PoliciesGrantingServiceAccess"]["member"] !== undefined) {
        contents.PoliciesGrantingServiceAccess = de_listPolicyGrantingServiceAccessResponseListType(__getArrayIfSingleItem(output["PoliciesGrantingServiceAccess"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.Policies === "") {
        contents.Policies = [];
    }
    else if (output["Policies"] !== undefined && output["Policies"]["member"] !== undefined) {
        contents.Policies = de_policyListType(__getArrayIfSingleItem(output["Policies"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_listPolicyGrantingServiceAccessResponseListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ListPoliciesGrantingServiceAccessEntry(entry, context);
    });
};
const de_ListPolicyTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListPolicyVersionsResponse = (output, context) => {
    const contents = {};
    if (output.Versions === "") {
        contents.Versions = [];
    }
    else if (output["Versions"] !== undefined && output["Versions"]["member"] !== undefined) {
        contents.Versions = de_policyDocumentVersionListType(__getArrayIfSingleItem(output["Versions"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListRolePoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents.PolicyNames = [];
    }
    else if (output["PolicyNames"] !== undefined && output["PolicyNames"]["member"] !== undefined) {
        contents.PolicyNames = de_policyNameListType(__getArrayIfSingleItem(output["PolicyNames"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListRolesResponse = (output, context) => {
    const contents = {};
    if (output.Roles === "") {
        contents.Roles = [];
    }
    else if (output["Roles"] !== undefined && output["Roles"]["member"] !== undefined) {
        contents.Roles = de_roleListType(__getArrayIfSingleItem(output["Roles"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListRoleTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListSAMLProvidersResponse = (output, context) => {
    const contents = {};
    if (output.SAMLProviderList === "") {
        contents.SAMLProviderList = [];
    }
    else if (output["SAMLProviderList"] !== undefined && output["SAMLProviderList"]["member"] !== undefined) {
        contents.SAMLProviderList = de_SAMLProviderListType(__getArrayIfSingleItem(output["SAMLProviderList"]["member"]), context);
    }
    return contents;
};
const de_ListSAMLProviderTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListServerCertificatesResponse = (output, context) => {
    const contents = {};
    if (output.ServerCertificateMetadataList === "") {
        contents.ServerCertificateMetadataList = [];
    }
    else if (output["ServerCertificateMetadataList"] !== undefined &&
        output["ServerCertificateMetadataList"]["member"] !== undefined) {
        contents.ServerCertificateMetadataList = de_serverCertificateMetadataListType(__getArrayIfSingleItem(output["ServerCertificateMetadataList"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListServerCertificateTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListServiceSpecificCredentialsResponse = (output, context) => {
    const contents = {};
    if (output.ServiceSpecificCredentials === "") {
        contents.ServiceSpecificCredentials = [];
    }
    else if (output["ServiceSpecificCredentials"] !== undefined &&
        output["ServiceSpecificCredentials"]["member"] !== undefined) {
        contents.ServiceSpecificCredentials = de_ServiceSpecificCredentialsListType(__getArrayIfSingleItem(output["ServiceSpecificCredentials"]["member"]), context);
    }
    return contents;
};
const de_ListSigningCertificatesResponse = (output, context) => {
    const contents = {};
    if (output.Certificates === "") {
        contents.Certificates = [];
    }
    else if (output["Certificates"] !== undefined && output["Certificates"]["member"] !== undefined) {
        contents.Certificates = de_certificateListType(__getArrayIfSingleItem(output["Certificates"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListSSHPublicKeysResponse = (output, context) => {
    const contents = {};
    if (output.SSHPublicKeys === "") {
        contents.SSHPublicKeys = [];
    }
    else if (output["SSHPublicKeys"] !== undefined && output["SSHPublicKeys"]["member"] !== undefined) {
        contents.SSHPublicKeys = de_SSHPublicKeyListType(__getArrayIfSingleItem(output["SSHPublicKeys"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListUserPoliciesResponse = (output, context) => {
    const contents = {};
    if (output.PolicyNames === "") {
        contents.PolicyNames = [];
    }
    else if (output["PolicyNames"] !== undefined && output["PolicyNames"]["member"] !== undefined) {
        contents.PolicyNames = de_policyNameListType(__getArrayIfSingleItem(output["PolicyNames"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListUsersResponse = (output, context) => {
    const contents = {};
    if (output.Users === "") {
        contents.Users = [];
    }
    else if (output["Users"] !== undefined && output["Users"]["member"] !== undefined) {
        contents.Users = de_userListType(__getArrayIfSingleItem(output["Users"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListUserTagsResponse = (output, context) => {
    const contents = {};
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_ListVirtualMFADevicesResponse = (output, context) => {
    const contents = {};
    if (output.VirtualMFADevices === "") {
        contents.VirtualMFADevices = [];
    }
    else if (output["VirtualMFADevices"] !== undefined && output["VirtualMFADevices"]["member"] !== undefined) {
        contents.VirtualMFADevices = de_virtualMFADeviceListType(__getArrayIfSingleItem(output["VirtualMFADevices"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_LoginProfile = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["PasswordResetRequired"] !== undefined) {
        contents.PasswordResetRequired = __parseBoolean(output["PasswordResetRequired"]);
    }
    return contents;
};
const de_MalformedCertificateException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_MalformedPolicyDocumentException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ManagedPolicyDetail = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyId"] !== undefined) {
        contents.PolicyId = __expectString(output["PolicyId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["DefaultVersionId"] !== undefined) {
        contents.DefaultVersionId = __expectString(output["DefaultVersionId"]);
    }
    if (output["AttachmentCount"] !== undefined) {
        contents.AttachmentCount = __strictParseInt32(output["AttachmentCount"]);
    }
    if (output["PermissionsBoundaryUsageCount"] !== undefined) {
        contents.PermissionsBoundaryUsageCount = __strictParseInt32(output["PermissionsBoundaryUsageCount"]);
    }
    if (output["IsAttachable"] !== undefined) {
        contents.IsAttachable = __parseBoolean(output["IsAttachable"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = __expectString(output["Description"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["UpdateDate"] !== undefined) {
        contents.UpdateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["UpdateDate"]));
    }
    if (output.PolicyVersionList === "") {
        contents.PolicyVersionList = [];
    }
    else if (output["PolicyVersionList"] !== undefined && output["PolicyVersionList"]["member"] !== undefined) {
        contents.PolicyVersionList = de_policyDocumentVersionListType(__getArrayIfSingleItem(output["PolicyVersionList"]["member"]), context);
    }
    return contents;
};
const de_ManagedPolicyDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ManagedPolicyDetail(entry, context);
    });
};
const de_MFADevice = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["SerialNumber"] !== undefined) {
        contents.SerialNumber = __expectString(output["SerialNumber"]);
    }
    if (output["EnableDate"] !== undefined) {
        contents.EnableDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["EnableDate"]));
    }
    return contents;
};
const de_mfaDeviceListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MFADevice(entry, context);
    });
};
const de_NoSuchEntityException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_OpenIDConnectProviderListEntry = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    return contents;
};
const de_OpenIDConnectProviderListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OpenIDConnectProviderListEntry(entry, context);
    });
};
const de_OrganizationsDecisionDetail = (output, context) => {
    const contents = {};
    if (output["AllowedByOrganizations"] !== undefined) {
        contents.AllowedByOrganizations = __parseBoolean(output["AllowedByOrganizations"]);
    }
    return contents;
};
const de_PasswordPolicy = (output, context) => {
    const contents = {};
    if (output["MinimumPasswordLength"] !== undefined) {
        contents.MinimumPasswordLength = __strictParseInt32(output["MinimumPasswordLength"]);
    }
    if (output["RequireSymbols"] !== undefined) {
        contents.RequireSymbols = __parseBoolean(output["RequireSymbols"]);
    }
    if (output["RequireNumbers"] !== undefined) {
        contents.RequireNumbers = __parseBoolean(output["RequireNumbers"]);
    }
    if (output["RequireUppercaseCharacters"] !== undefined) {
        contents.RequireUppercaseCharacters = __parseBoolean(output["RequireUppercaseCharacters"]);
    }
    if (output["RequireLowercaseCharacters"] !== undefined) {
        contents.RequireLowercaseCharacters = __parseBoolean(output["RequireLowercaseCharacters"]);
    }
    if (output["AllowUsersToChangePassword"] !== undefined) {
        contents.AllowUsersToChangePassword = __parseBoolean(output["AllowUsersToChangePassword"]);
    }
    if (output["ExpirePasswords"] !== undefined) {
        contents.ExpirePasswords = __parseBoolean(output["ExpirePasswords"]);
    }
    if (output["MaxPasswordAge"] !== undefined) {
        contents.MaxPasswordAge = __strictParseInt32(output["MaxPasswordAge"]);
    }
    if (output["PasswordReusePrevention"] !== undefined) {
        contents.PasswordReusePrevention = __strictParseInt32(output["PasswordReusePrevention"]);
    }
    if (output["HardExpiry"] !== undefined) {
        contents.HardExpiry = __parseBoolean(output["HardExpiry"]);
    }
    return contents;
};
const de_PasswordPolicyViolationException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_PermissionsBoundaryDecisionDetail = (output, context) => {
    const contents = {};
    if (output["AllowedByPermissionsBoundary"] !== undefined) {
        contents.AllowedByPermissionsBoundary = __parseBoolean(output["AllowedByPermissionsBoundary"]);
    }
    return contents;
};
const de_Policy = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyId"] !== undefined) {
        contents.PolicyId = __expectString(output["PolicyId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["DefaultVersionId"] !== undefined) {
        contents.DefaultVersionId = __expectString(output["DefaultVersionId"]);
    }
    if (output["AttachmentCount"] !== undefined) {
        contents.AttachmentCount = __strictParseInt32(output["AttachmentCount"]);
    }
    if (output["PermissionsBoundaryUsageCount"] !== undefined) {
        contents.PermissionsBoundaryUsageCount = __strictParseInt32(output["PermissionsBoundaryUsageCount"]);
    }
    if (output["IsAttachable"] !== undefined) {
        contents.IsAttachable = __parseBoolean(output["IsAttachable"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = __expectString(output["Description"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["UpdateDate"] !== undefined) {
        contents.UpdateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["UpdateDate"]));
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_PolicyDetail = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyDocument"] !== undefined) {
        contents.PolicyDocument = __expectString(output["PolicyDocument"]);
    }
    return contents;
};
const de_policyDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyDetail(entry, context);
    });
};
const de_policyDocumentVersionListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyVersion(entry, context);
    });
};
const de_PolicyEvaluationException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_PolicyGrantingServiceAccess = (output, context) => {
    const contents = {};
    if (output["PolicyName"] !== undefined) {
        contents.PolicyName = __expectString(output["PolicyName"]);
    }
    if (output["PolicyType"] !== undefined) {
        contents.PolicyType = __expectString(output["PolicyType"]);
    }
    if (output["PolicyArn"] !== undefined) {
        contents.PolicyArn = __expectString(output["PolicyArn"]);
    }
    if (output["EntityType"] !== undefined) {
        contents.EntityType = __expectString(output["EntityType"]);
    }
    if (output["EntityName"] !== undefined) {
        contents.EntityName = __expectString(output["EntityName"]);
    }
    return contents;
};
const de_policyGrantingServiceAccessListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyGrantingServiceAccess(entry, context);
    });
};
const de_PolicyGroup = (output, context) => {
    const contents = {};
    if (output["GroupName"] !== undefined) {
        contents.GroupName = __expectString(output["GroupName"]);
    }
    if (output["GroupId"] !== undefined) {
        contents.GroupId = __expectString(output["GroupId"]);
    }
    return contents;
};
const de_PolicyGroupListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyGroup(entry, context);
    });
};
const de_policyListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Policy(entry, context);
    });
};
const de_policyNameListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_PolicyNotAttachableException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_PolicyRole = (output, context) => {
    const contents = {};
    if (output["RoleName"] !== undefined) {
        contents.RoleName = __expectString(output["RoleName"]);
    }
    if (output["RoleId"] !== undefined) {
        contents.RoleId = __expectString(output["RoleId"]);
    }
    return contents;
};
const de_PolicyRoleListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyRole(entry, context);
    });
};
const de_PolicyUser = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["UserId"] !== undefined) {
        contents.UserId = __expectString(output["UserId"]);
    }
    return contents;
};
const de_PolicyUserListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyUser(entry, context);
    });
};
const de_PolicyVersion = (output, context) => {
    const contents = {};
    if (output["Document"] !== undefined) {
        contents.Document = __expectString(output["Document"]);
    }
    if (output["VersionId"] !== undefined) {
        contents.VersionId = __expectString(output["VersionId"]);
    }
    if (output["IsDefaultVersion"] !== undefined) {
        contents.IsDefaultVersion = __parseBoolean(output["IsDefaultVersion"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    return contents;
};
const de_Position = (output, context) => {
    const contents = {};
    if (output["Line"] !== undefined) {
        contents.Line = __strictParseInt32(output["Line"]);
    }
    if (output["Column"] !== undefined) {
        contents.Column = __strictParseInt32(output["Column"]);
    }
    return contents;
};
const de_ReportGenerationLimitExceededException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ResetServiceSpecificCredentialResponse = (output, context) => {
    const contents = {};
    if (output["ServiceSpecificCredential"] !== undefined) {
        contents.ServiceSpecificCredential = de_ServiceSpecificCredential(output["ServiceSpecificCredential"], context);
    }
    return contents;
};
const de_ResourceSpecificResult = (output, context) => {
    const contents = {};
    if (output["EvalResourceName"] !== undefined) {
        contents.EvalResourceName = __expectString(output["EvalResourceName"]);
    }
    if (output["EvalResourceDecision"] !== undefined) {
        contents.EvalResourceDecision = __expectString(output["EvalResourceDecision"]);
    }
    if (output.MatchedStatements === "") {
        contents.MatchedStatements = [];
    }
    else if (output["MatchedStatements"] !== undefined && output["MatchedStatements"]["member"] !== undefined) {
        contents.MatchedStatements = de_StatementListType(__getArrayIfSingleItem(output["MatchedStatements"]["member"]), context);
    }
    if (output.MissingContextValues === "") {
        contents.MissingContextValues = [];
    }
    else if (output["MissingContextValues"] !== undefined && output["MissingContextValues"]["member"] !== undefined) {
        contents.MissingContextValues = de_ContextKeyNamesResultListType(__getArrayIfSingleItem(output["MissingContextValues"]["member"]), context);
    }
    if (output.EvalDecisionDetails === "") {
        contents.EvalDecisionDetails = {};
    }
    else if (output["EvalDecisionDetails"] !== undefined && output["EvalDecisionDetails"]["entry"] !== undefined) {
        contents.EvalDecisionDetails = de_EvalDecisionDetailsType(__getArrayIfSingleItem(output["EvalDecisionDetails"]["entry"]), context);
    }
    if (output["PermissionsBoundaryDecisionDetail"] !== undefined) {
        contents.PermissionsBoundaryDecisionDetail = de_PermissionsBoundaryDecisionDetail(output["PermissionsBoundaryDecisionDetail"], context);
    }
    return contents;
};
const de_ResourceSpecificResultListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ResourceSpecificResult(entry, context);
    });
};
const de_Role = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["RoleName"] !== undefined) {
        contents.RoleName = __expectString(output["RoleName"]);
    }
    if (output["RoleId"] !== undefined) {
        contents.RoleId = __expectString(output["RoleId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["AssumeRolePolicyDocument"] !== undefined) {
        contents.AssumeRolePolicyDocument = __expectString(output["AssumeRolePolicyDocument"]);
    }
    if (output["Description"] !== undefined) {
        contents.Description = __expectString(output["Description"]);
    }
    if (output["MaxSessionDuration"] !== undefined) {
        contents.MaxSessionDuration = __strictParseInt32(output["MaxSessionDuration"]);
    }
    if (output["PermissionsBoundary"] !== undefined) {
        contents.PermissionsBoundary = de_AttachedPermissionsBoundary(output["PermissionsBoundary"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["RoleLastUsed"] !== undefined) {
        contents.RoleLastUsed = de_RoleLastUsed(output["RoleLastUsed"], context);
    }
    return contents;
};
const de_RoleDetail = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["RoleName"] !== undefined) {
        contents.RoleName = __expectString(output["RoleName"]);
    }
    if (output["RoleId"] !== undefined) {
        contents.RoleId = __expectString(output["RoleId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["AssumeRolePolicyDocument"] !== undefined) {
        contents.AssumeRolePolicyDocument = __expectString(output["AssumeRolePolicyDocument"]);
    }
    if (output.InstanceProfileList === "") {
        contents.InstanceProfileList = [];
    }
    else if (output["InstanceProfileList"] !== undefined && output["InstanceProfileList"]["member"] !== undefined) {
        contents.InstanceProfileList = de_instanceProfileListType(__getArrayIfSingleItem(output["InstanceProfileList"]["member"]), context);
    }
    if (output.RolePolicyList === "") {
        contents.RolePolicyList = [];
    }
    else if (output["RolePolicyList"] !== undefined && output["RolePolicyList"]["member"] !== undefined) {
        contents.RolePolicyList = de_policyDetailListType(__getArrayIfSingleItem(output["RolePolicyList"]["member"]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents.AttachedManagedPolicies = [];
    }
    else if (output["AttachedManagedPolicies"] !== undefined &&
        output["AttachedManagedPolicies"]["member"] !== undefined) {
        contents.AttachedManagedPolicies = de_attachedPoliciesListType(__getArrayIfSingleItem(output["AttachedManagedPolicies"]["member"]), context);
    }
    if (output["PermissionsBoundary"] !== undefined) {
        contents.PermissionsBoundary = de_AttachedPermissionsBoundary(output["PermissionsBoundary"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    if (output["RoleLastUsed"] !== undefined) {
        contents.RoleLastUsed = de_RoleLastUsed(output["RoleLastUsed"], context);
    }
    return contents;
};
const de_roleDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoleDetail(entry, context);
    });
};
const de_RoleLastUsed = (output, context) => {
    const contents = {};
    if (output["LastUsedDate"] !== undefined) {
        contents.LastUsedDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastUsedDate"]));
    }
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    return contents;
};
const de_roleListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Role(entry, context);
    });
};
const de_RoleUsageListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RoleUsageType(entry, context);
    });
};
const de_RoleUsageType = (output, context) => {
    const contents = {};
    if (output["Region"] !== undefined) {
        contents.Region = __expectString(output["Region"]);
    }
    if (output.Resources === "") {
        contents.Resources = [];
    }
    else if (output["Resources"] !== undefined && output["Resources"]["member"] !== undefined) {
        contents.Resources = de_ArnListType(__getArrayIfSingleItem(output["Resources"]["member"]), context);
    }
    return contents;
};
const de_SAMLProviderListEntry = (output, context) => {
    const contents = {};
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["ValidUntil"] !== undefined) {
        contents.ValidUntil = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["ValidUntil"]));
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    return contents;
};
const de_SAMLProviderListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SAMLProviderListEntry(entry, context);
    });
};
const de_ServerCertificate = (output, context) => {
    const contents = {};
    if (output["ServerCertificateMetadata"] !== undefined) {
        contents.ServerCertificateMetadata = de_ServerCertificateMetadata(output["ServerCertificateMetadata"], context);
    }
    if (output["CertificateBody"] !== undefined) {
        contents.CertificateBody = __expectString(output["CertificateBody"]);
    }
    if (output["CertificateChain"] !== undefined) {
        contents.CertificateChain = __expectString(output["CertificateChain"]);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_ServerCertificateMetadata = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["ServerCertificateName"] !== undefined) {
        contents.ServerCertificateName = __expectString(output["ServerCertificateName"]);
    }
    if (output["ServerCertificateId"] !== undefined) {
        contents.ServerCertificateId = __expectString(output["ServerCertificateId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["UploadDate"] !== undefined) {
        contents.UploadDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["UploadDate"]));
    }
    if (output["Expiration"] !== undefined) {
        contents.Expiration = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["Expiration"]));
    }
    return contents;
};
const de_serverCertificateMetadataListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServerCertificateMetadata(entry, context);
    });
};
const de_ServiceFailureException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ServiceLastAccessed = (output, context) => {
    const contents = {};
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = __expectString(output["ServiceName"]);
    }
    if (output["LastAuthenticated"] !== undefined) {
        contents.LastAuthenticated = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastAuthenticated"]));
    }
    if (output["ServiceNamespace"] !== undefined) {
        contents.ServiceNamespace = __expectString(output["ServiceNamespace"]);
    }
    if (output["LastAuthenticatedEntity"] !== undefined) {
        contents.LastAuthenticatedEntity = __expectString(output["LastAuthenticatedEntity"]);
    }
    if (output["LastAuthenticatedRegion"] !== undefined) {
        contents.LastAuthenticatedRegion = __expectString(output["LastAuthenticatedRegion"]);
    }
    if (output["TotalAuthenticatedEntities"] !== undefined) {
        contents.TotalAuthenticatedEntities = __strictParseInt32(output["TotalAuthenticatedEntities"]);
    }
    if (output.TrackedActionsLastAccessed === "") {
        contents.TrackedActionsLastAccessed = [];
    }
    else if (output["TrackedActionsLastAccessed"] !== undefined &&
        output["TrackedActionsLastAccessed"]["member"] !== undefined) {
        contents.TrackedActionsLastAccessed = de_TrackedActionsLastAccessed(__getArrayIfSingleItem(output["TrackedActionsLastAccessed"]["member"]), context);
    }
    return contents;
};
const de_ServiceNotSupportedException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_ServicesLastAccessed = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceLastAccessed(entry, context);
    });
};
const de_ServiceSpecificCredential = (output, context) => {
    const contents = {};
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = __expectString(output["ServiceName"]);
    }
    if (output["ServiceUserName"] !== undefined) {
        contents.ServiceUserName = __expectString(output["ServiceUserName"]);
    }
    if (output["ServicePassword"] !== undefined) {
        contents.ServicePassword = __expectString(output["ServicePassword"]);
    }
    if (output["ServiceSpecificCredentialId"] !== undefined) {
        contents.ServiceSpecificCredentialId = __expectString(output["ServiceSpecificCredentialId"]);
    }
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    return contents;
};
const de_ServiceSpecificCredentialMetadata = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["ServiceUserName"] !== undefined) {
        contents.ServiceUserName = __expectString(output["ServiceUserName"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["ServiceSpecificCredentialId"] !== undefined) {
        contents.ServiceSpecificCredentialId = __expectString(output["ServiceSpecificCredentialId"]);
    }
    if (output["ServiceName"] !== undefined) {
        contents.ServiceName = __expectString(output["ServiceName"]);
    }
    return contents;
};
const de_ServiceSpecificCredentialsListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ServiceSpecificCredentialMetadata(entry, context);
    });
};
const de_SigningCertificate = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["CertificateId"] !== undefined) {
        contents.CertificateId = __expectString(output["CertificateId"]);
    }
    if (output["CertificateBody"] !== undefined) {
        contents.CertificateBody = __expectString(output["CertificateBody"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["UploadDate"] !== undefined) {
        contents.UploadDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["UploadDate"]));
    }
    return contents;
};
const de_SimulatePolicyResponse = (output, context) => {
    const contents = {};
    if (output.EvaluationResults === "") {
        contents.EvaluationResults = [];
    }
    else if (output["EvaluationResults"] !== undefined && output["EvaluationResults"]["member"] !== undefined) {
        contents.EvaluationResults = de_EvaluationResultsListType(__getArrayIfSingleItem(output["EvaluationResults"]["member"]), context);
    }
    if (output["IsTruncated"] !== undefined) {
        contents.IsTruncated = __parseBoolean(output["IsTruncated"]);
    }
    if (output["Marker"] !== undefined) {
        contents.Marker = __expectString(output["Marker"]);
    }
    return contents;
};
const de_SSHPublicKey = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["SSHPublicKeyId"] !== undefined) {
        contents.SSHPublicKeyId = __expectString(output["SSHPublicKeyId"]);
    }
    if (output["Fingerprint"] !== undefined) {
        contents.Fingerprint = __expectString(output["Fingerprint"]);
    }
    if (output["SSHPublicKeyBody"] !== undefined) {
        contents.SSHPublicKeyBody = __expectString(output["SSHPublicKeyBody"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["UploadDate"] !== undefined) {
        contents.UploadDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["UploadDate"]));
    }
    return contents;
};
const de_SSHPublicKeyListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_SSHPublicKeyMetadata(entry, context);
    });
};
const de_SSHPublicKeyMetadata = (output, context) => {
    const contents = {};
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["SSHPublicKeyId"] !== undefined) {
        contents.SSHPublicKeyId = __expectString(output["SSHPublicKeyId"]);
    }
    if (output["Status"] !== undefined) {
        contents.Status = __expectString(output["Status"]);
    }
    if (output["UploadDate"] !== undefined) {
        contents.UploadDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["UploadDate"]));
    }
    return contents;
};
const de_Statement = (output, context) => {
    const contents = {};
    if (output["SourcePolicyId"] !== undefined) {
        contents.SourcePolicyId = __expectString(output["SourcePolicyId"]);
    }
    if (output["SourcePolicyType"] !== undefined) {
        contents.SourcePolicyType = __expectString(output["SourcePolicyType"]);
    }
    if (output["StartPosition"] !== undefined) {
        contents.StartPosition = de_Position(output["StartPosition"], context);
    }
    if (output["EndPosition"] !== undefined) {
        contents.EndPosition = de_Position(output["EndPosition"], context);
    }
    return contents;
};
const de_StatementListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Statement(entry, context);
    });
};
const de_summaryMapType = (output, context) => {
    return output.reduce((acc, pair) => {
        if (pair["value"] === null) {
            return acc;
        }
        acc[pair["key"]] = __strictParseInt32(pair["value"]);
        return acc;
    }, {});
};
const de_Tag = (output, context) => {
    const contents = {};
    if (output["Key"] !== undefined) {
        contents.Key = __expectString(output["Key"]);
    }
    if (output["Value"] !== undefined) {
        contents.Value = __expectString(output["Value"]);
    }
    return contents;
};
const de_tagListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Tag(entry, context);
    });
};
const de_thumbprintListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return __expectString(entry);
    });
};
const de_TrackedActionLastAccessed = (output, context) => {
    const contents = {};
    if (output["ActionName"] !== undefined) {
        contents.ActionName = __expectString(output["ActionName"]);
    }
    if (output["LastAccessedEntity"] !== undefined) {
        contents.LastAccessedEntity = __expectString(output["LastAccessedEntity"]);
    }
    if (output["LastAccessedTime"] !== undefined) {
        contents.LastAccessedTime = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["LastAccessedTime"]));
    }
    if (output["LastAccessedRegion"] !== undefined) {
        contents.LastAccessedRegion = __expectString(output["LastAccessedRegion"]);
    }
    return contents;
};
const de_TrackedActionsLastAccessed = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TrackedActionLastAccessed(entry, context);
    });
};
const de_UnmodifiableEntityException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_UnrecognizedPublicKeyEncodingException = (output, context) => {
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = __expectString(output["message"]);
    }
    return contents;
};
const de_UpdateRoleDescriptionResponse = (output, context) => {
    const contents = {};
    if (output["Role"] !== undefined) {
        contents.Role = de_Role(output["Role"], context);
    }
    return contents;
};
const de_UpdateRoleResponse = (output, context) => {
    const contents = {};
    return contents;
};
const de_UpdateSAMLProviderResponse = (output, context) => {
    const contents = {};
    if (output["SAMLProviderArn"] !== undefined) {
        contents.SAMLProviderArn = __expectString(output["SAMLProviderArn"]);
    }
    return contents;
};
const de_UploadServerCertificateResponse = (output, context) => {
    const contents = {};
    if (output["ServerCertificateMetadata"] !== undefined) {
        contents.ServerCertificateMetadata = de_ServerCertificateMetadata(output["ServerCertificateMetadata"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_UploadSigningCertificateResponse = (output, context) => {
    const contents = {};
    if (output["Certificate"] !== undefined) {
        contents.Certificate = de_SigningCertificate(output["Certificate"], context);
    }
    return contents;
};
const de_UploadSSHPublicKeyResponse = (output, context) => {
    const contents = {};
    if (output["SSHPublicKey"] !== undefined) {
        contents.SSHPublicKey = de_SSHPublicKey(output["SSHPublicKey"], context);
    }
    return contents;
};
const de_User = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["UserId"] !== undefined) {
        contents.UserId = __expectString(output["UserId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output["PasswordLastUsed"] !== undefined) {
        contents.PasswordLastUsed = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["PasswordLastUsed"]));
    }
    if (output["PermissionsBoundary"] !== undefined) {
        contents.PermissionsBoundary = de_AttachedPermissionsBoundary(output["PermissionsBoundary"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_UserDetail = (output, context) => {
    const contents = {};
    if (output["Path"] !== undefined) {
        contents.Path = __expectString(output["Path"]);
    }
    if (output["UserName"] !== undefined) {
        contents.UserName = __expectString(output["UserName"]);
    }
    if (output["UserId"] !== undefined) {
        contents.UserId = __expectString(output["UserId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = __expectString(output["Arn"]);
    }
    if (output["CreateDate"] !== undefined) {
        contents.CreateDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["CreateDate"]));
    }
    if (output.UserPolicyList === "") {
        contents.UserPolicyList = [];
    }
    else if (output["UserPolicyList"] !== undefined && output["UserPolicyList"]["member"] !== undefined) {
        contents.UserPolicyList = de_policyDetailListType(__getArrayIfSingleItem(output["UserPolicyList"]["member"]), context);
    }
    if (output.GroupList === "") {
        contents.GroupList = [];
    }
    else if (output["GroupList"] !== undefined && output["GroupList"]["member"] !== undefined) {
        contents.GroupList = de_groupNameListType(__getArrayIfSingleItem(output["GroupList"]["member"]), context);
    }
    if (output.AttachedManagedPolicies === "") {
        contents.AttachedManagedPolicies = [];
    }
    else if (output["AttachedManagedPolicies"] !== undefined &&
        output["AttachedManagedPolicies"]["member"] !== undefined) {
        contents.AttachedManagedPolicies = de_attachedPoliciesListType(__getArrayIfSingleItem(output["AttachedManagedPolicies"]["member"]), context);
    }
    if (output["PermissionsBoundary"] !== undefined) {
        contents.PermissionsBoundary = de_AttachedPermissionsBoundary(output["PermissionsBoundary"], context);
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_userDetailListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UserDetail(entry, context);
    });
};
const de_userListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_User(entry, context);
    });
};
const de_VirtualMFADevice = (output, context) => {
    const contents = {};
    if (output["SerialNumber"] !== undefined) {
        contents.SerialNumber = __expectString(output["SerialNumber"]);
    }
    if (output["Base32StringSeed"] !== undefined) {
        contents.Base32StringSeed = context.base64Decoder(output["Base32StringSeed"]);
    }
    if (output["QRCodePNG"] !== undefined) {
        contents.QRCodePNG = context.base64Decoder(output["QRCodePNG"]);
    }
    if (output["User"] !== undefined) {
        contents.User = de_User(output["User"], context);
    }
    if (output["EnableDate"] !== undefined) {
        contents.EnableDate = __expectNonNull(__parseRfc3339DateTimeWithOffset(output["EnableDate"]));
    }
    if (output.Tags === "") {
        contents.Tags = [];
    }
    else if (output["Tags"] !== undefined && output["Tags"]["member"] !== undefined) {
        contents.Tags = de_tagListType(__getArrayIfSingleItem(output["Tags"]["member"]), context);
    }
    return contents;
};
const de_virtualMFADeviceListType = (output, context) => {
    return (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_VirtualMFADevice(entry, context);
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const throwDefaultError = withBaseException(__BaseException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded",
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        const parser = new XMLParser({
            attributeNamePrefix: "",
            htmlEntities: true,
            ignoreAttributes: false,
            ignoreDeclaration: true,
            parseTagValue: false,
            trimValues: false,
            tagValueProcessor: (_, val) => (val.trim() === "" && val.includes("\n") ? "" : undefined),
        });
        parser.addEntity("#xD", "\r");
        parser.addEntity("#10", "\n");
        const parsedObj = parser.parse(encoded);
        const textNodeName = "#text";
        const key = Object.keys(parsedObj)[0];
        const parsedObjToReturn = parsedObj[key];
        if (parsedObjToReturn[textNodeName]) {
            parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
            delete parsedObjToReturn[textNodeName];
        }
        return __getValueFromTextNode(parsedObjToReturn);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries) => Object.entries(formEntries)
    .map(([key, value]) => __extendedEncodeURIComponent(key) + "=" + __extendedEncodeURIComponent(value))
    .join("&");
const loadQueryErrorCode = (output, data) => {
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};
