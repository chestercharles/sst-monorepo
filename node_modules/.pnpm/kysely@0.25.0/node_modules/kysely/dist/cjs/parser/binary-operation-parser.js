"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseWhen = exports.parseOn = exports.parseHaving = exports.parseWhere = exports.parseReferentialComparison = exports.parseValueComparison = exports.parseReferentialBinaryOperation = exports.parseValueBinaryOperation = void 0;
const binary_operation_node_js_1 = require("../operation-node/binary-operation-node.js");
const object_utils_js_1 = require("../util/object-utils.js");
const operation_node_source_js_1 = require("../operation-node/operation-node-source.js");
const raw_node_js_1 = require("../operation-node/raw-node.js");
const operator_node_js_1 = require("../operation-node/operator-node.js");
const parens_node_js_1 = require("../operation-node/parens-node.js");
const reference_parser_js_1 = require("./reference-parser.js");
const value_parser_js_1 = require("./value-parser.js");
const value_node_js_1 = require("../operation-node/value-node.js");
const parse_utils_js_1 = require("./parse-utils.js");
const select_query_node_js_1 = require("../operation-node/select-query-node.js");
const join_node_js_1 = require("../operation-node/join-node.js");
const expression_builder_js_1 = require("../expression/expression-builder.js");
const unary_operation_node_js_1 = require("../operation-node/unary-operation-node.js");
const case_node_js_1 = require("../operation-node/case-node.js");
function parseValueBinaryOperation(leftOperand, operator, rightOperand) {
    if (!(0, operator_node_js_1.isBinaryOperator)(operator) && !(0, operation_node_source_js_1.isOperationNodeSource)(operator)) {
        throw new Error(`invalid binary operator ${JSON.stringify(operator)}`);
    }
    if (isIsComparison(operator, rightOperand)) {
        return parseIs(leftOperand, operator, rightOperand);
    }
    return binary_operation_node_js_1.BinaryOperationNode.create((0, reference_parser_js_1.parseReferenceExpression)(leftOperand), parseOperator(operator), (0, value_parser_js_1.parseValueExpressionOrList)(rightOperand));
}
exports.parseValueBinaryOperation = parseValueBinaryOperation;
function parseReferentialBinaryOperation(leftOperand, operator, rightOperand) {
    if (!(0, operator_node_js_1.isBinaryOperator)(operator) && !(0, operation_node_source_js_1.isOperationNodeSource)(operator)) {
        throw new Error(`invalid binary operator ${JSON.stringify(operator)}`);
    }
    return binary_operation_node_js_1.BinaryOperationNode.create((0, reference_parser_js_1.parseReferenceExpression)(leftOperand), parseOperator(operator), (0, reference_parser_js_1.parseReferenceExpression)(rightOperand));
}
exports.parseReferentialBinaryOperation = parseReferentialBinaryOperation;
function parseValueComparison(leftOperand, operator, rightOperand) {
    if (!(0, operator_node_js_1.isComparisonOperator)(operator) && !(0, operation_node_source_js_1.isOperationNodeSource)(operator)) {
        throw new Error(`invalid comparison operator ${JSON.stringify(operator)}`);
    }
    return parseValueBinaryOperation(leftOperand, operator, rightOperand);
}
exports.parseValueComparison = parseValueComparison;
function parseReferentialComparison(leftOperand, operator, rightOperand) {
    if (!(0, operator_node_js_1.isComparisonOperator)(operator) && !(0, operation_node_source_js_1.isOperationNodeSource)(operator)) {
        throw new Error(`invalid comparison operator ${JSON.stringify(operator)}`);
    }
    return parseReferentialBinaryOperation(leftOperand, operator, rightOperand);
}
exports.parseReferentialComparison = parseReferentialComparison;
function parseWhere(args) {
    return parseFilter('where', args);
}
exports.parseWhere = parseWhere;
function parseHaving(args) {
    return parseFilter('having', args);
}
exports.parseHaving = parseHaving;
function parseOn(args) {
    return parseFilter('on', args);
}
exports.parseOn = parseOn;
function parseWhen(args) {
    return parseFilter('when', args);
}
exports.parseWhen = parseWhen;
function parseFilter(type, args) {
    if (args.length === 3) {
        return parseValueComparison(args[0], args[1], args[2]);
    }
    if (args.length === 1) {
        return parseOneArgFilterExpression(type, args[0]);
    }
    throw createFilterExpressionError(type, args);
}
function isIsComparison(operator, rightOperand) {
    return ((operator === 'is' || operator === 'is not') &&
        ((0, object_utils_js_1.isNull)(rightOperand) || (0, object_utils_js_1.isBoolean)(rightOperand)));
}
function parseIs(leftOperand, operator, rightOperand) {
    return binary_operation_node_js_1.BinaryOperationNode.create((0, reference_parser_js_1.parseReferenceExpression)(leftOperand), parseOperator(operator), value_node_js_1.ValueNode.createImmediate(rightOperand));
}
function parseOperator(operator) {
    if ((0, object_utils_js_1.isString)(operator) && operator_node_js_1.OPERATORS.includes(operator)) {
        return operator_node_js_1.OperatorNode.create(operator);
    }
    if ((0, operation_node_source_js_1.isOperationNodeSource)(operator)) {
        return operator.toOperationNode();
    }
    throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function parseOneArgFilterExpression(type, arg) {
    if ((0, object_utils_js_1.isFunction)(arg)) {
        if (type === 'when') {
            throw new Error(`when method doesn't accept a callback as an argument`);
        }
        return CALLBACK_PARSERS[type](arg);
    }
    else if ((0, operation_node_source_js_1.isOperationNodeSource)(arg)) {
        const node = arg.toOperationNode();
        if (raw_node_js_1.RawNode.is(node) ||
            binary_operation_node_js_1.BinaryOperationNode.is(node) ||
            unary_operation_node_js_1.UnaryOperationNode.is(node) ||
            parens_node_js_1.ParensNode.is(node) ||
            case_node_js_1.CaseNode.is(node)) {
            return node;
        }
    }
    else if (type === 'when') {
        return value_node_js_1.ValueNode.create(arg);
    }
    throw createFilterExpressionError(type, arg);
}
function createFilterExpressionError(type, args) {
    return new Error(`invalid arguments passed to a '${type}' method: ${JSON.stringify(args)}`);
}
const CALLBACK_PARSERS = (0, object_utils_js_1.freeze)({
    where(callback) {
        // TODO: Remove this once the grouper overload is removed.
        const whereBuilder = (0, parse_utils_js_1.createSelectQueryBuilder)();
        const exprBuilder = (0, expression_builder_js_1.expressionBuilder)();
        const res = callback(Object.assign(whereBuilder, exprBuilder));
        const node = res.toOperationNode();
        if (select_query_node_js_1.SelectQueryNode.is(node)) {
            if (!node.where) {
                throw new Error('no `where` methods called inside a group callback');
            }
            return parens_node_js_1.ParensNode.create(node.where.where);
        }
        else {
            return node;
        }
    },
    having(callback) {
        // TODO: Remove this once the grouper overload is removed.
        const havingBuilder = (0, parse_utils_js_1.createSelectQueryBuilder)();
        const exprBuilder = (0, expression_builder_js_1.expressionBuilder)();
        const res = callback(Object.assign(havingBuilder, exprBuilder));
        const node = res.toOperationNode();
        if (select_query_node_js_1.SelectQueryNode.is(node)) {
            if (!node.having) {
                throw new Error('no `having` methods called inside a group callback');
            }
            return parens_node_js_1.ParensNode.create(node.having.having);
        }
        else {
            return node;
        }
    },
    on(callback) {
        // TODO: Remove this once the grouper overload is removed.
        const onBuilder = (0, parse_utils_js_1.createJoinBuilder)('InnerJoin', 'table');
        const exprBuilder = (0, expression_builder_js_1.expressionBuilder)();
        const res = callback(Object.assign(onBuilder, exprBuilder));
        const node = res.toOperationNode();
        if (join_node_js_1.JoinNode.is(node)) {
            if (!node.on) {
                throw new Error('no `on` methods called inside a group callback');
            }
            return parens_node_js_1.ParensNode.create(node.on.on);
        }
        else {
            return node;
        }
    },
});
