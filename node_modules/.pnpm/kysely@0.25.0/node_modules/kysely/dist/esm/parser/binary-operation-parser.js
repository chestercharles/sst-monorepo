/// <reference types="./binary-operation-parser.d.ts" />
import { BinaryOperationNode } from '../operation-node/binary-operation-node.js';
import { freeze, isBoolean, isFunction, isNull, isString, } from '../util/object-utils.js';
import { isOperationNodeSource } from '../operation-node/operation-node-source.js';
import { RawNode } from '../operation-node/raw-node.js';
import { OperatorNode, isComparisonOperator, isBinaryOperator, OPERATORS, } from '../operation-node/operator-node.js';
import { ParensNode } from '../operation-node/parens-node.js';
import { parseReferenceExpression, } from './reference-parser.js';
import { parseValueExpressionOrList, } from './value-parser.js';
import { ValueNode } from '../operation-node/value-node.js';
import { createJoinBuilder, createSelectQueryBuilder } from './parse-utils.js';
import { SelectQueryNode } from '../operation-node/select-query-node.js';
import { JoinNode } from '../operation-node/join-node.js';
import { expressionBuilder } from '../expression/expression-builder.js';
import { UnaryOperationNode } from '../operation-node/unary-operation-node.js';
import { CaseNode } from '../operation-node/case-node.js';
export function parseValueBinaryOperation(leftOperand, operator, rightOperand) {
    if (!isBinaryOperator(operator) && !isOperationNodeSource(operator)) {
        throw new Error(`invalid binary operator ${JSON.stringify(operator)}`);
    }
    if (isIsComparison(operator, rightOperand)) {
        return parseIs(leftOperand, operator, rightOperand);
    }
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseOperator(operator), parseValueExpressionOrList(rightOperand));
}
export function parseReferentialBinaryOperation(leftOperand, operator, rightOperand) {
    if (!isBinaryOperator(operator) && !isOperationNodeSource(operator)) {
        throw new Error(`invalid binary operator ${JSON.stringify(operator)}`);
    }
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseOperator(operator), parseReferenceExpression(rightOperand));
}
export function parseValueComparison(leftOperand, operator, rightOperand) {
    if (!isComparisonOperator(operator) && !isOperationNodeSource(operator)) {
        throw new Error(`invalid comparison operator ${JSON.stringify(operator)}`);
    }
    return parseValueBinaryOperation(leftOperand, operator, rightOperand);
}
export function parseReferentialComparison(leftOperand, operator, rightOperand) {
    if (!isComparisonOperator(operator) && !isOperationNodeSource(operator)) {
        throw new Error(`invalid comparison operator ${JSON.stringify(operator)}`);
    }
    return parseReferentialBinaryOperation(leftOperand, operator, rightOperand);
}
export function parseWhere(args) {
    return parseFilter('where', args);
}
export function parseHaving(args) {
    return parseFilter('having', args);
}
export function parseOn(args) {
    return parseFilter('on', args);
}
export function parseWhen(args) {
    return parseFilter('when', args);
}
function parseFilter(type, args) {
    if (args.length === 3) {
        return parseValueComparison(args[0], args[1], args[2]);
    }
    if (args.length === 1) {
        return parseOneArgFilterExpression(type, args[0]);
    }
    throw createFilterExpressionError(type, args);
}
function isIsComparison(operator, rightOperand) {
    return ((operator === 'is' || operator === 'is not') &&
        (isNull(rightOperand) || isBoolean(rightOperand)));
}
function parseIs(leftOperand, operator, rightOperand) {
    return BinaryOperationNode.create(parseReferenceExpression(leftOperand), parseOperator(operator), ValueNode.createImmediate(rightOperand));
}
function parseOperator(operator) {
    if (isString(operator) && OPERATORS.includes(operator)) {
        return OperatorNode.create(operator);
    }
    if (isOperationNodeSource(operator)) {
        return operator.toOperationNode();
    }
    throw new Error(`invalid operator ${JSON.stringify(operator)}`);
}
function parseOneArgFilterExpression(type, arg) {
    if (isFunction(arg)) {
        if (type === 'when') {
            throw new Error(`when method doesn't accept a callback as an argument`);
        }
        return CALLBACK_PARSERS[type](arg);
    }
    else if (isOperationNodeSource(arg)) {
        const node = arg.toOperationNode();
        if (RawNode.is(node) ||
            BinaryOperationNode.is(node) ||
            UnaryOperationNode.is(node) ||
            ParensNode.is(node) ||
            CaseNode.is(node)) {
            return node;
        }
    }
    else if (type === 'when') {
        return ValueNode.create(arg);
    }
    throw createFilterExpressionError(type, arg);
}
function createFilterExpressionError(type, args) {
    return new Error(`invalid arguments passed to a '${type}' method: ${JSON.stringify(args)}`);
}
const CALLBACK_PARSERS = freeze({
    where(callback) {
        // TODO: Remove this once the grouper overload is removed.
        const whereBuilder = createSelectQueryBuilder();
        const exprBuilder = expressionBuilder();
        const res = callback(Object.assign(whereBuilder, exprBuilder));
        const node = res.toOperationNode();
        if (SelectQueryNode.is(node)) {
            if (!node.where) {
                throw new Error('no `where` methods called inside a group callback');
            }
            return ParensNode.create(node.where.where);
        }
        else {
            return node;
        }
    },
    having(callback) {
        // TODO: Remove this once the grouper overload is removed.
        const havingBuilder = createSelectQueryBuilder();
        const exprBuilder = expressionBuilder();
        const res = callback(Object.assign(havingBuilder, exprBuilder));
        const node = res.toOperationNode();
        if (SelectQueryNode.is(node)) {
            if (!node.having) {
                throw new Error('no `having` methods called inside a group callback');
            }
            return ParensNode.create(node.having.having);
        }
        else {
            return node;
        }
    },
    on(callback) {
        // TODO: Remove this once the grouper overload is removed.
        const onBuilder = createJoinBuilder('InnerJoin', 'table');
        const exprBuilder = expressionBuilder();
        const res = callback(Object.assign(onBuilder, exprBuilder));
        const node = res.toOperationNode();
        if (JoinNode.is(node)) {
            if (!node.on) {
                throw new Error('no `on` methods called inside a group callback');
            }
            return ParensNode.create(node.on.on);
        }
        else {
            return node;
        }
    },
});
