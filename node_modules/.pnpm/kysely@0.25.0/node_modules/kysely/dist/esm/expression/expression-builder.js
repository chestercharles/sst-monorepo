/// <reference types="./expression-builder.d.ts" />
import { SelectQueryBuilder } from '../query-builder/select-query-builder.js';
import { SelectQueryNode } from '../operation-node/select-query-node.js';
import { parseTableExpressionOrList, } from '../parser/table-parser.js';
import { WithSchemaPlugin } from '../plugin/with-schema/with-schema-plugin.js';
import { createQueryId } from '../util/query-id.js';
import { createFunctionModule, } from '../query-builder/function-module.js';
import { parseReferenceExpression, parseStringReference, } from '../parser/reference-parser.js';
import { parseValueBinaryOperation, } from '../parser/binary-operation-parser.js';
import { AndNode } from '../operation-node/and-node.js';
import { OrNode } from '../operation-node/or-node.js';
import { ParensNode } from '../operation-node/parens-node.js';
import { ExpressionWrapper } from './expression-wrapper.js';
import { parseUnaryOperation } from '../parser/unary-operation-parser.js';
import { parseValueExpressionOrList, } from '../parser/value-parser.js';
import { NOOP_QUERY_EXECUTOR } from '../query-executor/noop-query-executor.js';
import { ValueNode } from '../operation-node/value-node.js';
import { CaseBuilder } from '../query-builder/case-builder.js';
import { CaseNode } from '../operation-node/case-node.js';
import { isUndefined } from '../util/object-utils.js';
export function createExpressionBuilder(executor = NOOP_QUERY_EXECUTOR) {
    function unary(op, expr) {
        return new ExpressionWrapper(parseUnaryOperation(op, expr));
    }
    return {
        get fn() {
            return createFunctionModule();
        },
        selectFrom(table) {
            return new SelectQueryBuilder({
                queryId: createQueryId(),
                executor: executor,
                queryNode: SelectQueryNode.create(parseTableExpressionOrList(table)),
            });
        },
        case(reference) {
            return new CaseBuilder({
                node: CaseNode.create(isUndefined(reference)
                    ? undefined
                    : parseReferenceExpression(reference)),
            });
        },
        ref(reference) {
            return new ExpressionWrapper(parseStringReference(reference));
        },
        val(value) {
            return new ExpressionWrapper(parseValueExpressionOrList(value));
        },
        cmpr(lhs, op, rhs) {
            return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
        },
        bxp(lhs, op, rhs) {
            return new ExpressionWrapper(parseValueBinaryOperation(lhs, op, rhs));
        },
        unary,
        not(expr) {
            return unary('not', expr);
        },
        exists(expr) {
            return unary('exists', expr);
        },
        neg(expr) {
            return unary('-', expr);
        },
        and(exprs) {
            if (exprs.length === 0) {
                return new ExpressionWrapper(ValueNode.createImmediate(true));
            }
            else if (exprs.length === 1) {
                return new ExpressionWrapper(exprs[0].toOperationNode());
            }
            let node = AndNode.create(exprs[0].toOperationNode(), exprs[1].toOperationNode());
            for (let i = 2; i < exprs.length; ++i) {
                node = AndNode.create(node, exprs[i].toOperationNode());
            }
            return new ExpressionWrapper(ParensNode.create(node));
        },
        or(exprs) {
            if (exprs.length === 0) {
                return new ExpressionWrapper(ValueNode.createImmediate(false));
            }
            else if (exprs.length === 1) {
                return new ExpressionWrapper(exprs[0].toOperationNode());
            }
            let node = OrNode.create(exprs[0].toOperationNode(), exprs[1].toOperationNode());
            for (let i = 2; i < exprs.length; ++i) {
                node = OrNode.create(node, exprs[i].toOperationNode());
            }
            return new ExpressionWrapper(ParensNode.create(node));
        },
        withSchema(schema) {
            return createExpressionBuilder(executor.withPluginAtFront(new WithSchemaPlugin(schema)));
        },
    };
}
export function expressionBuilder(_) {
    return createExpressionBuilder();
}
