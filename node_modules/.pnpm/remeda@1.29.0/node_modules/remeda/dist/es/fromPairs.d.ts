import { IterableContainer } from './_types';
type Entry<Key extends PropertyKey = PropertyKey, Value = unknown> = readonly [
    key: Key,
    value: Value
];
export declare function fromPairs<V>(pairs: ReadonlyArray<Entry<number, V>>): Record<number, V>;
export declare function fromPairs<V>(pairs: ReadonlyArray<Entry<string, V>>): Record<string, V>;
type Strict = <Entries extends IterableContainer<Entry>>(entries: Entries) => StrictOut<Entries>;
type StrictOut<Entries> = Entries extends readonly [infer First, ...infer Tail] ? FromPairsTuple<First, Tail> : Entries extends readonly [...infer Head, infer Last] ? FromPairsTuple<Last, Head> : Entries extends IterableContainer<Entry> ? FromPairsArray<Entries> : 'ERROR: Entries array-like could not be infered';
type FromPairsTuple<E, Rest> = E extends Entry ? Record<E[0], E[1]> & StrictOut<Rest> : 'ERROR: Array-like contains a non-entry element';
type FromPairsArray<Entries extends IterableContainer<Entry>> = string extends AllKeys<Entries> ? Record<string, Entries[number][1]> : number extends AllKeys<Entries> ? Record<number, Entries[number][1]> : symbol extends AllKeys<Entries> ? Record<symbol, Entries[number][1]> : FromPairsArrayWithLiteralKeys<Entries>;
type FromPairsArrayWithLiteralKeys<Entries extends IterableContainer<Entry>> = {
    [K in AllKeys<Entries>]?: ValueForKey<Entries, K>;
};
type AllKeys<Entries extends IterableContainer<Entry>> = Extract<Entries[number], Entry>[0];
type ValueForKey<Entries extends IterableContainer<Entry>, K extends PropertyKey> = (Extract<Entries[number], Entry<K>> extends never ? Entries[number] : Extract<Entries[number], Entry<K>>)[1];
export declare namespace fromPairs {
    const strict: Strict;
}
export {};
//# sourceMappingURL=fromPairs.d.ts.map