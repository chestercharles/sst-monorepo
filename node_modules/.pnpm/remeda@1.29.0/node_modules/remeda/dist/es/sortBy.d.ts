import type { IterableContainer, NonEmptyArray } from './_types';
declare const ALL_DIRECTIONS: readonly ["asc", "desc"];
type Direction = (typeof ALL_DIRECTIONS)[number];
type ComparablePrimitive = number | string | boolean;
type Comparable = ComparablePrimitive | {
    valueOf(): ComparablePrimitive;
};
type SortProjection<T> = (x: T) => Comparable;
type SortPair<T> = readonly [
    projector: SortProjection<T>,
    direction: Direction
];
type SortRule<T> = SortProjection<T> | SortPair<T>;
export declare function sortBy<T>(...sortRules: Readonly<NonEmptyArray<SortRule<T>>>): (array: ReadonlyArray<T>) => Array<T>;
export declare function sortBy<T>(array: ReadonlyArray<T>, ...sortRules: Readonly<NonEmptyArray<SortRule<T>>>): Array<T>;
interface Strict {
    <T extends IterableContainer>(...sortRules: Readonly<NonEmptyArray<SortRule<T[number]>>>): (array: T) => SortedBy<T>;
    <T extends IterableContainer>(array: T, ...sortRules: Readonly<NonEmptyArray<SortRule<T[number]>>>): SortedBy<T>;
}
type SortedBy<T extends IterableContainer> = {
    -readonly [P in keyof T]: T[number];
};
export declare namespace sortBy {
    const strict: Strict;
}
export {};
//# sourceMappingURL=sortBy.d.ts.map