import type { IterableContainer } from './_types';
import type { Joined } from './join';
type isEqual<A, B> = (<G>() => G extends A ? 1 : 2) extends <G>() => G extends B ? 1 : 2 ? true : false;
type Difference<A extends number, B extends number> = TupleOfLength<A> extends [
    ...infer U,
    ...TupleOfLength<B>
] ? U['length'] : never;
type isLessThan<A extends number, B extends number> = isEqual<A, B> extends true ? false : 0 extends A ? true : 0 extends B ? false : isLessThan<Difference<A, 1>, Difference<B, 1>>;
type TupleOfLength<L extends number, T extends IterableContainer = []> = T['length'] extends L ? T : TupleOfLength<L, [...T, unknown]>;
type IsNonNegative<T extends number> = number extends T ? false : `${T}` extends `-${string}` ? false : true;
type CharactersTuple<T extends string> = string extends T ? Array<string> : T extends `${infer C}${infer R}` ? [C, ...CharactersTuple<R>] : [];
type SwapArrayInternal<T extends IterableContainer, Index1 extends number, Index2 extends number, Position extends ReadonlyArray<unknown> = [], Original extends IterableContainer = T> = T extends readonly [infer AtPosition, ...infer Rest] ? [
    Position['length'] extends Index1 ? Original[Index2] : Position['length'] extends Index2 ? Original[Index1] : AtPosition,
    ...SwapArrayInternal<Rest, Index1, Index2, [
        unknown,
        ...Position
    ], Original>
] : T;
type SwapString<T extends string, K1 extends number, K2 extends number> = Joined<SwapArray<CharactersTuple<T>, K1, K2>, ''>;
type SwapArray<T extends IterableContainer, K1 extends number, K2 extends number> = IsNonNegative<K1> extends false ? Array<T[number]> : IsNonNegative<K2> extends false ? Array<T[number]> : isLessThan<K1, T['length']> extends false ? T : isLessThan<K2, T['length']> extends false ? T : SwapArrayInternal<T, K1, K2>;
type SwappedIndices<T extends IterableContainer | string, K1 extends number, K2 extends number> = T extends string ? SwapString<T, K1, K2> : T extends IterableContainer ? SwapArray<T, K1, K2> : never;
export declare function swapIndices<T extends IterableContainer | string, K1 extends number, K2 extends number>(data: T, index1: K1, index2: K2): SwappedIndices<T, K1, K2>;
export declare function swapIndices<K1 extends number, K2 extends number>(index1: K1, index2: K2): <T extends IterableContainer | string>(data: T) => SwappedIndices<T, K1, K2>;
export {};
//# sourceMappingURL=swapIndices.d.ts.map