"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryHotswapDeployment = void 0;
const cfn_diff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const aws_auth_1 = require("./aws-auth");
const evaluate_cloudformation_template_1 = require("./evaluate-cloudformation-template");
const appsync_mapping_templates_1 = require("./hotswap/appsync-mapping-templates");
const code_build_projects_1 = require("./hotswap/code-build-projects");
const common_1 = require("./hotswap/common");
const ecs_services_1 = require("./hotswap/ecs-services");
const lambda_functions_1 = require("./hotswap/lambda-functions");
const s3_bucket_deployments_1 = require("./hotswap/s3-bucket-deployments");
const stepfunctions_state_machines_1 = require("./hotswap/stepfunctions-state-machines");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
const logging_1 = require("../logging");
const RESOURCE_DETECTORS = {
    // Lambda
    'AWS::Lambda::Function': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Version': lambda_functions_1.isHotswappableLambdaFunctionChange,
    'AWS::Lambda::Alias': lambda_functions_1.isHotswappableLambdaFunctionChange,
    // AppSync
    'AWS::AppSync::Resolver': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::FunctionConfiguration': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::AppSync::GraphQLSchema': appsync_mapping_templates_1.isHotswappableAppSyncChange,
    'AWS::ECS::TaskDefinition': ecs_services_1.isHotswappableEcsServiceChange,
    'AWS::CodeBuild::Project': code_build_projects_1.isHotswappableCodeBuildProjectChange,
    'AWS::StepFunctions::StateMachine': stepfunctions_state_machines_1.isHotswappableStateMachineChange,
    'Custom::CDKBucketDeployment': s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange,
    'AWS::IAM::Policy': s3_bucket_deployments_1.isHotswappableS3BucketDeploymentChange,
    'AWS::CDK::Metadata': async () => [],
};
/**
 * Perform a hotswap deployment,
 * short-circuiting CloudFormation if possible.
 * If it's not possible to short-circuit the deployment
 * (because the CDK Stack contains changes that cannot be deployed without CloudFormation),
 * returns `undefined`.
 */
async function tryHotswapDeployment(sdkProvider, assetParams, cloudFormationStack, stackArtifact, hotswapMode) {
    // resolve the environment, so we can substitute things like AWS::Region in CFN expressions
    const resolvedEnv = await sdkProvider.resolveEnvironment(stackArtifact.environment);
    // create a new SDK using the CLI credentials, because the default one will not work for new-style synthesis -
    // it assumes the bootstrap deploy Role, which doesn't have permissions to update Lambda functions
    const sdk = (await sdkProvider.forEnvironment(resolvedEnv, aws_auth_1.Mode.ForWriting)).sdk;
    const currentTemplate = await (0, nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks)(stackArtifact, sdk);
    const evaluateCfnTemplate = new evaluate_cloudformation_template_1.EvaluateCloudFormationTemplate({
        stackName: stackArtifact.stackName,
        template: stackArtifact.template,
        parameters: assetParams,
        account: resolvedEnv.account,
        region: resolvedEnv.region,
        partition: (await sdk.currentAccount()).partition,
        urlSuffix: (region) => sdk.getEndpointSuffix(region),
        sdk,
        nestedStackNames: currentTemplate.nestedStackNames,
    });
    const stackChanges = cfn_diff.diffTemplate(currentTemplate.deployedTemplate, stackArtifact.template);
    const { hotswappableChanges, nonHotswappableChanges } = await classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, currentTemplate.nestedStackNames);
    logNonHotswappableChanges(nonHotswappableChanges, hotswapMode);
    // preserve classic hotswap behavior
    if (hotswapMode === common_1.HotswapMode.FALL_BACK) {
        if (nonHotswappableChanges.length > 0) {
            return undefined;
        }
    }
    // apply the short-circuitable changes
    await applyAllHotswappableChanges(sdk, hotswappableChanges);
    return { noOp: hotswappableChanges.length === 0, stackArn: cloudFormationStack.stackId, outputs: cloudFormationStack.outputs };
}
exports.tryHotswapDeployment = tryHotswapDeployment;
/**
 * Classifies all changes to all resources as either hotswappable or not.
 * Metadata changes are excluded from the list of (non)hotswappable resources.
 */
async function classifyResourceChanges(stackChanges, evaluateCfnTemplate, sdk, nestedStackNames) {
    const resourceDifferences = getStackResourceDifferences(stackChanges);
    const promises = [];
    const hotswappableResources = new Array();
    const nonHotswappableResources = new Array();
    for (const logicalId of Object.keys(stackChanges.outputs.changes)) {
        nonHotswappableResources.push({
            hotswappable: false,
            reason: 'output was changed',
            logicalId,
            rejectedChanges: [],
            resourceType: 'Stack Output',
        });
    }
    // gather the results of the detector functions
    for (const [logicalId, change] of Object.entries(resourceDifferences)) {
        if (change.newValue?.Type === 'AWS::CloudFormation::Stack' && change.oldValue?.Type === 'AWS::CloudFormation::Stack') {
            const nestedHotswappableResources = await findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk);
            hotswappableResources.push(...nestedHotswappableResources.hotswappableChanges);
            nonHotswappableResources.push(...nestedHotswappableResources.nonHotswappableChanges);
            continue;
        }
        const hotswappableChangeCandidate = isCandidateForHotswapping(change, logicalId);
        // we don't need to run this through the detector functions, we can already judge this
        if ('hotswappable' in hotswappableChangeCandidate) {
            if (!hotswappableChangeCandidate.hotswappable) {
                nonHotswappableResources.push(hotswappableChangeCandidate);
            }
            continue;
        }
        const resourceType = hotswappableChangeCandidate.newValue.Type;
        if (resourceType in RESOURCE_DETECTORS) {
            // run detector functions lazily to prevent unhandled promise rejections
            promises.push(() => RESOURCE_DETECTORS[resourceType](logicalId, hotswappableChangeCandidate, evaluateCfnTemplate));
        }
        else {
            (0, common_1.reportNonHotswappableChange)(nonHotswappableResources, hotswappableChangeCandidate, undefined, 'This resource type is not supported for hotswap deployments');
        }
    }
    // resolve all detector results
    const changesDetectionResults = [];
    for (const detectorResultPromises of promises) {
        const hotswapDetectionResults = await Promise.all(await detectorResultPromises());
        changesDetectionResults.push(hotswapDetectionResults);
    }
    for (const resourceDetectionResults of changesDetectionResults) {
        for (const propertyResult of resourceDetectionResults) {
            propertyResult.hotswappable ?
                hotswappableResources.push(propertyResult) :
                nonHotswappableResources.push(propertyResult);
        }
    }
    return {
        hotswappableChanges: hotswappableResources,
        nonHotswappableChanges: nonHotswappableResources,
    };
}
/**
 * Returns all changes to resources in the given Stack.
 *
 * @param stackChanges the collection of all changes to a given Stack
 */
function getStackResourceDifferences(stackChanges) {
    // we need to collapse logical ID rename changes into one change,
    // as they are represented in stackChanges as a pair of two changes: one addition and one removal
    const allResourceChanges = stackChanges.resources.changes;
    const allRemovalChanges = filterDict(allResourceChanges, resChange => resChange.isRemoval);
    const allNonRemovalChanges = filterDict(allResourceChanges, resChange => !resChange.isRemoval);
    for (const [logId, nonRemovalChange] of Object.entries(allNonRemovalChanges)) {
        if (nonRemovalChange.isAddition) {
            const addChange = nonRemovalChange;
            // search for an identical removal change
            const identicalRemovalChange = Object.entries(allRemovalChanges).find(([_, remChange]) => {
                return changesAreForSameResource(remChange, addChange);
            });
            // if we found one, then this means this is a rename change
            if (identicalRemovalChange) {
                const [removedLogId, removedResourceChange] = identicalRemovalChange;
                allNonRemovalChanges[logId] = makeRenameDifference(removedResourceChange, addChange);
                // delete the removal change that forms the rename pair
                delete allRemovalChanges[removedLogId];
            }
        }
    }
    // the final result are all of the remaining removal changes,
    // plus all of the non-removal changes
    // (we saved the rename changes in that object already)
    return {
        ...allRemovalChanges,
        ...allNonRemovalChanges,
    };
}
/** Filters an object with string keys based on whether the callback returns 'true' for the given value in the object. */
function filterDict(dict, func) {
    return Object.entries(dict).reduce((acc, [key, t]) => {
        if (func(t)) {
            acc[key] = t;
        }
        return acc;
    }, {});
}
/** Finds any hotswappable changes in all nested stacks. */
async function findNestedHotswappableChanges(logicalId, change, nestedStackNames, evaluateCfnTemplate, sdk) {
    const nestedStackName = nestedStackNames[logicalId].nestedStackPhysicalName;
    if (!nestedStackName) {
        return {
            hotswappableChanges: [],
            nonHotswappableChanges: [{
                    hotswappable: false,
                    logicalId,
                    reason: `physical name for AWS::CloudFormation::Stack '${logicalId}' could not be found in CloudFormation, so this is a newly created nested stack and cannot be hotswapped`,
                    rejectedChanges: [],
                    resourceType: 'AWS::CloudFormation::Stack',
                }],
        };
    }
    const evaluateNestedCfnTemplate = await evaluateCfnTemplate.createNestedEvaluateCloudFormationTemplate(nestedStackName, change.newValue?.Properties?.NestedTemplate, change.newValue?.Properties?.Parameters);
    const nestedDiff = cfn_diff.diffTemplate(change.oldValue?.Properties?.NestedTemplate, change.newValue?.Properties?.NestedTemplate);
    return classifyResourceChanges(nestedDiff, evaluateNestedCfnTemplate, sdk, nestedStackNames[logicalId].nestedChildStackNames);
}
/** Returns 'true' if a pair of changes is for the same resource. */
function changesAreForSameResource(oldChange, newChange) {
    return oldChange.oldResourceType === newChange.newResourceType &&
        // this isn't great, but I don't want to bring in something like underscore just for this comparison
        JSON.stringify(oldChange.oldProperties) === JSON.stringify(newChange.newProperties);
}
function makeRenameDifference(remChange, addChange) {
    return new cfn_diff.ResourceDifference(
    // we have to fill in the old value, because otherwise this will be classified as a non-hotswappable change
    remChange.oldValue, addChange.newValue, {
        resourceType: {
            oldType: remChange.oldResourceType,
            newType: addChange.newResourceType,
        },
        propertyDiffs: addChange.propertyDiffs,
        otherDiffs: addChange.otherDiffs,
    });
}
/**
 * Returns a `HotswappableChangeCandidate` if the change is hotswappable
 * Returns an empty `HotswappableChange` if the change is to CDK::Metadata
 * Returns a `NonHotswappableChange` if the change is not hotswappable
 */
function isCandidateForHotswapping(change, logicalId) {
    // a resource has been removed OR a resource has been added; we can't short-circuit that change
    if (!change.oldValue) {
        return {
            hotswappable: false,
            resourceType: change.newValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was created by this deployment`,
        };
    }
    else if (!change.newValue) {
        return {
            hotswappable: false,
            resourceType: change.oldValue.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' was destroyed by this deployment`,
        };
    }
    // a resource has had its type changed
    if (change.newValue?.Type !== change.oldValue?.Type) {
        return {
            hotswappable: false,
            resourceType: change.newValue?.Type,
            logicalId,
            rejectedChanges: [],
            reason: `resource '${logicalId}' had its type changed from '${change.oldValue?.Type}' to '${change.newValue?.Type}'`,
        };
    }
    return {
        logicalId,
        oldValue: change.oldValue,
        newValue: change.newValue,
        propertyUpdates: change.propertyUpdates,
    };
}
async function applyAllHotswappableChanges(sdk, hotswappableChanges) {
    if (hotswappableChanges.length > 0) {
        (0, logging_1.print)(`\n${common_1.ICON} hotswapping resources:`);
    }
    return Promise.all(hotswappableChanges.map(hotswapOperation => {
        return applyHotswappableChange(sdk, hotswapOperation);
    }));
}
async function applyHotswappableChange(sdk, hotswapOperation) {
    // note the type of service that was successfully hotswapped in the User-Agent
    const customUserAgent = `cdk-hotswap/success-${hotswapOperation.service}`;
    sdk.appendCustomUserAgent(customUserAgent);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.print)(`   ${common_1.ICON} %s`, chalk.bold(name));
    }
    // if the SDK call fails, an error will be thrown by the SDK
    // and will prevent the green 'hotswapped!' text from being displayed
    await hotswapOperation.apply(sdk);
    for (const name of hotswapOperation.resourceNames) {
        (0, logging_1.print)(`${common_1.ICON} %s %s`, chalk.bold(name), chalk.green('hotswapped!'));
    }
    sdk.removeCustomUserAgent(customUserAgent);
}
function logNonHotswappableChanges(nonHotswappableChanges, hotswapMode) {
    if (nonHotswappableChanges.length === 0) {
        return;
    }
    /**
     * EKS Services can have a task definition that doesn't refer to the task definition being updated.
     * We have to log this as a non-hotswappable change to the task definition, but when we do,
     * we wind up hotswapping the task definition and logging it as a non-hotswappable change.
     *
     * This logic prevents us from logging that change as non-hotswappable when we hotswap it.
     */
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        nonHotswappableChanges = nonHotswappableChanges.filter((change) => change.hotswapOnlyVisible === true);
        if (nonHotswappableChanges.length === 0) {
            return;
        }
    }
    if (hotswapMode === common_1.HotswapMode.HOTSWAP_ONLY) {
        (0, logging_1.print)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found. To reconcile these using CloudFormation, specify --hotswap-fallback'));
    }
    else {
        (0, logging_1.print)('\n%s %s', chalk.red('⚠️'), chalk.red('The following non-hotswappable changes were found:'));
    }
    for (const change of nonHotswappableChanges) {
        change.rejectedChanges.length > 0 ?
            (0, logging_1.print)('    logicalID: %s, type: %s, rejected changes: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.bold(change.rejectedChanges), chalk.red(change.reason)) :
            (0, logging_1.print)('    logicalID: %s, type: %s, reason: %s', chalk.bold(change.logicalId), chalk.bold(change.resourceType), chalk.red(change.reason));
    }
    (0, logging_1.print)(''); // newline
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaG90c3dhcC1kZXBsb3ltZW50cy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhvdHN3YXAtZGVwbG95bWVudHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseURBQXlEO0FBRXpELCtCQUErQjtBQUMvQix5Q0FBcUQ7QUFFckQseUZBQW9GO0FBQ3BGLG1GQUFrRjtBQUNsRix1RUFBcUY7QUFDckYsNkNBQTBNO0FBQzFNLHlEQUF3RTtBQUN4RSxpRUFBZ0Y7QUFDaEYsMkVBQXlGO0FBQ3pGLHlGQUEwRjtBQUMxRixpRUFBK0Y7QUFFL0Ysd0NBQW1DO0FBTW5DLE1BQU0sa0JBQWtCLEdBQXNDO0lBQzVELFNBQVM7SUFDVCx1QkFBdUIsRUFBRSxxREFBa0M7SUFDM0Qsc0JBQXNCLEVBQUUscURBQWtDO0lBQzFELG9CQUFvQixFQUFFLHFEQUFrQztJQUV4RCxVQUFVO0lBQ1Ysd0JBQXdCLEVBQUUsdURBQTJCO0lBQ3JELHFDQUFxQyxFQUFFLHVEQUEyQjtJQUNsRSw2QkFBNkIsRUFBRSx1REFBMkI7SUFFMUQsMEJBQTBCLEVBQUUsNkNBQThCO0lBQzFELHlCQUF5QixFQUFFLDBEQUFvQztJQUMvRCxrQ0FBa0MsRUFBRSwrREFBZ0M7SUFDcEUsNkJBQTZCLEVBQUUsOERBQXNDO0lBQ3JFLGtCQUFrQixFQUFFLDhEQUFzQztJQUUxRCxvQkFBb0IsRUFBRSxLQUFLLElBQUksRUFBRSxDQUFDLEVBQUU7Q0FDckMsQ0FBQztBQUVGOzs7Ozs7R0FNRztBQUNJLEtBQUssVUFBVSxvQkFBb0IsQ0FDeEMsV0FBd0IsRUFBRSxXQUFzQyxFQUNoRSxtQkFBd0MsRUFBRSxhQUFnRCxFQUMxRixXQUF3QjtJQUV4QiwyRkFBMkY7SUFDM0YsTUFBTSxXQUFXLEdBQUcsTUFBTSxXQUFXLENBQUMsa0JBQWtCLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQ3BGLDhHQUE4RztJQUM5RyxrR0FBa0c7SUFDbEcsTUFBTSxHQUFHLEdBQUcsQ0FBQyxN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QUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGVBQWUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUEsQ0FBQztZQUNwTSxJQUFBLGVBQUssRUFBQyx5Q0FBeUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxTQUFTLENBQUMsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsRUFBRSxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0tBQzdJO0lBRUQsSUFBQSxlQUFLLEVBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVO0FBQ3ZCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjZm5fZGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjaGFsayBmcm9tICdjaGFsayc7XG5pbXBvcnQgeyBJU0RLLCBNb2RlLCBTZGtQcm92aWRlciB9IGZyb20gJy4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgRGVwbG95U3RhY2tSZXN1bHQgfSBmcm9tICcuL2RlcGxveS1zdGFjayc7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlQXBwU3luY0NoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9hcHBzeW5jLW1hcHBpbmctdGVtcGxhdGVzJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlQ29kZUJ1aWxkUHJvamVjdENoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9jb2RlLWJ1aWxkLXByb2plY3RzJztcbmltcG9ydCB7IElDT04sIENoYW5nZUhvdHN3YXBSZXN1bHQsIEhvdHN3YXBNb2RlLCBIb3Rzd2FwcGFibGVDaGFuZ2UsIE5vbkhvdHN3YXBwYWJsZUNoYW5nZSwgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBDbGFzc2lmaWVkUmVzb3VyY2VDaGFuZ2VzLCByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UgfSBmcm9tICcuL2hvdHN3YXAvY29tbW9uJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9lY3Mtc2VydmljZXMnO1xuaW1wb3J0IHsgaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9sYW1iZGEtZnVuY3Rpb25zJztcbmltcG9ydCB7IGlzSG90c3dhcHBhYmxlUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlIH0gZnJvbSAnLi9ob3Rzd2FwL3MzLWJ1Y2tldC1kZXBsb3ltZW50cyc7XG5pbXBvcnQgeyBpc0hvdHN3YXBwYWJsZVN0YXRlTWFjaGluZUNoYW5nZSB9IGZyb20gJy4vaG90c3dhcC9zdGVwZnVuY3Rpb25zLXN0YXRlLW1hY2hpbmVzJztcbmltcG9ydCB7IGxvYWRDdXJyZW50VGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzLCBOZXN0ZWRTdGFja05hbWVzIH0gZnJvbSAnLi9uZXN0ZWQtc3RhY2staGVscGVycyc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvblN0YWNrIH0gZnJvbSAnLi91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IHByaW50IH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5cbnR5cGUgSG90c3dhcERldGVjdG9yID0gKFxuICBsb2dpY2FsSWQ6IHN0cmluZywgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZVxuKSA9PiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+O1xuXG5jb25zdCBSRVNPVVJDRV9ERVRFQ1RPUlM6IHsgW2tleTpzdHJpbmddOiBIb3Rzd2FwRGV0ZWN0b3IgfSA9IHtcbiAgLy8gTGFtYmRhXG4gICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuICAnQVdTOjpMYW1iZGE6OlZlcnNpb24nOiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlLFxuICAnQVdTOjpMYW1iZGE6OkFsaWFzJzogaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZSxcblxuICAvLyBBcHBTeW5jXG4gICdBV1M6OkFwcFN5bmM6OlJlc29sdmVyJzogaXNIb3Rzd2FwcGFibGVBcHBTeW5jQ2hhbmdlLFxuICAnQVdTOjpBcHBTeW5jOjpGdW5jdGlvbkNvbmZpZ3VyYXRpb24nOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG4gICdBV1M6OkFwcFN5bmM6OkdyYXBoUUxTY2hlbWEnOiBpc0hvdHN3YXBwYWJsZUFwcFN5bmNDaGFuZ2UsXG5cbiAgJ0FXUzo6RUNTOjpUYXNrRGVmaW5pdGlvbic6IGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZSxcbiAgJ0FXUzo6Q29kZUJ1aWxkOjpQcm9qZWN0JzogaXNIb3Rzd2FwcGFibGVDb2RlQnVpbGRQcm9qZWN0Q2hhbmdlLFxuICAnQVdTOjpTdGVwRnVuY3Rpb25zOjpTdGF0ZU1hY2hpbmUnOiBpc0hvdHN3YXBwYWJsZVN0YXRlTWFjaGluZUNoYW5nZSxcbiAgJ0N1c3RvbTo6Q0RLQnVja2V0RGVwbG95bWVudCc6IGlzSG90c3dhcHBhYmxlUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlLFxuICAnQVdTOjpJQU06OlBvbGljeSc6IGlzSG90c3dhcHBhYmxlUzNCdWNrZXREZXBsb3ltZW50Q2hhbmdlLFxuXG4gICdBV1M6OkNESzo6TWV0YWRhdGEnOiBhc3luYyAoKSA9PiBbXSxcbn07XG5cbi8qKlxuICogUGVyZm9ybSBhIGhvdHN3YXAgZGVwbG95bWVudCxcbiAqIHNob3J0LWNpcmN1aXRpbmcgQ2xvdWRGb3JtYXRpb24gaWYgcG9zc2libGUuXG4gKiBJZiBpdCdzIG5vdCBwb3NzaWJsZSB0byBzaG9ydC1jaXJjdWl0IHRoZSBkZXBsb3ltZW50XG4gKiAoYmVjYXVzZSB0aGUgQ0RLIFN0YWNrIGNvbnRhaW5zIGNoYW5nZXMgdGhhdCBjYW5ub3QgYmUgZGVwbG95ZWQgd2l0aG91dCBDbG91ZEZvcm1hdGlvbiksXG4gKiByZXR1cm5zIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdHJ5SG90c3dhcERlcGxveW1lbnQoXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlciwgYXNzZXRQYXJhbXM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nIH0sXG4gIGNsb3VkRm9ybWF0aW9uU3RhY2s6IENsb3VkRm9ybWF0aW9uU3RhY2ssIHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgaG90c3dhcE1vZGU6IEhvdHN3YXBNb2RlLFxuKTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdCB8IHVuZGVmaW5lZD4ge1xuICAvLyByZXNvbHZlIHRoZSBlbnZpcm9ubWVudCwgc28gd2UgY2FuIHN1YnN0aXR1dGUgdGhpbmdzIGxpa2UgQVdTOjpSZWdpb24gaW4gQ0ZOIGV4cHJlc3Npb25zXG4gIGNvbnN0IHJlc29sdmVkRW52ID0gYXdhaXQgc2RrUHJvdmlkZXIucmVzb2x2ZUVudmlyb25tZW50KHN0YWNrQXJ0aWZhY3QuZW52aXJvbm1lbnQpO1xuICAvLyBjcmVhdGUgYSBuZXcgU0RLIHVzaW5nIHRoZSBDTEkgY3JlZGVudGlhbHMsIGJlY2F1c2UgdGhlIGRlZmF1bHQgb25lIHdpbGwgbm90IHdvcmsgZm9yIG5ldy1zdHlsZSBzeW50aGVzaXMgLVxuICAvLyBpdCBhc3N1bWVzIHRoZSBib290c3RyYXAgZGVwbG95IFJvbGUsIHdoaWNoIGRvZXNuJ3QgaGF2ZSBwZXJtaXNzaW9ucyB0byB1cGRhdGUgTGFtYmRhIGZ1bmN0aW9uc1xuICBjb25zdCBzZGsgPSAoYXdhaXQgc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQocmVzb2x2ZWRFbnYsIE1vZGUuRm9yV3JpdGluZykpLnNkaztcblxuICBjb25zdCBjdXJyZW50VGVtcGxhdGUgPSBhd2FpdCBsb2FkQ3VycmVudFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyhzdGFja0FydGlmYWN0LCBzZGspO1xuXG4gIGNvbnN0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUgPSBuZXcgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlKHtcbiAgICBzdGFja05hbWU6IHN0YWNrQXJ0aWZhY3Quc3RhY2tOYW1lLFxuICAgIHRlbXBsYXRlOiBzdGFja0FydGlmYWN0LnRlbXBsYXRlLFxuICAgIHBhcmFtZXRlcnM6IGFzc2V0UGFyYW1zLFxuICAgIGFjY291bnQ6IHJlc29sdmVkRW52LmFjY291bnQsXG4gICAgcmVnaW9uOiByZXNvbHZlZEVudi5yZWdpb24sXG4gICAgcGFydGl0aW9uOiAoYXdhaXQgc2RrLmN1cnJlbnRBY2NvdW50KCkpLnBhcnRpdGlvbixcbiAgICB1cmxTdWZmaXg6IChyZWdpb24pID0+IHNkay5nZXRFbmRwb2ludFN1ZmZpeChyZWdpb24pLFxuICAgIHNkayxcbiAgICBuZXN0ZWRTdGFja05hbWVzOiBjdXJyZW50VGVtcGxhdGUubmVzdGVkU3RhY2tOYW1lcyxcbiAgfSk7XG5cbiAgY29uc3Qgc3RhY2tDaGFuZ2VzID0gY2ZuX2RpZmYuZGlmZlRlbXBsYXRlKGN1cnJlbnRUZW1wbGF0ZS5kZXBsb3llZFRlbXBsYXRlLCBzdGFja0FydGlmYWN0LnRlbXBsYXRlKTtcbiAgY29uc3QgeyBob3Rzd2FwcGFibGVDaGFuZ2VzLCBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzIH0gPSBhd2FpdCBjbGFzc2lmeVJlc291cmNlQ2hhbmdlcyhcbiAgICBzdGFja0NoYW5nZXMsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUsIHNkaywgY3VycmVudFRlbXBsYXRlLm5lc3RlZFN0YWNrTmFtZXMsXG4gICk7XG5cbiAgbG9nTm9uSG90c3dhcHBhYmxlQ2hhbmdlcyhub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLCBob3Rzd2FwTW9kZSk7XG5cbiAgLy8gcHJlc2VydmUgY2xhc3NpYyBob3Rzd2FwIGJlaGF2aW9yXG4gIGlmIChob3Rzd2FwTW9kZSA9PT0gSG90c3dhcE1vZGUuRkFMTF9CQUNLKSB7XG4gICAgaWYgKG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICAvLyBhcHBseSB0aGUgc2hvcnQtY2lyY3VpdGFibGUgY2hhbmdlc1xuICBhd2FpdCBhcHBseUFsbEhvdHN3YXBwYWJsZUNoYW5nZXMoc2RrLCBob3Rzd2FwcGFibGVDaGFuZ2VzKTtcblxuICByZXR1cm4geyBub09wOiBob3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCwgc3RhY2tBcm46IGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tJZCwgb3V0cHV0czogY2xvdWRGb3JtYXRpb25TdGFjay5vdXRwdXRzIH07XG59XG5cbi8qKlxuICogQ2xhc3NpZmllcyBhbGwgY2hhbmdlcyB0byBhbGwgcmVzb3VyY2VzIGFzIGVpdGhlciBob3Rzd2FwcGFibGUgb3Igbm90LlxuICogTWV0YWRhdGEgY2hhbmdlcyBhcmUgZXhjbHVkZWQgZnJvbSB0aGUgbGlzdCBvZiAobm9uKWhvdHN3YXBwYWJsZSByZXNvdXJjZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKFxuICBzdGFja0NoYW5nZXM6IGNmbl9kaWZmLlRlbXBsYXRlRGlmZixcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBzZGs6IElTREssXG4gIG5lc3RlZFN0YWNrTmFtZXM6IHsgW25lc3RlZFN0YWNrTmFtZTogc3RyaW5nXTogTmVzdGVkU3RhY2tOYW1lcyB9LFxuKTogUHJvbWlzZTxDbGFzc2lmaWVkUmVzb3VyY2VDaGFuZ2VzPiB7XG4gIGNvbnN0IHJlc291cmNlRGlmZmVyZW5jZXMgPSBnZXRTdGFja1Jlc291cmNlRGlmZmVyZW5jZXMoc3RhY2tDaGFuZ2VzKTtcblxuICBjb25zdCBwcm9taXNlczogQXJyYXk8KCkgPT4gUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0Pj4gPSBbXTtcbiAgY29uc3QgaG90c3dhcHBhYmxlUmVzb3VyY2VzID0gbmV3IEFycmF5PEhvdHN3YXBwYWJsZUNoYW5nZT4oKTtcbiAgY29uc3Qgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzID0gbmV3IEFycmF5PE5vbkhvdHN3YXBwYWJsZUNoYW5nZT4oKTtcbiAgZm9yIChjb25zdCBsb2dpY2FsSWQgb2YgT2JqZWN0LmtleXMoc3RhY2tDaGFuZ2VzLm91dHB1dHMuY2hhbmdlcykpIHtcbiAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaCh7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgcmVhc29uOiAnb3V0cHV0IHdhcyBjaGFuZ2VkJyxcbiAgICAgIGxvZ2ljYWxJZCxcbiAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICByZXNvdXJjZVR5cGU6ICdTdGFjayBPdXRwdXQnLFxuICAgIH0pO1xuICB9XG4gIC8vIGdhdGhlciB0aGUgcmVzdWx0cyBvZiB0aGUgZGV0ZWN0b3IgZnVuY3Rpb25zXG4gIGZvciAoY29uc3QgW2xvZ2ljYWxJZCwgY2hhbmdlXSBvZiBPYmplY3QuZW50cmllcyhyZXNvdXJjZURpZmZlcmVuY2VzKSkge1xuICAgIGlmIChjaGFuZ2UubmV3VmFsdWU/LlR5cGUgPT09ICdBV1M6OkNsb3VkRm9ybWF0aW9uOjpTdGFjaycgJiYgY2hhbmdlLm9sZFZhbHVlPy5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snKSB7XG4gICAgICBjb25zdCBuZXN0ZWRIb3Rzd2FwcGFibGVSZXNvdXJjZXMgPSBhd2FpdCBmaW5kTmVzdGVkSG90c3dhcHBhYmxlQ2hhbmdlcyhsb2dpY2FsSWQsIGNoYW5nZSwgbmVzdGVkU3RhY2tOYW1lcywgZXZhbHVhdGVDZm5UZW1wbGF0ZSwgc2RrKTtcbiAgICAgIGhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKC4uLm5lc3RlZEhvdHN3YXBwYWJsZVJlc291cmNlcy5ob3Rzd2FwcGFibGVDaGFuZ2VzKTtcbiAgICAgIG5vbkhvdHN3YXBwYWJsZVJlc291cmNlcy5wdXNoKC4uLm5lc3RlZEhvdHN3YXBwYWJsZVJlc291cmNlcy5ub25Ib3Rzd2FwcGFibGVDaGFuZ2VzKTtcblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlID0gaXNDYW5kaWRhdGVGb3JIb3Rzd2FwcGluZyhjaGFuZ2UsIGxvZ2ljYWxJZCk7XG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBydW4gdGhpcyB0aHJvdWdoIHRoZSBkZXRlY3RvciBmdW5jdGlvbnMsIHdlIGNhbiBhbHJlYWR5IGp1ZGdlIHRoaXNcbiAgICBpZiAoJ2hvdHN3YXBwYWJsZScgaW4gaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlKSB7XG4gICAgICBpZiAoIWhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZS5ob3Rzd2FwcGFibGUpIHtcbiAgICAgICAgbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLnB1c2goaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlKTtcbiAgICAgIH1cblxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb3VyY2VUeXBlOiBzdHJpbmcgPSBob3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUubmV3VmFsdWUuVHlwZTtcbiAgICBpZiAocmVzb3VyY2VUeXBlIGluIFJFU09VUkNFX0RFVEVDVE9SUykge1xuICAgICAgLy8gcnVuIGRldGVjdG9yIGZ1bmN0aW9ucyBsYXppbHkgdG8gcHJldmVudCB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25zXG4gICAgICBwcm9taXNlcy5wdXNoKCgpID0+IFJFU09VUkNFX0RFVEVDVE9SU1tyZXNvdXJjZVR5cGVdKGxvZ2ljYWxJZCwgaG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZShub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMsIGhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgdW5kZWZpbmVkLCAnVGhpcyByZXNvdXJjZSB0eXBlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGhvdHN3YXAgZGVwbG95bWVudHMnKTtcbiAgICB9XG4gIH1cblxuICAvLyByZXNvbHZlIGFsbCBkZXRlY3RvciByZXN1bHRzXG4gIGNvbnN0IGNoYW5nZXNEZXRlY3Rpb25SZXN1bHRzOiBBcnJheTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiA9IFtdO1xuICBmb3IgKGNvbnN0IGRldGVjdG9yUmVzdWx0UHJvbWlzZXMgb2YgcHJvbWlzZXMpIHtcbiAgICBjb25zdCBob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGF3YWl0IGRldGVjdG9yUmVzdWx0UHJvbWlzZXMoKSk7XG4gICAgY2hhbmdlc0RldGVjdGlvblJlc3VsdHMucHVzaChob3Rzd2FwRGV0ZWN0aW9uUmVzdWx0cyk7XG4gIH1cblxuICBmb3IgKGNvbnN0IHJlc291cmNlRGV0ZWN0aW9uUmVzdWx0cyBvZiBjaGFuZ2VzRGV0ZWN0aW9uUmVzdWx0cykge1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlSZXN1bHQgb2YgcmVzb3VyY2VEZXRlY3Rpb25SZXN1bHRzKSB7XG4gICAgICBwcm9wZXJ0eVJlc3VsdC5ob3Rzd2FwcGFibGUgP1xuICAgICAgICBob3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChwcm9wZXJ0eVJlc3VsdCkgOlxuICAgICAgICBub25Ib3Rzd2FwcGFibGVSZXNvdXJjZXMucHVzaChwcm9wZXJ0eVJlc3VsdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBob3Rzd2FwcGFibGVDaGFuZ2VzOiBob3Rzd2FwcGFibGVSZXNvdXJjZXMsXG4gICAgbm9uSG90c3dhcHBhYmxlQ2hhbmdlczogbm9uSG90c3dhcHBhYmxlUmVzb3VyY2VzLFxuICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGNoYW5nZXMgdG8gcmVzb3VyY2VzIGluIHRoZSBnaXZlbiBTdGFjay5cbiAqXG4gKiBAcGFyYW0gc3RhY2tDaGFuZ2VzIHRoZSBjb2xsZWN0aW9uIG9mIGFsbCBjaGFuZ2VzIHRvIGEgZ2l2ZW4gU3RhY2tcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhY2tSZXNvdXJjZURpZmZlcmVuY2VzKHN0YWNrQ2hhbmdlczogY2ZuX2RpZmYuVGVtcGxhdGVEaWZmKTogeyBbbG9naWNhbElkOiBzdHJpbmddOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UgfSB7XG4gIC8vIHdlIG5lZWQgdG8gY29sbGFwc2UgbG9naWNhbCBJRCByZW5hbWUgY2hhbmdlcyBpbnRvIG9uZSBjaGFuZ2UsXG4gIC8vIGFzIHRoZXkgYXJlIHJlcHJlc2VudGVkIGluIHN0YWNrQ2hhbmdlcyBhcyBhIHBhaXIgb2YgdHdvIGNoYW5nZXM6IG9uZSBhZGRpdGlvbiBhbmQgb25lIHJlbW92YWxcbiAgY29uc3QgYWxsUmVzb3VyY2VDaGFuZ2VzOiB7IFtsb2dJZDogc3RyaW5nXTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlIH0gPSBzdGFja0NoYW5nZXMucmVzb3VyY2VzLmNoYW5nZXM7XG4gIGNvbnN0IGFsbFJlbW92YWxDaGFuZ2VzID0gZmlsdGVyRGljdChhbGxSZXNvdXJjZUNoYW5nZXMsIHJlc0NoYW5nZSA9PiByZXNDaGFuZ2UuaXNSZW1vdmFsKTtcbiAgY29uc3QgYWxsTm9uUmVtb3ZhbENoYW5nZXMgPSBmaWx0ZXJEaWN0KGFsbFJlc291cmNlQ2hhbmdlcywgcmVzQ2hhbmdlID0+ICFyZXNDaGFuZ2UuaXNSZW1vdmFsKTtcbiAgZm9yIChjb25zdCBbbG9nSWQsIG5vblJlbW92YWxDaGFuZ2VdIG9mIE9iamVjdC5lbnRyaWVzKGFsbE5vblJlbW92YWxDaGFuZ2VzKSkge1xuICAgIGlmIChub25SZW1vdmFsQ2hhbmdlLmlzQWRkaXRpb24pIHtcbiAgICAgIGNvbnN0IGFkZENoYW5nZSA9IG5vblJlbW92YWxDaGFuZ2U7XG4gICAgICAvLyBzZWFyY2ggZm9yIGFuIGlkZW50aWNhbCByZW1vdmFsIGNoYW5nZVxuICAgICAgY29uc3QgaWRlbnRpY2FsUmVtb3ZhbENoYW5nZSA9IE9iamVjdC5lbnRyaWVzKGFsbFJlbW92YWxDaGFuZ2VzKS5maW5kKChbXywgcmVtQ2hhbmdlXSkgPT4ge1xuICAgICAgICByZXR1cm4gY2hhbmdlc0FyZUZvclNhbWVSZXNvdXJjZShyZW1DaGFuZ2UsIGFkZENoYW5nZSk7XG4gICAgICB9KTtcbiAgICAgIC8vIGlmIHdlIGZvdW5kIG9uZSwgdGhlbiB0aGlzIG1lYW5zIHRoaXMgaXMgYSByZW5hbWUgY2hhbmdlXG4gICAgICBpZiAoaWRlbnRpY2FsUmVtb3ZhbENoYW5nZSkge1xuICAgICAgICBjb25zdCBbcmVtb3ZlZExvZ0lkLCByZW1vdmVkUmVzb3VyY2VDaGFuZ2VdID0gaWRlbnRpY2FsUmVtb3ZhbENoYW5nZTtcbiAgICAgICAgYWxsTm9uUmVtb3ZhbENoYW5nZXNbbG9nSWRdID0gbWFrZVJlbmFtZURpZmZlcmVuY2UocmVtb3ZlZFJlc291cmNlQ2hhbmdlLCBhZGRDaGFuZ2UpO1xuICAgICAgICAvLyBkZWxldGUgdGhlIHJlbW92YWwgY2hhbmdlIHRoYXQgZm9ybXMgdGhlIHJlbmFtZSBwYWlyXG4gICAgICAgIGRlbGV0ZSBhbGxSZW1vdmFsQ2hhbmdlc1tyZW1vdmVkTG9nSWRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyB0aGUgZmluYWwgcmVzdWx0IGFyZSBhbGwgb2YgdGhlIHJlbWFpbmluZyByZW1vdmFsIGNoYW5nZXMsXG4gIC8vIHBsdXMgYWxsIG9mIHRoZSBub24tcmVtb3ZhbCBjaGFuZ2VzXG4gIC8vICh3ZSBzYXZlZCB0aGUgcmVuYW1lIGNoYW5nZXMgaW4gdGhhdCBvYmplY3QgYWxyZWFkeSlcbiAgcmV0dXJuIHtcbiAgICAuLi5hbGxSZW1vdmFsQ2hhbmdlcyxcbiAgICAuLi5hbGxOb25SZW1vdmFsQ2hhbmdlcyxcbiAgfTtcbn1cblxuLyoqIEZpbHRlcnMgYW4gb2JqZWN0IHdpdGggc3RyaW5nIGtleXMgYmFzZWQgb24gd2hldGhlciB0aGUgY2FsbGJhY2sgcmV0dXJucyAndHJ1ZScgZm9yIHRoZSBnaXZlbiB2YWx1ZSBpbiB0aGUgb2JqZWN0LiAqL1xuZnVuY3Rpb24gZmlsdGVyRGljdDxUPihkaWN0OiB7IFtrZXk6IHN0cmluZ106IFQgfSwgZnVuYzogKHQ6IFQpID0+IGJvb2xlYW4pOiB7IFtrZXk6IHN0cmluZ106IFQgfSB7XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhkaWN0KS5yZWR1Y2UoKGFjYywgW2tleSwgdF0pID0+IHtcbiAgICBpZiAoZnVuYyh0KSkge1xuICAgICAgYWNjW2tleV0gPSB0O1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSBhcyB7IFtrZXk6IHN0cmluZ106IFQgfSk7XG59XG5cbi8qKiBGaW5kcyBhbnkgaG90c3dhcHBhYmxlIGNoYW5nZXMgaW4gYWxsIG5lc3RlZCBzdGFja3MuICovXG5hc3luYyBmdW5jdGlvbiBmaW5kTmVzdGVkSG90c3dhcHBhYmxlQ2hhbmdlcyhcbiAgbG9naWNhbElkOiBzdHJpbmcsXG4gIGNoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLFxuICBuZXN0ZWRTdGFja05hbWVzOiB7IFtuZXN0ZWRTdGFja05hbWU6IHN0cmluZ106IE5lc3RlZFN0YWNrTmFtZXMgfSxcbiAgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuICBzZGs6IElTREssXG4pOiBQcm9taXNlPENsYXNzaWZpZWRSZXNvdXJjZUNoYW5nZXM+IHtcbiAgY29uc3QgbmVzdGVkU3RhY2tOYW1lID0gbmVzdGVkU3RhY2tOYW1lc1tsb2dpY2FsSWRdLm5lc3RlZFN0YWNrUGh5c2ljYWxOYW1lO1xuICBpZiAoIW5lc3RlZFN0YWNrTmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGVDaGFuZ2VzOiBbXSxcbiAgICAgIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXM6IFt7XG4gICAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICAgIGxvZ2ljYWxJZCxcbiAgICAgICAgcmVhc29uOiBgcGh5c2ljYWwgbmFtZSBmb3IgQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2sgJyR7bG9naWNhbElkfScgY291bGQgbm90IGJlIGZvdW5kIGluIENsb3VkRm9ybWF0aW9uLCBzbyB0aGlzIGlzIGEgbmV3bHkgY3JlYXRlZCBuZXN0ZWQgc3RhY2sgYW5kIGNhbm5vdCBiZSBob3Rzd2FwcGVkYCxcbiAgICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgICAgcmVzb3VyY2VUeXBlOiAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snLFxuICAgICAgfV0sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IGV2YWx1YXRlTmVzdGVkQ2ZuVGVtcGxhdGUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmNyZWF0ZU5lc3RlZEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZShcbiAgICBuZXN0ZWRTdGFja05hbWUsIGNoYW5nZS5uZXdWYWx1ZT8uUHJvcGVydGllcz8uTmVzdGVkVGVtcGxhdGUsIGNoYW5nZS5uZXdWYWx1ZT8uUHJvcGVydGllcz8uUGFyYW1ldGVycyxcbiAgKTtcblxuICBjb25zdCBuZXN0ZWREaWZmID0gY2ZuX2RpZmYuZGlmZlRlbXBsYXRlKFxuICAgIGNoYW5nZS5vbGRWYWx1ZT8uUHJvcGVydGllcz8uTmVzdGVkVGVtcGxhdGUsIGNoYW5nZS5uZXdWYWx1ZT8uUHJvcGVydGllcz8uTmVzdGVkVGVtcGxhdGUsXG4gICk7XG5cbiAgcmV0dXJuIGNsYXNzaWZ5UmVzb3VyY2VDaGFuZ2VzKG5lc3RlZERpZmYsIGV2YWx1YXRlTmVzdGVkQ2ZuVGVtcGxhdGUsIHNkaywgbmVzdGVkU3RhY2tOYW1lc1tsb2dpY2FsSWRdLm5lc3RlZENoaWxkU3RhY2tOYW1lcyk7XG59XG5cbi8qKiBSZXR1cm5zICd0cnVlJyBpZiBhIHBhaXIgb2YgY2hhbmdlcyBpcyBmb3IgdGhlIHNhbWUgcmVzb3VyY2UuICovXG5mdW5jdGlvbiBjaGFuZ2VzQXJlRm9yU2FtZVJlc291cmNlKG9sZENoYW5nZTogY2ZuX2RpZmYuUmVzb3VyY2VEaWZmZXJlbmNlLCBuZXdDaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gb2xkQ2hhbmdlLm9sZFJlc291cmNlVHlwZSA9PT0gbmV3Q2hhbmdlLm5ld1Jlc291cmNlVHlwZSAmJlxuICAgICAgLy8gdGhpcyBpc24ndCBncmVhdCwgYnV0IEkgZG9uJ3Qgd2FudCB0byBicmluZyBpbiBzb21ldGhpbmcgbGlrZSB1bmRlcnNjb3JlIGp1c3QgZm9yIHRoaXMgY29tcGFyaXNvblxuICAgICAgSlNPTi5zdHJpbmdpZnkob2xkQ2hhbmdlLm9sZFByb3BlcnRpZXMpID09PSBKU09OLnN0cmluZ2lmeShuZXdDaGFuZ2UubmV3UHJvcGVydGllcyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VSZW5hbWVEaWZmZXJlbmNlKFxuICByZW1DaGFuZ2U6IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZSxcbiAgYWRkQ2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsXG4pOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2Uge1xuICByZXR1cm4gbmV3IGNmbl9kaWZmLlJlc291cmNlRGlmZmVyZW5jZShcbiAgICAvLyB3ZSBoYXZlIHRvIGZpbGwgaW4gdGhlIG9sZCB2YWx1ZSwgYmVjYXVzZSBvdGhlcndpc2UgdGhpcyB3aWxsIGJlIGNsYXNzaWZpZWQgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZVxuICAgIHJlbUNoYW5nZS5vbGRWYWx1ZSxcbiAgICBhZGRDaGFuZ2UubmV3VmFsdWUsXG4gICAge1xuICAgICAgcmVzb3VyY2VUeXBlOiB7XG4gICAgICAgIG9sZFR5cGU6IHJlbUNoYW5nZS5vbGRSZXNvdXJjZVR5cGUsXG4gICAgICAgIG5ld1R5cGU6IGFkZENoYW5nZS5uZXdSZXNvdXJjZVR5cGUsXG4gICAgICB9LFxuICAgICAgcHJvcGVydHlEaWZmczogKGFkZENoYW5nZSBhcyBhbnkpLnByb3BlcnR5RGlmZnMsXG4gICAgICBvdGhlckRpZmZzOiAoYWRkQ2hhbmdlIGFzIGFueSkub3RoZXJEaWZmcyxcbiAgICB9LFxuICApO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlYCBpZiB0aGUgY2hhbmdlIGlzIGhvdHN3YXBwYWJsZVxuICogUmV0dXJucyBhbiBlbXB0eSBgSG90c3dhcHBhYmxlQ2hhbmdlYCBpZiB0aGUgY2hhbmdlIGlzIHRvIENESzo6TWV0YWRhdGFcbiAqIFJldHVybnMgYSBgTm9uSG90c3dhcHBhYmxlQ2hhbmdlYCBpZiB0aGUgY2hhbmdlIGlzIG5vdCBob3Rzd2FwcGFibGVcbiAqL1xuZnVuY3Rpb24gaXNDYW5kaWRhdGVGb3JIb3Rzd2FwcGluZyhcbiAgY2hhbmdlOiBjZm5fZGlmZi5SZXNvdXJjZURpZmZlcmVuY2UsIGxvZ2ljYWxJZDogc3RyaW5nLFxuKTogSG90c3dhcHBhYmxlQ2hhbmdlIHwgTm9uSG90c3dhcHBhYmxlQ2hhbmdlIHwgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlIHtcbiAgLy8gYSByZXNvdXJjZSBoYXMgYmVlbiByZW1vdmVkIE9SIGEgcmVzb3VyY2UgaGFzIGJlZW4gYWRkZWQ7IHdlIGNhbid0IHNob3J0LWNpcmN1aXQgdGhhdCBjaGFuZ2VcbiAgaWYgKCFjaGFuZ2Uub2xkVmFsdWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaG90c3dhcHBhYmxlOiBmYWxzZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlIS5UeXBlLFxuICAgICAgbG9naWNhbElkLFxuICAgICAgcmVqZWN0ZWRDaGFuZ2VzOiBbXSxcbiAgICAgIHJlYXNvbjogYHJlc291cmNlICcke2xvZ2ljYWxJZH0nIHdhcyBjcmVhdGVkIGJ5IHRoaXMgZGVwbG95bWVudGAsXG4gICAgfTtcbiAgfSBlbHNlIGlmICghY2hhbmdlLm5ld1ZhbHVlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhvdHN3YXBwYWJsZTogZmFsc2UsXG4gICAgICByZXNvdXJjZVR5cGU6IGNoYW5nZS5vbGRWYWx1ZSEuVHlwZSxcbiAgICAgIGxvZ2ljYWxJZCxcbiAgICAgIHJlamVjdGVkQ2hhbmdlczogW10sXG4gICAgICByZWFzb246IGByZXNvdXJjZSAnJHtsb2dpY2FsSWR9JyB3YXMgZGVzdHJveWVkIGJ5IHRoaXMgZGVwbG95bWVudGAsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGEgcmVzb3VyY2UgaGFzIGhhZCBpdHMgdHlwZSBjaGFuZ2VkXG4gIGlmIChjaGFuZ2UubmV3VmFsdWU/LlR5cGUgIT09IGNoYW5nZS5vbGRWYWx1ZT8uVHlwZSkge1xuICAgIHJldHVybiB7XG4gICAgICBob3Rzd2FwcGFibGU6IGZhbHNlLFxuICAgICAgcmVzb3VyY2VUeXBlOiBjaGFuZ2UubmV3VmFsdWU/LlR5cGUsXG4gICAgICBsb2dpY2FsSWQsXG4gICAgICByZWplY3RlZENoYW5nZXM6IFtdLFxuICAgICAgcmVhc29uOiBgcmVzb3VyY2UgJyR7bG9naWNhbElkfScgaGFkIGl0cyB0eXBlIGNoYW5nZWQgZnJvbSAnJHtjaGFuZ2Uub2xkVmFsdWU/LlR5cGV9JyB0byAnJHtjaGFuZ2UubmV3VmFsdWU/LlR5cGV9J2AsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbG9naWNhbElkLFxuICAgIG9sZFZhbHVlOiBjaGFuZ2Uub2xkVmFsdWUsXG4gICAgbmV3VmFsdWU6IGNoYW5nZS5uZXdWYWx1ZSxcbiAgICBwcm9wZXJ0eVVwZGF0ZXM6IGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMsXG4gIH07XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5QWxsSG90c3dhcHBhYmxlQ2hhbmdlcyhzZGs6IElTREssIGhvdHN3YXBwYWJsZUNoYW5nZXM6IEhvdHN3YXBwYWJsZUNoYW5nZVtdKTogUHJvbWlzZTx2b2lkW10+IHtcbiAgaWYgKGhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgIHByaW50KGBcXG4ke0lDT059IGhvdHN3YXBwaW5nIHJlc291cmNlczpgKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoaG90c3dhcHBhYmxlQ2hhbmdlcy5tYXAoaG90c3dhcE9wZXJhdGlvbiA9PiB7XG4gICAgcmV0dXJuIGFwcGx5SG90c3dhcHBhYmxlQ2hhbmdlKHNkaywgaG90c3dhcE9wZXJhdGlvbik7XG4gIH0pKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXBwbHlIb3Rzd2FwcGFibGVDaGFuZ2Uoc2RrOiBJU0RLLCBob3Rzd2FwT3BlcmF0aW9uOiBIb3Rzd2FwcGFibGVDaGFuZ2UpOiBQcm9taXNlPHZvaWQ+IHtcbiAgLy8gbm90ZSB0aGUgdHlwZSBvZiBzZXJ2aWNlIHRoYXQgd2FzIHN1Y2Nlc3NmdWxseSBob3Rzd2FwcGVkIGluIHRoZSBVc2VyLUFnZW50XG4gIGNvbnN0IGN1c3RvbVVzZXJBZ2VudCA9IGBjZGstaG90c3dhcC9zdWNjZXNzLSR7aG90c3dhcE9wZXJhdGlvbi5zZXJ2aWNlfWA7XG4gIHNkay5hcHBlbmRDdXN0b21Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcblxuICBmb3IgKGNvbnN0IG5hbWUgb2YgaG90c3dhcE9wZXJhdGlvbi5yZXNvdXJjZU5hbWVzKSB7XG4gICAgcHJpbnQoYCAgICR7SUNPTn0gJXNgLCBjaGFsay5ib2xkKG5hbWUpKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSBTREsgY2FsbCBmYWlscywgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24gYnkgdGhlIFNES1xuICAvLyBhbmQgd2lsbCBwcmV2ZW50IHRoZSBncmVlbiAnaG90c3dhcHBlZCEnIHRleHQgZnJvbSBiZWluZyBkaXNwbGF5ZWRcbiAgYXdhaXQgaG90c3dhcE9wZXJhdGlvbi5hcHBseShzZGspO1xuXG4gIGZvciAoY29uc3QgbmFtZSBvZiBob3Rzd2FwT3BlcmF0aW9uLnJlc291cmNlTmFtZXMpIHtcbiAgICBwcmludChgJHtJQ09OfSAlcyAlc2AsIGNoYWxrLmJvbGQobmFtZSksIGNoYWxrLmdyZWVuKCdob3Rzd2FwcGVkIScpKTtcbiAgfVxuXG4gIHNkay5yZW1vdmVDdXN0b21Vc2VyQWdlbnQoY3VzdG9tVXNlckFnZW50KTtcbn1cblxuZnVuY3Rpb24gbG9nTm9uSG90c3dhcHBhYmxlQ2hhbmdlcyhub25Ib3Rzd2FwcGFibGVDaGFuZ2VzOiBOb25Ib3Rzd2FwcGFibGVDaGFuZ2VbXSwgaG90c3dhcE1vZGU6IEhvdHN3YXBNb2RlKTogdm9pZCB7XG4gIGlmIChub25Ib3Rzd2FwcGFibGVDaGFuZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvKipcbiAgICogRUtTIFNlcnZpY2VzIGNhbiBoYXZlIGEgdGFzayBkZWZpbml0aW9uIHRoYXQgZG9lc24ndCByZWZlciB0byB0aGUgdGFzayBkZWZpbml0aW9uIGJlaW5nIHVwZGF0ZWQuXG4gICAqIFdlIGhhdmUgdG8gbG9nIHRoaXMgYXMgYSBub24taG90c3dhcHBhYmxlIGNoYW5nZSB0byB0aGUgdGFzayBkZWZpbml0aW9uLCBidXQgd2hlbiB3ZSBkbyxcbiAgICogd2Ugd2luZCB1cCBob3Rzd2FwcGluZyB0aGUgdGFzayBkZWZpbml0aW9uIGFuZCBsb2dnaW5nIGl0IGFzIGEgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2UuXG4gICAqXG4gICAqIFRoaXMgbG9naWMgcHJldmVudHMgdXMgZnJvbSBsb2dnaW5nIHRoYXQgY2hhbmdlIGFzIG5vbi1ob3Rzd2FwcGFibGUgd2hlbiB3ZSBob3Rzd2FwIGl0LlxuICAgKi9cbiAgaWYgKGhvdHN3YXBNb2RlID09PSBIb3Rzd2FwTW9kZS5IT1RTV0FQX09OTFkpIHtcbiAgICBub25Ib3Rzd2FwcGFibGVDaGFuZ2VzID0gbm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSkgPT4gY2hhbmdlLmhvdHN3YXBPbmx5VmlzaWJsZSA9PT0gdHJ1ZSk7XG5cbiAgICBpZiAobm9uSG90c3dhcHBhYmxlQ2hhbmdlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgaWYgKGhvdHN3YXBNb2RlID09PSBIb3Rzd2FwTW9kZS5IT1RTV0FQX09OTFkpIHtcbiAgICBwcmludCgnXFxuJXMgJXMnLCBjaGFsay5yZWQoJ+KaoO+4jycpLCBjaGFsay5yZWQoJ1RoZSBmb2xsb3dpbmcgbm9uLWhvdHN3YXBwYWJsZSBjaGFuZ2VzIHdlcmUgZm91bmQuIFRvIHJlY29uY2lsZSB0aGVzZSB1c2luZyBDbG91ZEZvcm1hdGlvbiwgc3BlY2lmeSAtLWhvdHN3YXAtZmFsbGJhY2snKSk7XG4gIH0gZWxzZSB7XG4gICAgcHJpbnQoJ1xcbiVzICVzJywgY2hhbGsucmVkKCfimqDvuI8nKSwgY2hhbGsucmVkKCdUaGUgZm9sbG93aW5nIG5vbi1ob3Rzd2FwcGFibGUgY2hhbmdlcyB3ZXJlIGZvdW5kOicpKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgY2hhbmdlIG9mIG5vbkhvdHN3YXBwYWJsZUNoYW5nZXMpIHtcbiAgICBjaGFuZ2UucmVqZWN0ZWRDaGFuZ2VzLmxlbmd0aCA+IDAgP1xuICAgICAgcHJpbnQoJyAgICBsb2dpY2FsSUQ6ICVzLCB0eXBlOiAlcywgcmVqZWN0ZWQgY2hhbmdlczogJXMsIHJlYXNvbjogJXMnLCBjaGFsay5ib2xkKGNoYW5nZS5sb2dpY2FsSWQpLCBjaGFsay5ib2xkKGNoYW5nZS5yZXNvdXJjZVR5cGUpLCBjaGFsay5ib2xkKGNoYW5nZS5yZWplY3RlZENoYW5nZXMpLCBjaGFsay5yZWQoY2hhbmdlLnJlYXNvbikpOlxuICAgICAgcHJpbnQoJyAgICBsb2dpY2FsSUQ6ICVzLCB0eXBlOiAlcywgcmVhc29uOiAlcycsIGNoYWxrLmJvbGQoY2hhbmdlLmxvZ2ljYWxJZCksIGNoYWxrLmJvbGQoY2hhbmdlLnJlc291cmNlVHlwZSksIGNoYWxrLnJlZChjaGFuZ2UucmVhc29uKSk7XG4gIH1cblxuICBwcmludCgnJyk7IC8vIG5ld2xpbmVcbn1cbiJdfQ==