'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var immer = require('immer');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var BASIC = 0;
var OBJECT = 1;
var ARRAY = 2;
var MAP = 3;
var SET = 4;

var cantAccess = function cantAccess(thing, key) {
  return new Error("Cant access property " + String(key) + " of " + String(thing));
};

function getType(thing) {
  if (thing instanceof Map) return MAP;
  if (thing instanceof Set) return SET;
  if (Array.isArray(thing)) return ARRAY;
  if (thing instanceof Object) return OBJECT;
  return BASIC;
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any

function has(thing, key) {
  var type = getType(thing);

  if (type === OBJECT) {
    return key in thing;
  }

  if (type === ARRAY) {
    var index = key;
    return index < thing.length && index > -1;
  }

  if (type === MAP || type === SET) {
    return thing.has(key);
  }

  throw cantAccess(thing, key);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any

function get(thing, key) {
  var type = getType(thing);

  if (type === BASIC) {
    throw cantAccess(thing, key);
  }

  if (type === MAP) {
    return thing.get(key);
  }

  if (type === SET) {
    return thing.has(key) ? key : undefined;
  }

  return thing[key];
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any

function getIn(thing, path) {
  return path.reduce(function (red, key) {
    return get(red, key);
  }, thing);
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any

function set(thing, key, value) {
  var type = getType(thing);

  if (type === BASIC) {
    throw cantAccess(thing, key);
  }

  if (type === MAP) {
    return thing.set(key, value);
  }

  if (type === SET) {
    thing["delete"](key);
    thing.add(value);
    return;
  }

  thing[key] = value;
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any

function entries(thing) {
  var type = getType(thing);
  if (type === OBJECT) return Object.entries(thing);
  if (type === ARRAY || type === MAP || type === SET) return Array.from(thing.entries());
  throw cantAccess(thing, 'any');
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any

function clone(thing) {
  var type = getType(thing);
  if (type === OBJECT) return _extends({}, thing);
  if (type === ARRAY) return thing.slice();
  if (type === MAP) return new Map(thing);
  if (type === SET) return new Set(thing);
  return thing;
} // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any

function create(type) {
  if (type === OBJECT) return {};
  if (type === ARRAY) return [];
  if (type === MAP) return new Map();
  if (type === SET) return new Set();
  return undefined;
}

var zoomInPatches = function zoomInPatches(path, patches) {
  return patches.filter(function (patch) {
    return path.every(function (elem, index) {
      return elem === patch.path[index];
    });
  }).map(function (patch) {
    return _extends({}, patch, {
      path: patch.path.slice(path.length)
    });
  });
};
var zoomOutPatches = function zoomOutPatches(path, patches) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  return patches.map(function (patch) {
    var newPatch = _extends({}, patch, {
      path: path.concat(patch.path)
    });

    if (patch.from) {
      newPatch.from = path.concat(patch.from);
    }

    return newPatch;
  });
};

immer.enablePatches(); //
// optimise()
//
// chunks patches into groups where paths are the same
// and optimises patches that relates to transformations on an array
//
// e.g.
// value at ['foo','bar'] is an array
//
// [
//   {path: ['foo'], ...}
//   {path: ['foo'], ...}
//   {path: ['foo','bar', 0], ...} // optimise this
//   {path: ['foo','bar', 1], ...} // optimise this
//   {path: ['foo','bar', 2], ...} // optimise this
//   {path: ['foo','qux'], ...}
// ]
//

var optimise = function optimise(base, patches) {
  var newPatches = []; // check path is array (memoised)

  var lastResult;

  var checkPathIsArray = function checkPathIsArray(base, path) {
    var pathString = JSON.stringify(path);
    if (lastResult && lastResult[1] === pathString) return lastResult[0];
    var isArray = Array.isArray(getIn(base, path));
    lastResult = [isArray, pathString];
    return isArray;
  }; // buffer


  var currentPath;
  var buffer = [];

  var flush = function flush() {
    if (buffer.length === 0) return;

    if (currentPath) {
      var baseAtPath = getIn(base, currentPath);
      var patchesAtPath = zoomInPatches(currentPath, buffer); // optimise patches

      var optimisedPatches = optimiseArray(baseAtPath, patchesAtPath);
      var zoomedOutPatches = zoomOutPatches(currentPath, optimisedPatches);
      newPatches = newPatches.concat(zoomedOutPatches);
    } else {
      newPatches = newPatches.concat(buffer);
    }

    buffer = [];
  }; // seek


  patches.forEach(function (patch) {
    var _patch = patch,
        path = _patch.path;
    var parentPath = path.slice(0, -1);
    var thisPath = checkPathIsArray(base, parentPath) ? parentPath : undefined; // reset buffer whenever path changes

    if (JSON.stringify(thisPath) !== JSON.stringify(currentPath)) {
      flush();
      currentPath = thisPath;
    }

    if (patch.value === immer.nothing) {
      patch = _extends({}, patch, {
        value: undefined
      });
    } // ^ bug fix until https://github.com/immerjs/immer/issues/791


    buffer.push(patch);
  });
  flush(); // output

  return newPatches;
}; //
// optimiseArray()
//
// accepts patches with a common path relating to an array
// applies them, and optimises the patches required to produce
// the same result by using 'move' patches
//

var optimiseArray = function optimiseArray(base, patches) {
  var newPatches = []; // give unique id numbers to all values in base and patches for processing

  var id = 0;
  var valueToId = new Map();
  var idToValue = new Map();

  var addItem = function addItem(value) {
    if (valueToId.has(value)) {
      return valueToId.get(value);
    }

    var newId = id++;
    valueToId.set(value, newId);
    idToValue.set(newId, value);
    return newId;
  }; // add items from base


  var baseIds = base.map(addItem);
  var baseIdSet = new Set(baseIds); // add items from patches

  var targetIds = [];

  if (patches.length === 1 && patches[0].path.length === 0) {
    // this is a top level replace, substitute element ids directly
    var value = patches[0].value;
    if (!Array.isArray(value)) return patches;
    targetIds = value.map(addItem);
  } else if (base.some(function (b) {
    return typeof b !== 'object';
  })) {
    // if any primitives are in the array, we cant reliably track by reference
    // so skip the optimisation
    return patches;
  } else {
    var replacedPatches = patches.map(function (patch) {
      var op = patch.op,
          value = patch.value,
          path = patch.path;

      if (op === 'remove' // if 'remove', no value exists
      || op === 'replace' && path.length === 1 && path[0] === 'length' // this is an array length change
      ) {
          return patch;
        }

      return _extends({}, patch, {
        value: addItem(value)
      });
    });
    targetIds = immer.applyPatches(baseIds, replacedPatches);
  } // ignoring newly added values
  // look at each id in the target array
  // and add a 'move' operation that will move each id into the correct position


  var existingTargetIds = targetIds.filter(function (id) {
    return baseIdSet.has(id);
  });
  var wipIds = baseIds.slice(); // this array can be mutated as the sort progresses

  existingTargetIds.forEach(function (targetId, index) {
    if (targetId !== wipIds[index]) {
      var fromIndex = wipIds.indexOf(targetId);
      newPatches.push({
        op: 'move',
        from: [fromIndex],
        path: [index]
      });
      wipIds.splice(fromIndex, 1);
      wipIds.splice(index, 0, targetId);
    }
  }); // after this sorting is done
  // all the items to be removed will be collected at the end of the array
  // and can be truncated off

  if (existingTargetIds.length < baseIds.length) {
    newPatches.push({
      op: 'replace',
      path: ['length'],
      value: existingTargetIds.length
    });
  } // finally, add new items into result


  targetIds.forEach(function (id, index) {
    if (!baseIdSet.has(id)) {
      var _value = idToValue.get(id);

      newPatches.push({
        op: 'add',
        path: [index],
        value: _value
      });
    }
  });
  return newPatches;
};

var applyPatches = function applyPatches(base, patches) {
  patches.forEach(function (patch) {
    if (patch.op === 'move') {
      var patchFrom = patch.from;
      base = immer.applyPatches(base, [{
        op: 'remove',
        path: patchFrom
      }, {
        op: 'add',
        path: patch.path,
        value: getIn(base, patchFrom)
      }]);
    } else {
      base = immer.applyPatches(base, [patch]);
    }
  });
  return base;
};

exports.ARRAY = ARRAY;
exports.BASIC = BASIC;
exports.MAP = MAP;
exports.OBJECT = OBJECT;
exports.SET = SET;
exports.applyPatches = applyPatches;
exports.clone = clone;
exports.create = create;
exports.entries = entries;
exports.get = get;
exports.getIn = getIn;
exports.getType = getType;
exports.has = has;
exports.optimise = optimise;
exports.optimiseArray = optimiseArray;
exports.set = set;
exports.zoomInPatches = zoomInPatches;
exports.zoomOutPatches = zoomOutPatches;
//# sourceMappingURL=dendriform-immer-patch-optimiser.cjs.development.js.map
