{"version":3,"file":"dendriform-immer-patch-optimiser.cjs.production.min.js","sources":["../src/traverse.ts","../src/zoomPatches.ts","../src/optimise.ts","../src/applyPatches.ts"],"sourcesContent":["import type {Key} from './types';\n\nexport const BASIC = 0;\nexport const OBJECT = 1;\nexport const ARRAY = 2;\nexport const MAP = 3;\nexport const SET = 4;\n\nexport type DataType = typeof ARRAY|typeof OBJECT|typeof BASIC|typeof MAP|typeof SET;\n\nconst cantAccess = (thing: unknown, key: Key) => new Error(`Cant access property ${String(key)} of ${String(thing)}`);\n\nexport function getType(thing: unknown): DataType {\n    if(thing instanceof Map) return MAP;\n    if(thing instanceof Set) return SET;\n    if(Array.isArray(thing)) return ARRAY;\n    if(thing instanceof Object) return OBJECT;\n    return BASIC;\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function has(thing: any, key: Key): boolean {\n    const type = getType(thing);\n    if(type === OBJECT) {\n        return key in thing;\n    }\n    if(type === ARRAY) {\n        const index = key as number;\n        return index < thing.length && index > -1;\n    }\n    if(type === MAP || type === SET) {\n        return thing.has(key);\n    }\n    throw cantAccess(thing, key);\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function get(thing: any, key: Key): unknown {\n    const type = getType(thing);\n    if(type === BASIC) {\n        throw cantAccess(thing, key);\n    }\n    if(type === MAP) {\n        return thing.get(key);\n    }\n    if(type === SET) {\n        return thing.has(key) ? key : undefined;\n    }\n    return thing[key];\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function getIn(thing: unknown, path: Key[]): unknown {\n    return path.reduce((red, key) => get(red, key), thing);\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function set(thing: any, key: Key, value: unknown): void {\n    const type = getType(thing);\n    if(type === BASIC) {\n        throw cantAccess(thing, key);\n    }\n    if(type === MAP) {\n        return thing.set(key, value);\n    }\n    if(type === SET) {\n        thing.delete(key);\n        thing.add(value);\n        return;\n    }\n    thing[key] = value;\n}\n\nexport type EachCallback = (value: unknown, key: Key) => void;\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function entries(thing: any): [Key,any][] {\n    const type = getType(thing);\n    if(type === OBJECT) return Object.entries(thing);\n    if(type === ARRAY || type === MAP || type === SET) return Array.from(thing.entries());\n    throw cantAccess(thing, 'any');\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function clone(thing: any): any {\n    const type = getType(thing);\n    if(type === OBJECT) return {...thing};\n    if(type === ARRAY) return thing.slice();\n    if(type === MAP) return new Map(thing);\n    if(type === SET) return new Set(thing);\n    return thing;\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any\nexport function create(type: DataType): any {\n    if(type === OBJECT) return {};\n    if(type === ARRAY) return [];\n    if(type === MAP) return new Map();\n    if(type === SET) return new Set();\n    return undefined;\n}\n","import type {DendriformPatch, Path} from './types';\nimport type {Patch as ImmerPatch} from 'immer';\n\nexport const zoomInPatches = <P extends ImmerPatch | DendriformPatch>(path: Path, patches: P[]): P[] => {\n    return patches\n        .filter(patch => path.every((elem, index) => elem === patch.path[index]))\n        .map(patch => {\n            return {\n                ...patch,\n                path: patch.path.slice(path.length)\n            };\n        });\n};\n\nexport const zoomOutPatches = <P extends ImmerPatch | DendriformPatch>(path: Path, patches: P[]): P[] => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return patches.map((patch: any): any => {\n        const newPatch = {\n            ...patch,\n            path: path.concat(patch.path)\n        };\n        if(patch.from) {\n            newPatch.from = path.concat(patch.from);\n        }\n        return newPatch;\n    });\n};\n","import {applyPatches, enablePatches, nothing} from 'immer';\nimport {getIn} from './traverse';\nimport {zoomInPatches, zoomOutPatches} from './zoomPatches';\nimport type {Patch as ImmerPatch} from 'immer';\nimport type {DendriformPatch, Path, Key} from './types';\n\nenablePatches();\n\ntype CheckPathResult = [boolean, string];\n\n//\n// optimise()\n//\n// chunks patches into groups where paths are the same\n// and optimises patches that relates to transformations on an array\n//\n// e.g.\n// value at ['foo','bar'] is an array\n//\n// [\n//   {path: ['foo'], ...}\n//   {path: ['foo'], ...}\n//   {path: ['foo','bar', 0], ...} // optimise this\n//   {path: ['foo','bar', 1], ...} // optimise this\n//   {path: ['foo','bar', 2], ...} // optimise this\n//   {path: ['foo','qux'], ...}\n// ]\n//\n\nexport const optimise = <B,>(base: B, patches: ImmerPatch[]): DendriformPatch[] => {\n\n    let newPatches: DendriformPatch[] = [];\n\n    // check path is array (memoised)\n    let lastResult: CheckPathResult|undefined;\n    const checkPathIsArray = <B,>(base: B, path: Key[]): boolean => {\n        const pathString = JSON.stringify(path);\n        if(lastResult && lastResult[1] === pathString) return lastResult[0];\n        const isArray = Array.isArray(getIn(base, path));\n        lastResult = [isArray, pathString];\n        return isArray;\n    };\n\n    // buffer\n    let currentPath: Path|undefined;\n    let buffer: ImmerPatch[] = [];\n\n    const flush = (): void => {\n        if(buffer.length === 0) return;\n        if(currentPath) {\n            const baseAtPath = getIn(base, currentPath);\n            const patchesAtPath = zoomInPatches<ImmerPatch>(currentPath, buffer);\n            // optimise patches\n            const optimisedPatches = optimiseArray(baseAtPath as unknown[], patchesAtPath);\n            const zoomedOutPatches = zoomOutPatches<DendriformPatch>(currentPath, optimisedPatches);\n            newPatches = newPatches.concat(zoomedOutPatches);\n        } else {\n            newPatches = newPatches.concat(buffer);\n        }\n        buffer = [];\n    };\n\n    // seek\n    patches.forEach(patch => {\n        const {path} = patch;\n        const parentPath = path.slice(0,-1);\n        const thisPath = checkPathIsArray(base, parentPath) ? parentPath : undefined;\n\n        // reset buffer whenever path changes\n        if(JSON.stringify(thisPath) !== JSON.stringify(currentPath)) {\n            flush();\n            currentPath = thisPath;\n        }\n\n        if(patch.value === nothing) {\n            patch = {...patch, value: undefined};\n        }\n        // ^ bug fix until https://github.com/immerjs/immer/issues/791\n\n        buffer.push(patch);\n    });\n\n    flush();\n\n    // output\n\n    return newPatches;\n};\n\n\n//\n// optimiseArray()\n//\n// accepts patches with a common path relating to an array\n// applies them, and optimises the patches required to produce\n// the same result by using 'move' patches\n//\n\nexport const optimiseArray = <B>(base: B[], patches: ImmerPatch[]): DendriformPatch[] => {\n\n    const newPatches: DendriformPatch[] = [];\n\n    // give unique id numbers to all values in base and patches for processing\n    let id = 0;\n    const valueToId = new Map<B, number>();\n    const idToValue = new Map<number, B>();\n\n    const addItem = (value: B): number => {\n        if(valueToId.has(value)) {\n            return valueToId.get(value) as number;\n        }\n        const newId = id++;\n        valueToId.set(value, newId);\n        idToValue.set(newId, value);\n        return newId;\n    };\n\n    // add items from base\n    const baseIds = base.map(addItem);\n    const baseIdSet = new Set(baseIds);\n\n    // add items from patches\n    let targetIds: number[] = [];\n    if(patches.length === 1 && patches[0].path.length === 0) {\n        // this is a top level replace, substitute element ids directly\n        const {value} = patches[0];\n        if(!Array.isArray(value)) return patches;\n        targetIds = value.map(addItem);\n\n    } else if(base.some(b => typeof b !== 'object')) {\n        // if any primitives are in the array, we cant reliably track by reference\n        // so skip the optimisation\n        return patches;\n\n    } else {\n        const replacedPatches = patches.map(patch => {\n            const {op, value, path} = patch;\n\n            if(op === 'remove' // if 'remove', no value exists\n                || (op === 'replace' && path.length === 1 && path[0] === 'length') // this is an array length change\n            ) {\n                return patch;\n            }\n\n            return {\n                ...patch,\n                value: addItem(value)\n            };\n        });\n\n        targetIds = applyPatches(baseIds, replacedPatches) as number[];\n    }\n\n    // ignoring newly added values\n    // look at each id in the target array\n    // and add a 'move' operation that will move each id into the correct position\n\n    const existingTargetIds = targetIds.filter(id => baseIdSet.has(id));\n    const wipIds = baseIds.slice(); // this array can be mutated as the sort progresses\n\n    existingTargetIds.forEach((targetId, index) => {\n        if(targetId !== wipIds[index]) {\n            const fromIndex = wipIds.indexOf(targetId);\n            newPatches.push({op: 'move', from: [fromIndex], path: [index]});\n            wipIds.splice(fromIndex, 1);\n            wipIds.splice(index, 0, targetId);\n        }\n    });\n\n    // after this sorting is done\n    // all the items to be removed will be collected at the end of the array\n    // and can be truncated off\n\n    if(existingTargetIds.length < baseIds.length) {\n        newPatches.push({op: 'replace', path: ['length'], value: existingTargetIds.length});\n    }\n\n    // finally, add new items into result\n\n    targetIds.forEach((id, index) => {\n        if(!baseIdSet.has(id)) {\n            const value = idToValue.get(id);\n            newPatches.push({op: 'add', path: [index], value});\n        }\n    });\n\n    return newPatches;\n};\n","import {applyPatches as immerApplyPatches} from 'immer';\nimport {getIn} from './traverse';\nimport type {Patch as ImmerPatch} from 'immer';\nimport type {DendriformPatch, Path} from './types';\n\nexport const applyPatches = <B,>(base: B, patches: DendriformPatch[]): B => {\n    patches.forEach(patch => {\n        if(patch.op === 'move') {\n            const patchFrom = patch.from as Path;\n            base = immerApplyPatches(base, [\n                {op: 'remove', path: patchFrom},\n                {op: 'add', path: patch.path, value: getIn(base, patchFrom)}\n            ]);\n        } else {\n            base = immerApplyPatches(base, [patch as ImmerPatch]);\n        }\n    });\n    return base;\n};\n"],"names":["cantAccess","thing","key","Error","String","getType","Map","Set","Array","isArray","Object","get","type","has","undefined","getIn","path","reduce","red","zoomInPatches","patches","filter","patch","every","elem","index","map","slice","length","zoomOutPatches","newPatch","concat","from","enablePatches","optimiseArray","base","newPatches","id","valueToId","idToValue","addItem","value","newId","set","baseIds","baseIdSet","targetIds","some","b","replacedPatches","op","applyPatches","existingTargetIds","wipIds","forEach","targetId","fromIndex","indexOf","push","splice","patchFrom","immerApplyPatches","entries","lastResult","currentPath","buffer","flush","baseAtPath","patchesAtPath","optimisedPatches","zoomedOutPatches","parentPath","thisPath","pathString","JSON","stringify","checkPathIsArray","nothing","add"],"mappings":"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"}