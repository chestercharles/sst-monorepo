"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Serializer = void 0;
const enums_1 = require("./enums");
const IDENTIFIER_REGEXP = /^[a-zA-Z_$][a-zA-Z_0-9$]*$/;
/**
 * Creates a TypeScript output string from a codegen AST.
 */
class Serializer {
    constructor(options = {}) {
        this.typeOnlyImports = options.typeOnlyImports ?? true;
    }
    serialize(nodes) {
        let data = '';
        let i = 0;
        for (const node of nodes) {
            if (i >= 1) {
                data += '\n';
                if (node.type !== enums_1.NodeType.IMPORT_STATEMENT) {
                    data += '\n';
                }
            }
            switch (node.type) {
                case enums_1.NodeType.EXPORT_STATEMENT:
                    data += this.serializeExportStatement(node);
                    break;
                case enums_1.NodeType.IMPORT_STATEMENT:
                    data += this.serializeImportStatement(node);
                    break;
            }
            i++;
        }
        data += '\n';
        return data;
    }
    serializeAliasDeclaration(node) {
        const expression = node.body.type === enums_1.NodeType.TEMPLATE ? node.body.expression : node.body;
        let data = '';
        data += 'type ';
        data += node.name;
        if (node.body.type === enums_1.NodeType.TEMPLATE) {
            data += '<';
            for (let i = 0; i < node.body.params.length; i++) {
                if (i >= 1) {
                    data += ', ';
                }
                data += node.body.params[i];
            }
            data += '>';
        }
        data += ' = ';
        data += this.serializeExpression(expression);
        data += ';';
        return data;
    }
    serializeArrayExpression(node) {
        const shouldParenthesize = node.values.type === enums_1.NodeType.UNION_EXPRESSION &&
            node.values.args.length >= 2;
        let data = '';
        if (shouldParenthesize) {
            data += '(';
        }
        data += this.serializeExpression(node.values);
        if (shouldParenthesize) {
            data += ')';
        }
        data += '[]';
        return data;
    }
    serializeExportStatement(node) {
        let data = '';
        data += 'export ';
        switch (node.argument.type) {
            case enums_1.NodeType.ALIAS_DECLARATION:
                data += this.serializeAliasDeclaration(node.argument);
                break;
            case enums_1.NodeType.INTERFACE_DECLARATION:
                data += this.serializeInterfaceDeclaration(node.argument);
                break;
        }
        return data;
    }
    serializeExpression(node) {
        switch (node.type) {
            case enums_1.NodeType.ARRAY_EXPRESSION:
                return this.serializeArrayExpression(node);
            case enums_1.NodeType.EXTENDS_CLAUSE:
                return this.serializeExtendsClause(node);
            case enums_1.NodeType.GENERIC_EXPRESSION:
                return this.serializeGenericExpression(node);
            case enums_1.NodeType.IDENTIFIER:
                return this.serializeIdentifier(node);
            case enums_1.NodeType.INFER_CLAUSE:
                return this.serializeInferClause(node);
            case enums_1.NodeType.LITERAL:
                return this.serializeLiteral(node);
            case enums_1.NodeType.MAPPED_TYPE:
                return this.serializeMappedType(node);
            case enums_1.NodeType.OBJECT_EXPRESSION:
                return this.serializeObjectExpression(node);
            case enums_1.NodeType.UNION_EXPRESSION:
                return this.serializeUnionExpression(node);
        }
    }
    serializeExtendsClause(node) {
        let data = '';
        data += node.name;
        data += ' extends ';
        data += this.serializeExpression(node.test);
        data += '\n  ? ';
        data += this.serializeExpression(node.consequent);
        data += '\n  : ';
        data += this.serializeExpression(node.alternate);
        return data;
    }
    serializeGenericExpression(node) {
        let data = '';
        data += node.name;
        data += '<';
        for (let i = 0; i < node.args.length; i++) {
            if (i >= 1) {
                data += ', ';
            }
            data += this.serializeExpression(node.args[i]);
        }
        data += '>';
        return data;
    }
    serializeIdentifier(node) {
        return node.name;
    }
    serializeImportClause(node) {
        let data = '';
        data += node.name;
        if (node.alias) {
            data += ' as ';
            data += node.alias;
        }
        return data;
    }
    serializeImportStatement(node) {
        let data = '';
        let i = 0;
        data += 'import ';
        if (this.typeOnlyImports) {
            data += 'type ';
        }
        data += '{';
        for (const importClause of node.imports) {
            if (i >= 1) {
                data += ',';
            }
            data += ' ';
            data += this.serializeImportClause(importClause);
            i++;
        }
        data += ' } from ';
        data += JSON.stringify(node.moduleName);
        data += ';';
        return data;
    }
    serializeInferClause(node) {
        let data = '';
        data += 'infer ';
        data += node.name;
        return data;
    }
    serializeInterfaceDeclaration(node) {
        let data = '';
        data += 'interface ';
        data += node.name;
        data += ' ';
        data += this.serializeObjectExpression(node.body);
        return data;
    }
    serializeLiteral(node) {
        return JSON.stringify(node.value);
    }
    serializeKey(key) {
        return IDENTIFIER_REGEXP.test(key) ? key : JSON.stringify(key);
    }
    serializeMappedType(node) {
        let data = '';
        data += '{\n  [K in string]?: ';
        data += this.serializeExpression(node.value);
        data += ';\n}';
        return data;
    }
    serializeObjectExpression(node) {
        let data = '';
        data += '{';
        if (node.properties.length) {
            data += '\n';
            for (const property of node.properties) {
                data += '  ';
                data += this.serializeProperty(property);
            }
        }
        data += '}';
        return data;
    }
    serializeProperty(node) {
        let data = '';
        data += this.serializeKey(node.key);
        data += ': ';
        data += this.serializeExpression(node.value);
        data += ';\n';
        return data;
    }
    serializeUnionExpression(node) {
        let data = '';
        let i = 0;
        for (const arg of node.args) {
            if (i >= 1) {
                data += ' | ';
            }
            data += this.serializeExpression(arg);
            i++;
        }
        return data;
    }
}
exports.Serializer = Serializer;
//# sourceMappingURL=serializer.js.map