"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ConnectionStringParser_instances, _ConnectionStringParser_inferDialectName;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionStringParser = void 0;
const dotenv_1 = require("dotenv");
const CALL_STATEMENT_REGEXP = /^\s*([a-z]+)\s*\(\s*(.*)\s*\)\s*$/;
/**
 * @see https://dev.mysql.com/doc/refman/8.0/en/connecting-using-uri-or-key-value-pairs.html
 */
const MYSQL_URI_CONNECTION_STRING_REGEXP = /^mysqlx?:\/\//;
/**
 * Parses a connection string URL or loads it from an environment file.
 * Upon success, it also returns which dialect was inferred from the connection string.
 */
class ConnectionStringParser {
    constructor() {
        _ConnectionStringParser_instances.add(this);
    }
    parse(options) {
        let connectionString = options.connectionString;
        const expressionMatch = connectionString.match(CALL_STATEMENT_REGEXP);
        if (expressionMatch) {
            const name = expressionMatch[1];
            if (name !== 'env') {
                throw new ReferenceError(`Function '${name}' is not defined.`);
            }
            const keyToken = expressionMatch[2];
            let key;
            try {
                key = keyToken.includes('"') ? JSON.parse(keyToken) : keyToken;
            }
            catch {
                throw new SyntaxError(`Invalid connection string: '${connectionString}'`);
            }
            if (typeof key !== 'string') {
                throw new TypeError(`Parameter 0 of function '${name}' must be a string.`);
            }
            (0, dotenv_1.config)();
            options.logger?.info('Loaded environment variables from .env file.');
            const envConnectionString = process.env[key];
            if (!envConnectionString) {
                throw new ReferenceError(`Environment variable '${key}' could not be found.`);
            }
            connectionString = envConnectionString;
        }
        const inferredDialectName = options.dialectName ?? __classPrivateFieldGet(this, _ConnectionStringParser_instances, "m", _ConnectionStringParser_inferDialectName).call(this, connectionString);
        return {
            connectionString,
            inferredDialectName,
        };
    }
}
exports.ConnectionStringParser = ConnectionStringParser;
_ConnectionStringParser_instances = new WeakSet(), _ConnectionStringParser_inferDialectName = function _ConnectionStringParser_inferDialectName(connectionString) {
    if (connectionString.startsWith('postgres://')) {
        return 'postgres';
    }
    if (MYSQL_URI_CONNECTION_STRING_REGEXP.test(connectionString)) {
        return 'mysql';
    }
    return 'sqlite';
};
//# sourceMappingURL=connection-string-parser.js.map