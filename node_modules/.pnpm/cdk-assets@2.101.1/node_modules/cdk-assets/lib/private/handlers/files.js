"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAssetHandler = void 0;
const fs_1 = require("fs");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const mime = require("mime");
const progress_1 = require("../../progress");
const archive_1 = require("../archive");
const fs_extra_1 = require("../fs-extra");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
/**
 * The size of an empty zip file is 22 bytes
 *
 * Ref: https://en.wikipedia.org/wiki/ZIP_(file_format)
 */
const EMPTY_ZIP_FILE_SIZE = 22;
class FileAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.fileCacheRoot = path.join(workDir, '.cache');
    }
    async build() { }
    async isPublished() {
        const destination = await (0, placeholders_1.replaceAwsPlaceholders)(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        try {
            const s3 = await this.host.aws.s3Client({
                ...destination,
                quiet: true,
            });
            this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
            if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
                this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
                return true;
            }
        }
        catch (e) {
            this.host.emitMessage(progress_1.EventType.DEBUG, `${e.message}`);
        }
        return false;
    }
    async publish() {
        const destination = await (0, placeholders_1.replaceAwsPlaceholders)(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        const s3 = await this.host.aws.s3Client(destination);
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
        const bucketInfo = BucketInformation.for(this.host);
        // A thunk for describing the current account. Used when we need to format an error
        // message, not in the success case.
        const account = async () => (await this.host.aws.discoverTargetAccount(destination))?.accountId;
        switch (await bucketInfo.bucketOwnership(s3, destination.bucketName)) {
            case BucketOwnership.MINE:
                break;
            case BucketOwnership.DOES_NOT_EXIST:
                throw new Error(`No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
            case BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS:
                throw new Error(`Bucket named '${destination.bucketName}' exists, but not in account ${await account()}. Wrong account?`);
        }
        if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
            return;
        }
        // Identify the the bucket encryption type to set the header on upload
        // required for SCP rules denying uploads without encryption header
        let paramsEncryption = {};
        const encryption2 = await bucketInfo.bucketEncryption(s3, destination.bucketName);
        switch (encryption2.type) {
            case 'no_encryption':
                break;
            case 'aes256':
                paramsEncryption = { ServerSideEncryption: 'AES256' };
                break;
            case 'kms':
                // We must include the key ID otherwise S3 will encrypt with the default key
                paramsEncryption = {
                    ServerSideEncryption: 'aws:kms',
                    SSEKMSKeyId: encryption2.kmsKeyId,
                };
                break;
            case 'does_not_exist':
                this.host.emitMessage(progress_1.EventType.DEBUG, `No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
                break;
            case 'access_denied':
                this.host.emitMessage(progress_1.EventType.DEBUG, `Could not read encryption settings of bucket '${destination.bucketName}': uploading with default settings ("cdk bootstrap" to version 9 if your organization's policies prevent a successful upload or to get rid of this message).`);
                break;
        }
        if (this.host.aborted) {
            return;
        }
        const publishFile = this.asset.source.executable ?
            await this.externalPackageFile(this.asset.source.executable) : await this.packageFile(this.asset.source);
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Upload ${s3Url}`);
        const params = Object.assign({}, {
            Bucket: destination.bucketName,
            Key: destination.objectKey,
            Body: (0, fs_1.createReadStream)(publishFile.packagedPath),
            ContentType: publishFile.contentType,
        }, paramsEncryption);
        await s3.upload(params).promise();
    }
    async packageFile(source) {
        if (!source.path) {
            throw new Error(`'path' is expected in the File asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.path);
        if (source.packaging === cloud_assembly_schema_1.FileAssetPackaging.ZIP_DIRECTORY) {
            const contentType = 'application/zip';
            await fs_1.promises.mkdir(this.fileCacheRoot, { recursive: true });
            const packagedPath = path.join(this.fileCacheRoot, `${this.asset.id.assetId}.zip`);
            if (await (0, fs_extra_1.pathExists)(packagedPath)) {
                this.host.emitMessage(progress_1.EventType.CACHED, `From cache ${packagedPath}`);
                return { packagedPath, contentType };
            }
            this.host.emitMessage(progress_1.EventType.BUILD, `Zip ${fullPath} -> ${packagedPath}`);
            await (0, archive_1.zipDirectory)(fullPath, packagedPath, (m) => this.host.emitMessage(progress_1.EventType.DEBUG, m));
            return { packagedPath, contentType };
        }
        else {
            const contentType = mime.getType(fullPath) ?? 'application/octet-stream';
            return { packagedPath: fullPath, contentType };
        }
    }
    async externalPackageFile(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building asset source using command: '${executable}'`);
        return {
            packagedPath: (await (0, shell_1.shell)(executable, { quiet: true })).trim(),
            contentType: 'application/zip',
        };
    }
}
exports.FileAssetHandler = FileAssetHandler;
var BucketOwnership;
(function (BucketOwnership) {
    BucketOwnership[BucketOwnership["DOES_NOT_EXIST"] = 0] = "DOES_NOT_EXIST";
    BucketOwnership[BucketOwnership["MINE"] = 1] = "MINE";
    BucketOwnership[BucketOwnership["SOMEONE_ELSES_OR_NO_ACCESS"] = 2] = "SOMEONE_ELSES_OR_NO_ACCESS";
})(BucketOwnership || (BucketOwnership = {}));
async function objectExists(s3, bucket, key) {
    /*
     * The object existence check here refrains from using the `headObject` operation because this
     * would create a negative cache entry, making GET-after-PUT eventually consistent. This has been
     * observed to result in CloudFormation issuing "ValidationError: S3 error: Access Denied", for
     * example in https://github.com/aws/aws-cdk/issues/6430.
     *
     * To prevent this, we are instead using the listObjectsV2 call, using the looked up key as the
     * prefix, and limiting results to 1. Since the list operation returns keys ordered by binary
     * UTF-8 representation, the key we are looking for is guaranteed to always be the first match
     * returned if it exists.
     *
     * If the file is too small, we discount it as a cache hit. There is an issue
     * somewhere that sometimes produces empty zip files, and we would otherwise
     * never retry building those assets without users having to manually clear
     * their bucket, which is a bad experience.
     */
    const response = await s3.listObjectsV2({ Bucket: bucket, Prefix: key, MaxKeys: 1 }).promise();
    return (response.Contents != null &&
        response.Contents.some((object) => object.Key === key && (object.Size == null || object.Size > EMPTY_ZIP_FILE_SIZE)));
}
/**
 * Cache for bucket information, so we don't have to keep doing the same calls again and again
 *
 * We scope the lifetime of the cache to the lifetime of the host, so that we don't have to do
 * anything special for tests and yet the cache will live for the entire lifetime of the asset
 * upload session when used by the CLI.
 */
class BucketInformation {
    static for(host) {
        const existing = BucketInformation.caches.get(host);
        if (existing) {
            return existing;
        }
        const fresh = new BucketInformation();
        BucketInformation.caches.set(host, fresh);
        return fresh;
    }
    constructor() {
        this.ownerships = new Map();
        this.encryptions = new Map();
    }
    async bucketOwnership(s3, bucket) {
        return cached(this.ownerships, bucket, () => this._bucketOwnership(s3, bucket));
    }
    async bucketEncryption(s3, bucket) {
        return cached(this.encryptions, bucket, () => this._bucketEncryption(s3, bucket));
    }
    async _bucketOwnership(s3, bucket) {
        try {
            await s3.getBucketLocation({ Bucket: bucket }).promise();
            return BucketOwnership.MINE;
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return BucketOwnership.DOES_NOT_EXIST;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS;
            }
            throw e;
        }
    }
    async _bucketEncryption(s3, bucket) {
        try {
            const encryption = await s3.getBucketEncryption({ Bucket: bucket }).promise();
            const l = encryption?.ServerSideEncryptionConfiguration?.Rules?.length ?? 0;
            if (l > 0) {
                const apply = encryption?.ServerSideEncryptionConfiguration?.Rules[0]?.ApplyServerSideEncryptionByDefault;
                let ssealgo = apply?.SSEAlgorithm;
                if (ssealgo === 'AES256')
                    return { type: 'aes256' };
                if (ssealgo === 'aws:kms')
                    return { type: 'kms', kmsKeyId: apply?.KMSMasterKeyID };
            }
            return { type: 'no_encryption' };
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return { type: 'does_not_exist' };
            }
            if (e.code === 'ServerSideEncryptionConfigurationNotFoundError') {
                return { type: 'no_encryption' };
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return { type: 'access_denied' };
            }
            return { type: 'no_encryption' };
        }
    }
}
BucketInformation.caches = new WeakMap();
async function cached(cache, key, factory) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    const fresh = await factory(key);
    cache.set(key, fresh);
    return fresh;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQkFBc0Q7QUFDdEQsNkJBQTZCO0FBQzdCLDBFQUFnRjtBQUNoRiw2QkFBNkI7QUFFN0IsNkNBQTJDO0FBQzNDLHdDQUEwQztBQUUxQywwQ0FBeUM7QUFDekMsa0RBQXlEO0FBQ3pELG9DQUFpQztBQUVqQzs7OztHQUlHO0FBQ0gsTUFBTSxtQkFBbUIsR0FBRyxFQUFFLENBQUM7QUFFL0IsTUFBYSxnQkFBZ0I7SUFHM0IsWUFDbUIsT0FBZSxFQUNmLEtBQXdCLEVBQ3hCLElBQWtCO1FBRmxCLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFDZixVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQUN4QixTQUFJLEdBQUosSUFBSSxDQUFjO1FBQ25DLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVNLEtBQUssQ0FBQyxLQUFLLEtBQW1CLENBQUM7SUFFL0IsS0FBSyxDQUFDLFdBQVc7UUFDdEIsTUFBTSxXQUFXLEdBQUcsTUFBTSxJQUFBLHFDQUFzQixFQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEYsTUFBTSxLQUFLLEdBQUcsUUFBUSxXQUFXLENBQUMsVUFBVSxJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUN4RSxJQUFJO1lBQ0YsTUFBTSxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUM7Z0JBQ3RDLEdBQUcsV0FBVztnQkFDZCxLQUFLLEVBQUUsSUFBSTthQUNaLENBQUMsQ0FBQztZQUNILElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsS0FB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QixPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZWFkU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBGaWxlQXNzZXRQYWNrYWdpbmcsIEZpbGVTb3VyY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgbWltZSBmcm9tICdtaW1lJztcbmltcG9ydCB7IEZpbGVNYW5pZmVzdEVudHJ5IH0gZnJvbSAnLi4vLi4vYXNzZXQtbWFuaWZlc3QnO1xuaW1wb3J0IHsgRXZlbnRUeXBlIH0gZnJvbSAnLi4vLi4vcHJvZ3Jlc3MnO1xuaW1wb3J0IHsgemlwRGlyZWN0b3J5IH0gZnJvbSAnLi4vYXJjaGl2ZSc7XG5pbXBvcnQgeyBJQXNzZXRIYW5kbGVyLCBJSGFuZGxlckhvc3QgfSBmcm9tICcuLi9hc3NldC1oYW5kbGVyJztcbmltcG9ydCB7IHBhdGhFeGlzdHMgfSBmcm9tICcuLi9mcy1leHRyYSc7XG5pbXBvcnQgeyByZXBsYWNlQXdzUGxhY2Vob2xkZXJzIH0gZnJvbSAnLi4vcGxhY2Vob2xkZXJzJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi4vc2hlbGwnO1xuXG4vKipcbiAqIFRoZSBzaXplIG9mIGFuIGVtcHR5IHppcCBmaWxlIGlzIDIyIGJ5dGVzXG4gKlxuICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9aSVBfKGZpbGVfZm9ybWF0KVxuICovXG5jb25zdCBFTVBUWV9aSVBfRklMRV9TSVpFID0gMjI7XG5cbmV4cG9ydCBjbGFzcyBGaWxlQXNzZXRIYW5kbGVyIGltcGxlbWVudHMgSUFzc2V0SGFuZGxlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZmlsZUNhY2hlUm9vdDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgd29ya0Rpcjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXNzZXQ6IEZpbGVNYW5pZmVzdEVudHJ5LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaG9zdDogSUhhbmRsZXJIb3N0KSB7XG4gICAgdGhpcy5maWxlQ2FjaGVSb290ID0gcGF0aC5qb2luKHdvcmtEaXIsICcuY2FjaGUnKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidWlsZCgpOiBQcm9taXNlPHZvaWQ+IHt9XG5cbiAgcHVibGljIGFzeW5jIGlzUHVibGlzaGVkKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gYXdhaXQgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyh0aGlzLmFzc2V0LmRlc3RpbmF0aW9uLCB0aGlzLmhvc3QuYXdzKTtcbiAgICBjb25zdCBzM1VybCA9IGBzMzovLyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0vJHtkZXN0aW5hdGlvbi5vYmplY3RLZXl9YDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgczMgPSBhd2FpdCB0aGlzLmhvc3QuYXdzLnMzQ2xpZW50KHtcbiAgICAgICAgLi4uZGVzdGluYXRpb24sXG4gICAgICAgIHF1aWV0OiB0cnVlLFxuICAgICAgfSk7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNIRUNLLCBgQ2hlY2sgJHtzM1VybH1gKTtcblxuICAgICAgaWYgKGF3YWl0IG9iamVjdEV4aXN0cyhzMywgZGVzdGluYXRpb24uYnVja2V0TmFtZSwgZGVzdGluYXRpb24ub2JqZWN0S2V5KSkge1xuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkZPVU5ELCBgRm91bmQgJHtzM1VybH1gKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBgJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwdWJsaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gYXdhaXQgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyh0aGlzLmFzc2V0LmRlc3RpbmF0aW9uLCB0aGlzLmhvc3QuYXdzKTtcbiAgICBjb25zdCBzM1VybCA9IGBzMzovLyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0vJHtkZXN0aW5hdGlvbi5vYmplY3RLZXl9YDtcbiAgICBjb25zdCBzMyA9IGF3YWl0IHRoaXMuaG9zdC5hd3MuczNDbGllbnQoZGVzdGluYXRpb24pO1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0hFQ0ssIGBDaGVjayAke3MzVXJsfWApO1xuXG4gICAgY29uc3QgYnVja2V0SW5mbyA9IEJ1Y2tldEluZm9ybWF0aW9uLmZvcih0aGlzLmhvc3QpO1xuXG4gICAgLy8gQSB0aHVuayBmb3IgZGVzY3JpYmluZyB0aGUgY3VycmVudCBhY2NvdW50LiBVc2VkIHdoZW4gd2UgbmVlZCB0byBmb3JtYXQgYW4gZXJyb3JcbiAgICAvLyBtZXNzYWdlLCBub3QgaW4gdGhlIHN1Y2Nlc3MgY2FzZS5cbiAgICBjb25zdCBhY2NvdW50ID0gYXN5bmMgKCkgPT4gKGF3YWl0IHRoaXMuaG9zdC5hd3MuZGlzY292ZXJUYXJnZXRBY2NvdW50KGRlc3RpbmF0aW9uKSk/LmFjY291bnRJZDtcbiAgICBzd2l0Y2ggKGF3YWl0IGJ1Y2tldEluZm8uYnVja2V0T3duZXJzaGlwKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKSkge1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuTUlORTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5ET0VTX05PVF9FWElTVDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBidWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nLiBJcyBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfSBib290c3RyYXBwZWQ/YCk7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5TT01FT05FX0VMU0VTX09SX05PX0FDQ0VTUzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nIGV4aXN0cywgYnV0IG5vdCBpbiBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfS4gV3JvbmcgYWNjb3VudD9gKTtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgb2JqZWN0RXhpc3RzKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lLCBkZXN0aW5hdGlvbi5vYmplY3RLZXkpKSB7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkZPVU5ELCBgRm91bmQgJHtzM1VybH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmeSB0aGUgdGhlIGJ1Y2tldCBlbmNyeXB0aW9uIHR5cGUgdG8gc2V0IHRoZSBoZWFkZXIgb24gdXBsb2FkXG4gICAgLy8gcmVxdWlyZWQgZm9yIFNDUCBydWxlcyBkZW55aW5nIHVwbG9hZHMgd2l0aG91dCBlbmNyeXB0aW9uIGhlYWRlclxuICAgIGxldCBwYXJhbXNFbmNyeXB0aW9uOiB7W2luZGV4OiBzdHJpbmddOmFueX09IHt9O1xuICAgIGNvbnN0IGVuY3J5cHRpb24yID0gYXdhaXQgYnVja2V0SW5mby5idWNrZXRFbmNyeXB0aW9uKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKTtcbiAgICBzd2l0Y2ggKGVuY3J5cHRpb24yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25vX2VuY3J5cHRpb24nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FlczI1Nic6XG4gICAgICAgIHBhcmFtc0VuY3J5cHRpb24gPSB7IFNlcnZlclNpZGVFbmNyeXB0aW9uOiAnQUVTMjU2JyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ttcyc6XG4gICAgICAgIC8vIFdlIG11c3QgaW5jbHVkZSB0aGUga2V5IElEIG90aGVyd2lzZSBTMyB3aWxsIGVuY3J5cHQgd2l0aCB0aGUgZGVmYXVsdCBrZXlcbiAgICAgICAgcGFyYW1zRW5jcnlwdGlvbiA9IHtcbiAgICAgICAgICBTZXJ2ZXJTaWRlRW5jcnlwdGlvbjogJ2F3czprbXMnLFxuICAgICAgICAgIFNTRUtNU0tleUlkOiBlbmNyeXB0aW9uMi5rbXNLZXlJZCxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb2VzX25vdF9leGlzdCc6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuREVCVUcsIGBObyBidWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nLiBJcyBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfSBib290c3RyYXBwZWQ/YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYWNjZXNzX2RlbmllZCc6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuREVCVUcsIGBDb3VsZCBub3QgcmVhZCBlbmNyeXB0aW9uIHNldHRpbmdzIG9mIGJ1Y2tldCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfSc6IHVwbG9hZGluZyB3aXRoIGRlZmF1bHQgc2V0dGluZ3MgKFwiY2RrIGJvb3RzdHJhcFwiIHRvIHZlcnNpb24gOSBpZiB5b3VyIG9yZ2FuaXphdGlvbidzIHBvbGljaWVzIHByZXZlbnQgYSBzdWNjZXNzZnVsIHVwbG9hZCBvciB0byBnZXQgcmlkIG9mIHRoaXMgbWVzc2FnZSkuYCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkgeyByZXR1cm47IH1cbiAgICBjb25zdCBwdWJsaXNoRmlsZSA9IHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUgP1xuICAgICAgYXdhaXQgdGhpcy5leHRlcm5hbFBhY2thZ2VGaWxlKHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUpIDogYXdhaXQgdGhpcy5wYWNrYWdlRmlsZSh0aGlzLmFzc2V0LnNvdXJjZSk7XG5cbiAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLlVQTE9BRCwgYFVwbG9hZCAke3MzVXJsfWApO1xuXG4gICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgQnVja2V0OiBkZXN0aW5hdGlvbi5idWNrZXROYW1lLFxuICAgICAgS2V5OiBkZXN0aW5hdGlvbi5vYmplY3RLZXksXG4gICAgICBCb2R5OiBjcmVhdGVSZWFkU3RyZWFtKHB1Ymxpc2hGaWxlLnBhY2thZ2VkUGF0aCksXG4gICAgICBDb250ZW50VHlwZTogcHVibGlzaEZpbGUuY29udGVudFR5cGUsXG4gICAgfSxcbiAgICBwYXJhbXNFbmNyeXB0aW9uKTtcblxuICAgIGF3YWl0IHMzLnVwbG9hZChwYXJhbXMpLnByb21pc2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcGFja2FnZUZpbGUoc291cmNlOiBGaWxlU291cmNlKTogUHJvbWlzZTxQYWNrYWdlZEZpbGVBc3NldD4ge1xuICAgIGlmICghc291cmNlLnBhdGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJ3BhdGgnIGlzIGV4cGVjdGVkIGluIHRoZSBGaWxlIGFzc2V0IHNvdXJjZSwgZ290OiAke0pTT04uc3RyaW5naWZ5KHNvdXJjZSl9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZnVsbFBhdGggPSBwYXRoLnJlc29sdmUodGhpcy53b3JrRGlyLCBzb3VyY2UucGF0aCk7XG5cbiAgICBpZiAoc291cmNlLnBhY2thZ2luZyA9PT0gRmlsZUFzc2V0UGFja2FnaW5nLlpJUF9ESVJFQ1RPUlkpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gJ2FwcGxpY2F0aW9uL3ppcCc7XG5cbiAgICAgIGF3YWl0IGZzLm1rZGlyKHRoaXMuZmlsZUNhY2hlUm9vdCwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICBjb25zdCBwYWNrYWdlZFBhdGggPSBwYXRoLmpvaW4odGhpcy5maWxlQ2FjaGVSb290LCBgJHt0aGlzLmFzc2V0LmlkLmFzc2V0SWR9LnppcGApO1xuXG4gICAgICBpZiAoYXdhaXQgcGF0aEV4aXN0cyhwYWNrYWdlZFBhdGgpKSB7XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0FDSEVELCBgRnJvbSBjYWNoZSAke3BhY2thZ2VkUGF0aH1gKTtcbiAgICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoLCBjb250ZW50VHlwZSB9O1xuICAgICAgfVxuXG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkJVSUxELCBgWmlwICR7ZnVsbFBhdGh9IC0+ICR7cGFja2FnZWRQYXRofWApO1xuICAgICAgYXdhaXQgemlwRGlyZWN0b3J5KGZ1bGxQYXRoLCBwYWNrYWdlZFBhdGgsIChtKSA9PiB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkRFQlVHLCBtKSk7XG4gICAgICByZXR1cm4geyBwYWNrYWdlZFBhdGgsIGNvbnRlbnRUeXBlIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRUeXBlID0gbWltZS5nZXRUeXBlKGZ1bGxQYXRoKSA/PyAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcbiAgICAgIHJldHVybiB7IHBhY2thZ2VkUGF0aDogZnVsbFBhdGgsIGNvbnRlbnRUeXBlIH07XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBleHRlcm5hbFBhY2thZ2VGaWxlKGV4ZWN1dGFibGU6IHN0cmluZ1tdKTogUHJvbWlzZTxQYWNrYWdlZEZpbGVBc3NldD4ge1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQlVJTEQsIGBCdWlsZGluZyBhc3NldCBzb3VyY2UgdXNpbmcgY29tbWFuZDogJyR7ZXhlY3V0YWJsZX0nYCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFja2FnZWRQYXRoOiAoYXdhaXQgc2hlbGwoZXhlY3V0YWJsZSwgeyBxdWlldDogdHJ1ZSB9KSkudHJpbSgpLFxuICAgICAgY29udGVudFR5cGU6ICdhcHBsaWNhdGlvbi96aXAnLFxuICAgIH07XG4gIH1cbn1cblxuZW51bSBCdWNrZXRPd25lcnNoaXAge1xuICBET0VTX05PVF9FWElTVCxcbiAgTUlORSxcbiAgU09NRU9ORV9FTFNFU19PUl9OT19BQ0NFU1Ncbn1cblxudHlwZSBCdWNrZXRFbmNyeXB0aW9uID1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdub19lbmNyeXB0aW9uJyB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAnYWVzMjU2JyB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAna21zJzsgcmVhZG9ubHkga21zS2V5SWQ/OiBzdHJpbmcgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2FjY2Vzc19kZW5pZWQnIH1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdkb2VzX25vdF9leGlzdCcgfVxuICA7XG5cbmFzeW5jIGZ1bmN0aW9uIG9iamVjdEV4aXN0cyhzMzogQVdTLlMzLCBidWNrZXQ6IHN0cmluZywga2V5OiBzdHJpbmcpIHtcbiAgLypcbiAgICogVGhlIG9iamVjdCBleGlzdGVuY2UgY2hlY2sgaGVyZSByZWZyYWlucyBmcm9tIHVzaW5nIHRoZSBgaGVhZE9iamVjdGAgb3BlcmF0aW9uIGJlY2F1c2UgdGhpc1xuICAgKiB3b3VsZCBjcmVhdGUgYSBuZWdhdGl2ZSBjYWNoZSBlbnRyeSwgbWFraW5nIEdFVC1hZnRlci1QVVQgZXZlbnR1YWxseSBjb25zaXN0ZW50LiBUaGlzIGhhcyBiZWVuXG4gICAqIG9ic2VydmVkIHRvIHJlc3VsdCBpbiBDbG91ZEZvcm1hdGlvbiBpc3N1aW5nIFwiVmFsaWRhdGlvbkVycm9yOiBTMyBlcnJvcjogQWNjZXNzIERlbmllZFwiLCBmb3JcbiAgICogZXhhbXBsZSBpbiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzY0MzAuXG4gICAqXG4gICAqIFRvIHByZXZlbnQgdGhpcywgd2UgYXJlIGluc3RlYWQgdXNpbmcgdGhlIGxpc3RPYmplY3RzVjIgY2FsbCwgdXNpbmcgdGhlIGxvb2tlZCB1cCBrZXkgYXMgdGhlXG4gICAqIHByZWZpeCwgYW5kIGxpbWl0aW5nIHJlc3VsdHMgdG8gMS4gU2luY2UgdGhlIGxpc3Qgb3BlcmF0aW9uIHJldHVybnMga2V5cyBvcmRlcmVkIGJ5IGJpbmFyeVxuICAgKiBVVEYtOCByZXByZXNlbnRhdGlvbiwgdGhlIGtleSB3ZSBhcmUgbG9va2luZyBmb3IgaXMgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgdGhlIGZpcnN0IG1hdGNoXG4gICAqIHJldHVybmVkIGlmIGl0IGV4aXN0cy5cbiAgICpcbiAgICogSWYgdGhlIGZpbGUgaXMgdG9vIHNtYWxsLCB3ZSBkaXNjb3VudCBpdCBhcyBhIGNhY2hlIGhpdC4gVGhlcmUgaXMgYW4gaXNzdWVcbiAgICogc29tZXdoZXJlIHRoYXQgc29tZXRpbWVzIHByb2R1Y2VzIGVtcHR5IHppcCBmaWxlcywgYW5kIHdlIHdvdWxkIG90aGVyd2lzZVxuICAgKiBuZXZlciByZXRyeSBidWlsZGluZyB0aG9zZSBhc3NldHMgd2l0aG91dCB1c2VycyBoYXZpbmcgdG8gbWFudWFsbHkgY2xlYXJcbiAgICogdGhlaXIgYnVja2V0LCB3aGljaCBpcyBhIGJhZCBleHBlcmllbmNlLlxuICAgKi9cbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBzMy5saXN0T2JqZWN0c1YyKHsgQnVja2V0OiBidWNrZXQsIFByZWZpeDoga2V5LCBNYXhLZXlzOiAxIH0pLnByb21pc2UoKTtcbiAgcmV0dXJuIChcbiAgICByZXNwb25zZS5Db250ZW50cyAhPSBudWxsICYmXG4gICAgcmVzcG9uc2UuQ29udGVudHMuc29tZShcbiAgICAgIChvYmplY3QpID0+IG9iamVjdC5LZXkgPT09IGtleSAmJiAob2JqZWN0LlNpemUgPT0gbnVsbCB8fCBvYmplY3QuU2l6ZSA+IEVNUFRZX1pJUF9GSUxFX1NJWkUpLFxuICAgIClcbiAgKTtcbn1cblxuLyoqXG4gKiBBIHBhY2thZ2VkIGFzc2V0IHdoaWNoIGNhbiBiZSB1cGxvYWRlZCAoZWl0aGVyIGEgc2luZ2xlIGZpbGUgb3IgZGlyZWN0b3J5KVxuICovXG5pbnRlcmZhY2UgUGFja2FnZWRGaWxlQXNzZXQge1xuICAvKipcbiAgICogUGF0aCBvZiB0aGUgZmlsZSBvciBkaXJlY3RvcnlcbiAgICovXG4gIHJlYWRvbmx5IHBhY2thZ2VkUGF0aDogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBDb250ZW50IHR5cGUgdG8gYmUgYWRkZWQgaW4gdGhlIFMzIHVwbG9hZCBhY3Rpb25cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBjb250ZW50IHR5cGVcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRlbnRUeXBlPzogc3RyaW5nO1xufVxuXG4vKipcbiAqIENhY2hlIGZvciBidWNrZXQgaW5mb3JtYXRpb24sIHNvIHdlIGRvbid0IGhhdmUgdG8ga2VlcCBkb2luZyB0aGUgc2FtZSBjYWxscyBhZ2FpbiBhbmQgYWdhaW5cbiAqXG4gKiBXZSBzY29wZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGNhY2hlIHRvIHRoZSBsaWZldGltZSBvZiB0aGUgaG9zdCwgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGRvXG4gKiBhbnl0aGluZyBzcGVjaWFsIGZvciB0ZXN0cyBhbmQgeWV0IHRoZSBjYWNoZSB3aWxsIGxpdmUgZm9yIHRoZSBlbnRpcmUgbGlmZXRpbWUgb2YgdGhlIGFzc2V0XG4gKiB1cGxvYWQgc2Vzc2lvbiB3aGVuIHVzZWQgYnkgdGhlIENMSS5cbiAqL1xuY2xhc3MgQnVja2V0SW5mb3JtYXRpb24ge1xuICBwdWJsaWMgc3RhdGljIGZvcihob3N0OiBJSGFuZGxlckhvc3QpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IEJ1Y2tldEluZm9ybWF0aW9uLmNhY2hlcy5nZXQoaG9zdCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7IHJldHVybiBleGlzdGluZzsgfVxuXG4gICAgY29uc3QgZnJlc2ggPSBuZXcgQnVja2V0SW5mb3JtYXRpb24oKTtcbiAgICBCdWNrZXRJbmZvcm1hdGlvbi5jYWNoZXMuc2V0KGhvc3QsIGZyZXNoKTtcbiAgICByZXR1cm4gZnJlc2g7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBjYWNoZXMgPSBuZXcgV2Vha01hcDxJSGFuZGxlckhvc3QsIEJ1Y2tldEluZm9ybWF0aW9uPigpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgb3duZXJzaGlwcyA9IG5ldyBNYXA8c3RyaW5nLCBCdWNrZXRPd25lcnNoaXA+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jcnlwdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgQnVja2V0RW5jcnlwdGlvbj4oKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1Y2tldE93bmVyc2hpcChzMzogQVdTLlMzLCBidWNrZXQ6IHN0cmluZyk6IFByb21pc2U8QnVja2V0T3duZXJzaGlwPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLm93bmVyc2hpcHMsIGJ1Y2tldCwgKCkgPT4gdGhpcy5fYnVja2V0T3duZXJzaGlwKHMzLCBidWNrZXQpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidWNrZXRFbmNyeXB0aW9uKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRFbmNyeXB0aW9uPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLmVuY3J5cHRpb25zLCBidWNrZXQsICgpID0+IHRoaXMuX2J1Y2tldEVuY3J5cHRpb24oczMsIGJ1Y2tldCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYnVja2V0T3duZXJzaGlwKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRPd25lcnNoaXA+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgczMuZ2V0QnVja2V0TG9jYXRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KS5wcm9taXNlKCk7XG4gICAgICByZXR1cm4gQnVja2V0T3duZXJzaGlwLk1JTkU7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnTm9TdWNoQnVja2V0JykgeyByZXR1cm4gQnVja2V0T3duZXJzaGlwLkRPRVNfTk9UX0VYSVNUOyB9XG4gICAgICBpZiAoWydBY2Nlc3NEZW5pZWQnLCAnQWxsQWNjZXNzRGlzYWJsZWQnXS5pbmNsdWRlcyhlLmNvZGUpKSB7IHJldHVybiBCdWNrZXRPd25lcnNoaXAuU09NRU9ORV9FTFNFU19PUl9OT19BQ0NFU1M7IH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYnVja2V0RW5jcnlwdGlvbihzMzogQVdTLlMzLCBidWNrZXQ6IHN0cmluZyk6IFByb21pc2U8QnVja2V0RW5jcnlwdGlvbj4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlbmNyeXB0aW9uID0gYXdhaXQgczMuZ2V0QnVja2V0RW5jcnlwdGlvbih7IEJ1Y2tldDogYnVja2V0IH0pLnByb21pc2UoKTtcbiAgICAgIGNvbnN0IGwgPSBlbmNyeXB0aW9uPy5TZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb24/LlJ1bGVzPy5sZW5ndGggPz8gMDtcbiAgICAgIGlmIChsID4gMCkge1xuICAgICAgICBjb25zdCBhcHBseSA9IGVuY3J5cHRpb24/LlNlcnZlclNpZGVFbmNyeXB0aW9uQ29uZmlndXJhdGlvbj8uUnVsZXNbMF0/LkFwcGx5U2VydmVyU2lkZUVuY3J5cHRpb25CeURlZmF1bHQ7XG4gICAgICAgIGxldCBzc2VhbGdvID0gYXBwbHk/LlNTRUFsZ29yaXRobTtcbiAgICAgICAgaWYgKHNzZWFsZ28gPT09ICdBRVMyNTYnKSByZXR1cm4geyB0eXBlOiAnYWVzMjU2JyB9O1xuICAgICAgICBpZiAoc3NlYWxnbyA9PT0gJ2F3czprbXMnKSByZXR1cm4geyB0eXBlOiAna21zJywga21zS2V5SWQ6IGFwcGx5Py5LTVNNYXN0ZXJLZXlJRCB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdHlwZTogJ25vX2VuY3J5cHRpb24nIH07XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnTm9TdWNoQnVja2V0Jykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnZG9lc19ub3RfZXhpc3QnIH07XG4gICAgICB9XG4gICAgICBpZiAoZS5jb2RlID09PSAnU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uTm90Rm91bmRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ25vX2VuY3J5cHRpb24nIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChbJ0FjY2Vzc0RlbmllZCcsICdBbGxBY2Nlc3NEaXNhYmxlZCddLmluY2x1ZGVzKGUuY29kZSkpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogJ2FjY2Vzc19kZW5pZWQnIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyB0eXBlOiAnbm9fZW5jcnlwdGlvbicgfTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY2FjaGVkPEEsIEI+KGNhY2hlOiBNYXA8QSwgQj4sIGtleTogQSwgZmFjdG9yeTogKHg6IEEpID0+IFByb21pc2U8Qj4pOiBQcm9taXNlPEI+IHtcbiAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgcmV0dXJuIGNhY2hlLmdldChrZXkpITtcbiAgfVxuXG4gIGNvbnN0IGZyZXNoID0gYXdhaXQgZmFjdG9yeShrZXkpO1xuICBjYWNoZS5zZXQoa2V5LCBmcmVzaCk7XG4gIHJldHVybiBmcmVzaDtcbn1cbiJdfQ==