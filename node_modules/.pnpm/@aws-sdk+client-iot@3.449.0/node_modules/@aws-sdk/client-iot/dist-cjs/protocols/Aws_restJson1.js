"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.se_DeleteBillingGroupCommand = exports.se_DeleteAuthorizerCommand = exports.se_DeleteAuditSuppressionCommand = exports.se_DeleteAccountAuditConfigurationCommand = exports.se_CreateTopicRuleDestinationCommand = exports.se_CreateTopicRuleCommand = exports.se_CreateThingTypeCommand = exports.se_CreateThingGroupCommand = exports.se_CreateThingCommand = exports.se_CreateStreamCommand = exports.se_CreateSecurityProfileCommand = exports.se_CreateScheduledAuditCommand = exports.se_CreateRoleAliasCommand = exports.se_CreateProvisioningTemplateVersionCommand = exports.se_CreateProvisioningTemplateCommand = exports.se_CreateProvisioningClaimCommand = exports.se_CreatePolicyVersionCommand = exports.se_CreatePolicyCommand = exports.se_CreatePackageVersionCommand = exports.se_CreatePackageCommand = exports.se_CreateOTAUpdateCommand = exports.se_CreateMitigationActionCommand = exports.se_CreateKeysAndCertificateCommand = exports.se_CreateJobTemplateCommand = exports.se_CreateJobCommand = exports.se_CreateFleetMetricCommand = exports.se_CreateDynamicThingGroupCommand = exports.se_CreateDomainConfigurationCommand = exports.se_CreateDimensionCommand = exports.se_CreateCustomMetricCommand = exports.se_CreateCertificateFromCsrCommand = exports.se_CreateBillingGroupCommand = exports.se_CreateAuthorizerCommand = exports.se_CreateAuditSuppressionCommand = exports.se_ConfirmTopicRuleDestinationCommand = exports.se_ClearDefaultAuthorizerCommand = exports.se_CancelJobExecutionCommand = exports.se_CancelJobCommand = exports.se_CancelDetectMitigationActionsTaskCommand = exports.se_CancelCertificateTransferCommand = exports.se_CancelAuditTaskCommand = exports.se_CancelAuditMitigationActionsTaskCommand = exports.se_AttachThingPrincipalCommand = exports.se_AttachSecurityProfileCommand = exports.se_AttachPrincipalPolicyCommand = exports.se_AttachPolicyCommand = exports.se_AssociateTargetsWithJobCommand = exports.se_AddThingToThingGroupCommand = exports.se_AddThingToBillingGroupCommand = exports.se_AcceptCertificateTransferCommand = void 0;
exports.se_DescribeJobExecutionCommand = exports.se_DescribeJobCommand = exports.se_DescribeIndexCommand = exports.se_DescribeFleetMetricCommand = exports.se_DescribeEventConfigurationsCommand = exports.se_DescribeEndpointCommand = exports.se_DescribeDomainConfigurationCommand = exports.se_DescribeDimensionCommand = exports.se_DescribeDetectMitigationActionsTaskCommand = exports.se_DescribeDefaultAuthorizerCommand = exports.se_DescribeCustomMetricCommand = exports.se_DescribeCertificateCommand = exports.se_DescribeCACertificateCommand = exports.se_DescribeBillingGroupCommand = exports.se_DescribeAuthorizerCommand = exports.se_DescribeAuditTaskCommand = exports.se_DescribeAuditSuppressionCommand = exports.se_DescribeAuditMitigationActionsTaskCommand = exports.se_DescribeAuditFindingCommand = exports.se_DescribeAccountAuditConfigurationCommand = exports.se_DeprecateThingTypeCommand = exports.se_DeleteV2LoggingLevelCommand = exports.se_DeleteTopicRuleDestinationCommand = exports.se_DeleteTopicRuleCommand = exports.se_DeleteThingTypeCommand = exports.se_DeleteThingGroupCommand = exports.se_DeleteThingCommand = exports.se_DeleteStreamCommand = exports.se_DeleteSecurityProfileCommand = exports.se_DeleteScheduledAuditCommand = exports.se_DeleteRoleAliasCommand = exports.se_DeleteRegistrationCodeCommand = exports.se_DeleteProvisioningTemplateVersionCommand = exports.se_DeleteProvisioningTemplateCommand = exports.se_DeletePolicyVersionCommand = exports.se_DeletePolicyCommand = exports.se_DeletePackageVersionCommand = exports.se_DeletePackageCommand = exports.se_DeleteOTAUpdateCommand = exports.se_DeleteMitigationActionCommand = exports.se_DeleteJobTemplateCommand = exports.se_DeleteJobExecutionCommand = exports.se_DeleteJobCommand = exports.se_DeleteFleetMetricCommand = exports.se_DeleteDynamicThingGroupCommand = exports.se_DeleteDomainConfigurationCommand = exports.se_DeleteDimensionCommand = exports.se_DeleteCustomMetricCommand = exports.se_DeleteCertificateCommand = exports.se_DeleteCACertificateCommand = void 0;
exports.se_ListCertificatesByCACommand = exports.se_ListCertificatesCommand = exports.se_ListCACertificatesCommand = exports.se_ListBillingGroupsCommand = exports.se_ListAuthorizersCommand = exports.se_ListAuditTasksCommand = exports.se_ListAuditSuppressionsCommand = exports.se_ListAuditMitigationActionsTasksCommand = exports.se_ListAuditMitigationActionsExecutionsCommand = exports.se_ListAuditFindingsCommand = exports.se_ListAttachedPoliciesCommand = exports.se_ListActiveViolationsCommand = exports.se_GetV2LoggingOptionsCommand = exports.se_GetTopicRuleDestinationCommand = exports.se_GetTopicRuleCommand = exports.se_GetStatisticsCommand = exports.se_GetRegistrationCodeCommand = exports.se_GetPolicyVersionCommand = exports.se_GetPolicyCommand = exports.se_GetPercentilesCommand = exports.se_GetPackageVersionCommand = exports.se_GetPackageConfigurationCommand = exports.se_GetPackageCommand = exports.se_GetOTAUpdateCommand = exports.se_GetLoggingOptionsCommand = exports.se_GetJobDocumentCommand = exports.se_GetIndexingConfigurationCommand = exports.se_GetEffectivePoliciesCommand = exports.se_GetCardinalityCommand = exports.se_GetBucketsAggregationCommand = exports.se_GetBehaviorModelTrainingSummariesCommand = exports.se_EnableTopicRuleCommand = exports.se_DisableTopicRuleCommand = exports.se_DetachThingPrincipalCommand = exports.se_DetachSecurityProfileCommand = exports.se_DetachPrincipalPolicyCommand = exports.se_DetachPolicyCommand = exports.se_DescribeThingTypeCommand = exports.se_DescribeThingRegistrationTaskCommand = exports.se_DescribeThingGroupCommand = exports.se_DescribeThingCommand = exports.se_DescribeStreamCommand = exports.se_DescribeSecurityProfileCommand = exports.se_DescribeScheduledAuditCommand = exports.se_DescribeRoleAliasCommand = exports.se_DescribeProvisioningTemplateVersionCommand = exports.se_DescribeProvisioningTemplateCommand = exports.se_DescribeMitigationActionCommand = exports.se_DescribeManagedJobTemplateCommand = exports.se_DescribeJobTemplateCommand = void 0;
exports.se_RegisterCertificateCommand = exports.se_RegisterCACertificateCommand = exports.se_PutVerificationStateOnViolationCommand = exports.se_ListViolationEventsCommand = exports.se_ListV2LoggingLevelsCommand = exports.se_ListTopicRulesCommand = exports.se_ListTopicRuleDestinationsCommand = exports.se_ListThingTypesCommand = exports.se_ListThingsInThingGroupCommand = exports.se_ListThingsInBillingGroupCommand = exports.se_ListThingsCommand = exports.se_ListThingRegistrationTasksCommand = exports.se_ListThingRegistrationTaskReportsCommand = exports.se_ListThingPrincipalsCommand = exports.se_ListThingGroupsForThingCommand = exports.se_ListThingGroupsCommand = exports.se_ListTargetsForSecurityProfileCommand = exports.se_ListTargetsForPolicyCommand = exports.se_ListTagsForResourceCommand = exports.se_ListStreamsCommand = exports.se_ListSecurityProfilesForTargetCommand = exports.se_ListSecurityProfilesCommand = exports.se_ListScheduledAuditsCommand = exports.se_ListRoleAliasesCommand = exports.se_ListRelatedResourcesForAuditFindingCommand = exports.se_ListProvisioningTemplateVersionsCommand = exports.se_ListProvisioningTemplatesCommand = exports.se_ListPrincipalThingsCommand = exports.se_ListPrincipalPoliciesCommand = exports.se_ListPolicyVersionsCommand = exports.se_ListPolicyPrincipalsCommand = exports.se_ListPoliciesCommand = exports.se_ListPackageVersionsCommand = exports.se_ListPackagesCommand = exports.se_ListOutgoingCertificatesCommand = exports.se_ListOTAUpdatesCommand = exports.se_ListMitigationActionsCommand = exports.se_ListMetricValuesCommand = exports.se_ListManagedJobTemplatesCommand = exports.se_ListJobTemplatesCommand = exports.se_ListJobsCommand = exports.se_ListJobExecutionsForThingCommand = exports.se_ListJobExecutionsForJobCommand = exports.se_ListIndicesCommand = exports.se_ListFleetMetricsCommand = exports.se_ListDomainConfigurationsCommand = exports.se_ListDimensionsCommand = exports.se_ListDetectMitigationActionsTasksCommand = exports.se_ListDetectMitigationActionsExecutionsCommand = exports.se_ListCustomMetricsCommand = void 0;
exports.se_ValidateSecurityProfileBehaviorsCommand = exports.se_UpdateTopicRuleDestinationCommand = exports.se_UpdateThingGroupsForThingCommand = exports.se_UpdateThingGroupCommand = exports.se_UpdateThingCommand = exports.se_UpdateStreamCommand = exports.se_UpdateSecurityProfileCommand = exports.se_UpdateScheduledAuditCommand = exports.se_UpdateRoleAliasCommand = exports.se_UpdateProvisioningTemplateCommand = exports.se_UpdatePackageVersionCommand = exports.se_UpdatePackageConfigurationCommand = exports.se_UpdatePackageCommand = exports.se_UpdateMitigationActionCommand = exports.se_UpdateJobCommand = exports.se_UpdateIndexingConfigurationCommand = exports.se_UpdateFleetMetricCommand = exports.se_UpdateEventConfigurationsCommand = exports.se_UpdateDynamicThingGroupCommand = exports.se_UpdateDomainConfigurationCommand = exports.se_UpdateDimensionCommand = exports.se_UpdateCustomMetricCommand = exports.se_UpdateCertificateCommand = exports.se_UpdateCACertificateCommand = exports.se_UpdateBillingGroupCommand = exports.se_UpdateAuthorizerCommand = exports.se_UpdateAuditSuppressionCommand = exports.se_UpdateAccountAuditConfigurationCommand = exports.se_UntagResourceCommand = exports.se_TransferCertificateCommand = exports.se_TestInvokeAuthorizerCommand = exports.se_TestAuthorizationCommand = exports.se_TagResourceCommand = exports.se_StopThingRegistrationTaskCommand = exports.se_StartThingRegistrationTaskCommand = exports.se_StartOnDemandAuditTaskCommand = exports.se_StartDetectMitigationActionsTaskCommand = exports.se_StartAuditMitigationActionsTaskCommand = exports.se_SetV2LoggingOptionsCommand = exports.se_SetV2LoggingLevelCommand = exports.se_SetLoggingOptionsCommand = exports.se_SetDefaultPolicyVersionCommand = exports.se_SetDefaultAuthorizerCommand = exports.se_SearchIndexCommand = exports.se_ReplaceTopicRuleCommand = exports.se_RemoveThingFromThingGroupCommand = exports.se_RemoveThingFromBillingGroupCommand = exports.se_RejectCertificateTransferCommand = exports.se_RegisterThingCommand = exports.se_RegisterCertificateWithoutCACommand = void 0;
exports.de_DeleteBillingGroupCommand = exports.de_DeleteAuthorizerCommand = exports.de_DeleteAuditSuppressionCommand = exports.de_DeleteAccountAuditConfigurationCommand = exports.de_CreateTopicRuleDestinationCommand = exports.de_CreateTopicRuleCommand = exports.de_CreateThingTypeCommand = exports.de_CreateThingGroupCommand = exports.de_CreateThingCommand = exports.de_CreateStreamCommand = exports.de_CreateSecurityProfileCommand = exports.de_CreateScheduledAuditCommand = exports.de_CreateRoleAliasCommand = exports.de_CreateProvisioningTemplateVersionCommand = exports.de_CreateProvisioningTemplateCommand = exports.de_CreateProvisioningClaimCommand = exports.de_CreatePolicyVersionCommand = exports.de_CreatePolicyCommand = exports.de_CreatePackageVersionCommand = exports.de_CreatePackageCommand = exports.de_CreateOTAUpdateCommand = exports.de_CreateMitigationActionCommand = exports.de_CreateKeysAndCertificateCommand = exports.de_CreateJobTemplateCommand = exports.de_CreateJobCommand = exports.de_CreateFleetMetricCommand = exports.de_CreateDynamicThingGroupCommand = exports.de_CreateDomainConfigurationCommand = exports.de_CreateDimensionCommand = exports.de_CreateCustomMetricCommand = exports.de_CreateCertificateFromCsrCommand = exports.de_CreateBillingGroupCommand = exports.de_CreateAuthorizerCommand = exports.de_CreateAuditSuppressionCommand = exports.de_ConfirmTopicRuleDestinationCommand = exports.de_ClearDefaultAuthorizerCommand = exports.de_CancelJobExecutionCommand = exports.de_CancelJobCommand = exports.de_CancelDetectMitigationActionsTaskCommand = exports.de_CancelCertificateTransferCommand = exports.de_CancelAuditTaskCommand = exports.de_CancelAuditMitigationActionsTaskCommand = exports.de_AttachThingPrincipalCommand = exports.de_AttachSecurityProfileCommand = exports.de_AttachPrincipalPolicyCommand = exports.de_AttachPolicyCommand = exports.de_AssociateTargetsWithJobCommand = exports.de_AddThingToThingGroupCommand = exports.de_AddThingToBillingGroupCommand = exports.de_AcceptCertificateTransferCommand = void 0;
exports.de_DescribeJobExecutionCommand = exports.de_DescribeJobCommand = exports.de_DescribeIndexCommand = exports.de_DescribeFleetMetricCommand = exports.de_DescribeEventConfigurationsCommand = exports.de_DescribeEndpointCommand = exports.de_DescribeDomainConfigurationCommand = exports.de_DescribeDimensionCommand = exports.de_DescribeDetectMitigationActionsTaskCommand = exports.de_DescribeDefaultAuthorizerCommand = exports.de_DescribeCustomMetricCommand = exports.de_DescribeCertificateCommand = exports.de_DescribeCACertificateCommand = exports.de_DescribeBillingGroupCommand = exports.de_DescribeAuthorizerCommand = exports.de_DescribeAuditTaskCommand = exports.de_DescribeAuditSuppressionCommand = exports.de_DescribeAuditMitigationActionsTaskCommand = exports.de_DescribeAuditFindingCommand = exports.de_DescribeAccountAuditConfigurationCommand = exports.de_DeprecateThingTypeCommand = exports.de_DeleteV2LoggingLevelCommand = exports.de_DeleteTopicRuleDestinationCommand = exports.de_DeleteTopicRuleCommand = exports.de_DeleteThingTypeCommand = exports.de_DeleteThingGroupCommand = exports.de_DeleteThingCommand = exports.de_DeleteStreamCommand = exports.de_DeleteSecurityProfileCommand = exports.de_DeleteScheduledAuditCommand = exports.de_DeleteRoleAliasCommand = exports.de_DeleteRegistrationCodeCommand = exports.de_DeleteProvisioningTemplateVersionCommand = exports.de_DeleteProvisioningTemplateCommand = exports.de_DeletePolicyVersionCommand = exports.de_DeletePolicyCommand = exports.de_DeletePackageVersionCommand = exports.de_DeletePackageCommand = exports.de_DeleteOTAUpdateCommand = exports.de_DeleteMitigationActionCommand = exports.de_DeleteJobTemplateCommand = exports.de_DeleteJobExecutionCommand = exports.de_DeleteJobCommand = exports.de_DeleteFleetMetricCommand = exports.de_DeleteDynamicThingGroupCommand = exports.de_DeleteDomainConfigurationCommand = exports.de_DeleteDimensionCommand = exports.de_DeleteCustomMetricCommand = exports.de_DeleteCertificateCommand = exports.de_DeleteCACertificateCommand = void 0;
exports.de_ListCertificatesByCACommand = exports.de_ListCertificatesCommand = exports.de_ListCACertificatesCommand = exports.de_ListBillingGroupsCommand = exports.de_ListAuthorizersCommand = exports.de_ListAuditTasksCommand = exports.de_ListAuditSuppressionsCommand = exports.de_ListAuditMitigationActionsTasksCommand = exports.de_ListAuditMitigationActionsExecutionsCommand = exports.de_ListAuditFindingsCommand = exports.de_ListAttachedPoliciesCommand = exports.de_ListActiveViolationsCommand = exports.de_GetV2LoggingOptionsCommand = exports.de_GetTopicRuleDestinationCommand = exports.de_GetTopicRuleCommand = exports.de_GetStatisticsCommand = exports.de_GetRegistrationCodeCommand = exports.de_GetPolicyVersionCommand = exports.de_GetPolicyCommand = exports.de_GetPercentilesCommand = exports.de_GetPackageVersionCommand = exports.de_GetPackageConfigurationCommand = exports.de_GetPackageCommand = exports.de_GetOTAUpdateCommand = exports.de_GetLoggingOptionsCommand = exports.de_GetJobDocumentCommand = exports.de_GetIndexingConfigurationCommand = exports.de_GetEffectivePoliciesCommand = exports.de_GetCardinalityCommand = exports.de_GetBucketsAggregationCommand = exports.de_GetBehaviorModelTrainingSummariesCommand = exports.de_EnableTopicRuleCommand = exports.de_DisableTopicRuleCommand = exports.de_DetachThingPrincipalCommand = exports.de_DetachSecurityProfileCommand = exports.de_DetachPrincipalPolicyCommand = exports.de_DetachPolicyCommand = exports.de_DescribeThingTypeCommand = exports.de_DescribeThingRegistrationTaskCommand = exports.de_DescribeThingGroupCommand = exports.de_DescribeThingCommand = exports.de_DescribeStreamCommand = exports.de_DescribeSecurityProfileCommand = exports.de_DescribeScheduledAuditCommand = exports.de_DescribeRoleAliasCommand = exports.de_DescribeProvisioningTemplateVersionCommand = exports.de_DescribeProvisioningTemplateCommand = exports.de_DescribeMitigationActionCommand = exports.de_DescribeManagedJobTemplateCommand = exports.de_DescribeJobTemplateCommand = void 0;
exports.de_RegisterCertificateCommand = exports.de_RegisterCACertificateCommand = exports.de_PutVerificationStateOnViolationCommand = exports.de_ListViolationEventsCommand = exports.de_ListV2LoggingLevelsCommand = exports.de_ListTopicRulesCommand = exports.de_ListTopicRuleDestinationsCommand = exports.de_ListThingTypesCommand = exports.de_ListThingsInThingGroupCommand = exports.de_ListThingsInBillingGroupCommand = exports.de_ListThingsCommand = exports.de_ListThingRegistrationTasksCommand = exports.de_ListThingRegistrationTaskReportsCommand = exports.de_ListThingPrincipalsCommand = exports.de_ListThingGroupsForThingCommand = exports.de_ListThingGroupsCommand = exports.de_ListTargetsForSecurityProfileCommand = exports.de_ListTargetsForPolicyCommand = exports.de_ListTagsForResourceCommand = exports.de_ListStreamsCommand = exports.de_ListSecurityProfilesForTargetCommand = exports.de_ListSecurityProfilesCommand = exports.de_ListScheduledAuditsCommand = exports.de_ListRoleAliasesCommand = exports.de_ListRelatedResourcesForAuditFindingCommand = exports.de_ListProvisioningTemplateVersionsCommand = exports.de_ListProvisioningTemplatesCommand = exports.de_ListPrincipalThingsCommand = exports.de_ListPrincipalPoliciesCommand = exports.de_ListPolicyVersionsCommand = exports.de_ListPolicyPrincipalsCommand = exports.de_ListPoliciesCommand = exports.de_ListPackageVersionsCommand = exports.de_ListPackagesCommand = exports.de_ListOutgoingCertificatesCommand = exports.de_ListOTAUpdatesCommand = exports.de_ListMitigationActionsCommand = exports.de_ListMetricValuesCommand = exports.de_ListManagedJobTemplatesCommand = exports.de_ListJobTemplatesCommand = exports.de_ListJobsCommand = exports.de_ListJobExecutionsForThingCommand = exports.de_ListJobExecutionsForJobCommand = exports.de_ListIndicesCommand = exports.de_ListFleetMetricsCommand = exports.de_ListDomainConfigurationsCommand = exports.de_ListDimensionsCommand = exports.de_ListDetectMitigationActionsTasksCommand = exports.de_ListDetectMitigationActionsExecutionsCommand = exports.de_ListCustomMetricsCommand = void 0;
exports.de_ValidateSecurityProfileBehaviorsCommand = exports.de_UpdateTopicRuleDestinationCommand = exports.de_UpdateThingGroupsForThingCommand = exports.de_UpdateThingGroupCommand = exports.de_UpdateThingCommand = exports.de_UpdateStreamCommand = exports.de_UpdateSecurityProfileCommand = exports.de_UpdateScheduledAuditCommand = exports.de_UpdateRoleAliasCommand = exports.de_UpdateProvisioningTemplateCommand = exports.de_UpdatePackageVersionCommand = exports.de_UpdatePackageConfigurationCommand = exports.de_UpdatePackageCommand = exports.de_UpdateMitigationActionCommand = exports.de_UpdateJobCommand = exports.de_UpdateIndexingConfigurationCommand = exports.de_UpdateFleetMetricCommand = exports.de_UpdateEventConfigurationsCommand = exports.de_UpdateDynamicThingGroupCommand = exports.de_UpdateDomainConfigurationCommand = exports.de_UpdateDimensionCommand = exports.de_UpdateCustomMetricCommand = exports.de_UpdateCertificateCommand = exports.de_UpdateCACertificateCommand = exports.de_UpdateBillingGroupCommand = exports.de_UpdateAuthorizerCommand = exports.de_UpdateAuditSuppressionCommand = exports.de_UpdateAccountAuditConfigurationCommand = exports.de_UntagResourceCommand = exports.de_TransferCertificateCommand = exports.de_TestInvokeAuthorizerCommand = exports.de_TestAuthorizationCommand = exports.de_TagResourceCommand = exports.de_StopThingRegistrationTaskCommand = exports.de_StartThingRegistrationTaskCommand = exports.de_StartOnDemandAuditTaskCommand = exports.de_StartDetectMitigationActionsTaskCommand = exports.de_StartAuditMitigationActionsTaskCommand = exports.de_SetV2LoggingOptionsCommand = exports.de_SetV2LoggingLevelCommand = exports.de_SetLoggingOptionsCommand = exports.de_SetDefaultPolicyVersionCommand = exports.de_SetDefaultAuthorizerCommand = exports.de_SearchIndexCommand = exports.de_ReplaceTopicRuleCommand = exports.de_RemoveThingFromThingGroupCommand = exports.de_RemoveThingFromBillingGroupCommand = exports.de_RejectCertificateTransferCommand = exports.de_RegisterThingCommand = exports.de_RegisterCertificateWithoutCACommand = void 0;
const protocol_http_1 = require("@smithy/protocol-http");
const smithy_client_1 = require("@smithy/smithy-client");
const uuid_1 = require("uuid");
const IoTServiceException_1 = require("../models/IoTServiceException");
const models_0_1 = require("../models/models_0");
const models_1_1 = require("../models/models_1");
const models_2_1 = require("../models/models_2");
const se_AcceptCertificateTransferCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/accept-certificate-transfer/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = (0, smithy_client_1.map)({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_AcceptCertificateTransferCommand = se_AcceptCertificateTransferCommand;
const se_AddThingToBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/addThingToBillingGroup";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        billingGroupArn: [],
        billingGroupName: [],
        thingArn: [],
        thingName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_AddThingToBillingGroupCommand = se_AddThingToBillingGroupCommand;
const se_AddThingToThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/addThingToThingGroup";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        overrideDynamicGroups: [],
        thingArn: [],
        thingGroupArn: [],
        thingGroupName: [],
        thingName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_AddThingToThingGroupCommand = se_AddThingToThingGroupCommand;
const se_AssociateTargetsWithJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/targets";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = (0, smithy_client_1.map)({
        namespaceId: [, input.namespaceId],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        comment: [],
        targets: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_AssociateTargetsWithJobCommand = se_AssociateTargetsWithJobCommand;
const se_AttachPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/target-policies/{policyName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        target: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_AttachPolicyCommand = se_AttachPolicyCommand;
const se_AttachPrincipalPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amzn-iot-principal": input.principal,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies/{policyName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_AttachPrincipalPolicyCommand = se_AttachPrincipalPolicyCommand;
const se_AttachSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/security-profiles/{securityProfileName}/targets";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = (0, smithy_client_1.map)({
        securityProfileTargetArn: [, (0, smithy_client_1.expectNonNull)(input.securityProfileTargetArn, `securityProfileTargetArn`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_AttachSecurityProfileCommand = se_AttachSecurityProfileCommand;
const se_AttachThingPrincipalCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amzn-principal": input.principal,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_AttachThingPrincipalCommand = se_AttachThingPrincipalCommand;
const se_CancelAuditMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/mitigationactions/tasks/{taskId}/cancel";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CancelAuditMitigationActionsTaskCommand = se_CancelAuditMitigationActionsTaskCommand;
const se_CancelAuditTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks/{taskId}/cancel";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CancelAuditTaskCommand = se_CancelAuditTaskCommand;
const se_CancelCertificateTransferCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/cancel-certificate-transfer/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CancelCertificateTransferCommand = se_CancelCertificateTransferCommand;
const se_CancelDetectMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/detect/mitigationactions/tasks/{taskId}/cancel";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CancelDetectMitigationActionsTaskCommand = se_CancelDetectMitigationActionsTaskCommand;
const se_CancelJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/cancel";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = (0, smithy_client_1.map)({
        force: [() => input.force !== void 0, () => input.force.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        comment: [],
        reasonCode: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_CancelJobCommand = se_CancelJobCommand;
const se_CancelJobExecutionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs/{jobId}/cancel";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = (0, smithy_client_1.map)({
        force: [() => input.force !== void 0, () => input.force.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        expectedVersion: [],
        statusDetails: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_CancelJobExecutionCommand = se_CancelJobExecutionCommand;
const se_ClearDefaultAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ClearDefaultAuthorizerCommand = se_ClearDefaultAuthorizerCommand;
const se_ConfirmTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/confirmdestination/{confirmationToken+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "confirmationToken", () => input.confirmationToken, "{confirmationToken+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ConfirmTopicRuleDestinationCommand = se_ConfirmTopicRuleDestinationCommand;
const se_CreateAuditSuppressionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/create";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        checkName: [],
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        description: [],
        expirationDate: (_) => Math.round(_.getTime() / 1000),
        resourceIdentifier: (_) => (0, smithy_client_1._json)(_),
        suppressIndefinitely: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateAuditSuppressionCommand = se_CreateAuditSuppressionCommand;
const se_CreateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authorizerFunctionArn: [],
        enableCachingForHttp: [],
        signingDisabled: [],
        status: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        tokenKeyName: [],
        tokenSigningPublicKeys: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateAuthorizerCommand = se_CreateAuthorizerCommand;
const se_CreateBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        billingGroupProperties: (_) => (0, smithy_client_1._json)(_),
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateBillingGroupCommand = se_CreateBillingGroupCommand;
const se_CreateCertificateFromCsrCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates";
    const query = (0, smithy_client_1.map)({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        certificateSigningRequest: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_CreateCertificateFromCsrCommand = se_CreateCertificateFromCsrCommand;
const se_CreateCustomMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        displayName: [],
        metricType: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateCustomMetricCommand = se_CreateCustomMetricCommand;
const se_CreateDimensionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "name", () => input.name, "{name}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        stringValues: (_) => (0, smithy_client_1._json)(_),
        tags: (_) => (0, smithy_client_1._json)(_),
        type: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDimensionCommand = se_CreateDimensionCommand;
const se_CreateDomainConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainConfigurations/{domainConfigurationName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authorizerConfig: (_) => (0, smithy_client_1._json)(_),
        domainName: [],
        serverCertificateArns: (_) => (0, smithy_client_1._json)(_),
        serviceType: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        tlsConfig: (_) => (0, smithy_client_1._json)(_),
        validationCertificateArn: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDomainConfigurationCommand = se_CreateDomainConfigurationCommand;
const se_CreateDynamicThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        indexName: [],
        queryString: [],
        queryVersion: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        thingGroupProperties: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateDynamicThingGroupCommand = se_CreateDynamicThingGroupCommand;
const se_CreateFleetMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        aggregationField: [],
        aggregationType: (_) => (0, smithy_client_1._json)(_),
        description: [],
        indexName: [],
        period: [],
        queryString: [],
        queryVersion: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        unit: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateFleetMetricCommand = se_CreateFleetMetricCommand;
const se_CreateJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        abortConfig: (_) => se_AbortConfig(_, context),
        description: [],
        destinationPackageVersions: (_) => (0, smithy_client_1._json)(_),
        document: [],
        documentParameters: (_) => (0, smithy_client_1._json)(_),
        documentSource: [],
        jobExecutionsRetryConfig: (_) => (0, smithy_client_1._json)(_),
        jobExecutionsRolloutConfig: (_) => se_JobExecutionsRolloutConfig(_, context),
        jobTemplateArn: [],
        namespaceId: [],
        presignedUrlConfig: (_) => (0, smithy_client_1._json)(_),
        schedulingConfig: (_) => (0, smithy_client_1._json)(_),
        tags: (_) => (0, smithy_client_1._json)(_),
        targetSelection: [],
        targets: (_) => (0, smithy_client_1._json)(_),
        timeoutConfig: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateJobCommand = se_CreateJobCommand;
const se_CreateJobTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        abortConfig: (_) => se_AbortConfig(_, context),
        description: [],
        destinationPackageVersions: (_) => (0, smithy_client_1._json)(_),
        document: [],
        documentSource: [],
        jobArn: [],
        jobExecutionsRetryConfig: (_) => (0, smithy_client_1._json)(_),
        jobExecutionsRolloutConfig: (_) => se_JobExecutionsRolloutConfig(_, context),
        maintenanceWindows: (_) => (0, smithy_client_1._json)(_),
        presignedUrlConfig: (_) => (0, smithy_client_1._json)(_),
        tags: (_) => (0, smithy_client_1._json)(_),
        timeoutConfig: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateJobTemplateCommand = se_CreateJobTemplateCommand;
const se_CreateKeysAndCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/keys-and-certificate";
    const query = (0, smithy_client_1.map)({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_CreateKeysAndCertificateCommand = se_CreateKeysAndCertificateCommand;
const se_CreateMitigationActionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "actionName", () => input.actionName, "{actionName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        actionParams: (_) => (0, smithy_client_1._json)(_),
        roleArn: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateMitigationActionCommand = se_CreateMitigationActionCommand;
const se_CreateOTAUpdateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        additionalParameters: (_) => (0, smithy_client_1._json)(_),
        awsJobAbortConfig: (_) => se_AwsJobAbortConfig(_, context),
        awsJobExecutionsRolloutConfig: (_) => se_AwsJobExecutionsRolloutConfig(_, context),
        awsJobPresignedUrlConfig: (_) => (0, smithy_client_1._json)(_),
        awsJobTimeoutConfig: (_) => (0, smithy_client_1._json)(_),
        description: [],
        files: (_) => se_OTAUpdateFiles(_, context),
        protocols: (_) => (0, smithy_client_1._json)(_),
        roleArn: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        targetSelection: [],
        targets: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateOTAUpdateCommand = se_CreateOTAUpdateCommand;
const se_CreatePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/packages/{packageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    const query = (0, smithy_client_1.map)({
        clientToken: [, input.clientToken ?? (0, uuid_1.v4)()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_CreatePackageCommand = se_CreatePackageCommand;
const se_CreatePackageVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/packages/{packageName}/versions/{versionName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "versionName", () => input.versionName, "{versionName}", false);
    const query = (0, smithy_client_1.map)({
        clientToken: [, input.clientToken ?? (0, uuid_1.v4)()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        attributes: (_) => (0, smithy_client_1._json)(_),
        description: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_CreatePackageVersionCommand = se_CreatePackageVersionCommand;
const se_CreatePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        policyDocument: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreatePolicyCommand = se_CreatePolicyCommand;
const se_CreatePolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}/version";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    const query = (0, smithy_client_1.map)({
        setAsDefault: [() => input.setAsDefault !== void 0, () => input.setAsDefault.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        policyDocument: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_CreatePolicyVersionCommand = se_CreatePolicyVersionCommand;
const se_CreateProvisioningClaimCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/provisioning-claim";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateProvisioningClaimCommand = se_CreateProvisioningClaimCommand;
const se_CreateProvisioningTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [],
        enabled: [],
        preProvisioningHook: (_) => (0, smithy_client_1._json)(_),
        provisioningRoleArn: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        templateBody: [],
        templateName: [],
        type: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateProvisioningTemplateCommand = se_CreateProvisioningTemplateCommand;
const se_CreateProvisioningTemplateVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/versions";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    const query = (0, smithy_client_1.map)({
        setAsDefault: [() => input.setAsDefault !== void 0, () => input.setAsDefault.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        templateBody: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_CreateProvisioningTemplateVersionCommand = se_CreateProvisioningTemplateVersionCommand;
const se_CreateRoleAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        credentialDurationSeconds: [],
        roleArn: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateRoleAliasCommand = se_CreateRoleAliasCommand;
const se_CreateScheduledAuditCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/scheduledaudits/{scheduledAuditName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        dayOfMonth: [],
        dayOfWeek: [],
        frequency: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        targetCheckNames: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateScheduledAuditCommand = se_CreateScheduledAuditCommand;
const se_CreateSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        additionalMetricsToRetain: (_) => (0, smithy_client_1._json)(_),
        additionalMetricsToRetainV2: (_) => (0, smithy_client_1._json)(_),
        alertTargets: (_) => (0, smithy_client_1._json)(_),
        behaviors: (_) => se_Behaviors(_, context),
        securityProfileDescription: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateSecurityProfileCommand = se_CreateSecurityProfileCommand;
const se_CreateStreamCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "streamId", () => input.streamId, "{streamId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [],
        files: (_) => (0, smithy_client_1._json)(_),
        roleArn: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateStreamCommand = se_CreateStreamCommand;
const se_CreateThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        attributePayload: (_) => (0, smithy_client_1._json)(_),
        billingGroupName: [],
        thingTypeName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateThingCommand = se_CreateThingCommand;
const se_CreateThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        parentGroupName: [],
        tags: (_) => (0, smithy_client_1._json)(_),
        thingGroupProperties: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateThingGroupCommand = se_CreateThingGroupCommand;
const se_CreateThingTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        tags: (_) => (0, smithy_client_1._json)(_),
        thingTypeProperties: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateThingTypeCommand = se_CreateThingTypeCommand;
const se_CreateTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "content-type": "application/json",
        "x-amz-tagging": input.tags,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    if (input.topicRulePayload !== undefined) {
        body = (0, smithy_client_1._json)(input.topicRulePayload);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateTopicRuleCommand = se_CreateTopicRuleCommand;
const se_CreateTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        destinationConfiguration: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_CreateTopicRuleDestinationCommand = se_CreateTopicRuleDestinationCommand;
const se_DeleteAccountAuditConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
    const query = (0, smithy_client_1.map)({
        deleteScheduledAudits: [
            () => input.deleteScheduledAudits !== void 0,
            () => input.deleteScheduledAudits.toString(),
        ],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteAccountAuditConfigurationCommand = se_DeleteAccountAuditConfigurationCommand;
const se_DeleteAuditSuppressionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/delete";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        checkName: [],
        resourceIdentifier: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteAuditSuppressionCommand = se_DeleteAuditSuppressionCommand;
const se_DeleteAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteAuthorizerCommand = se_DeleteAuthorizerCommand;
const se_DeleteBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    const query = (0, smithy_client_1.map)({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteBillingGroupCommand = se_DeleteBillingGroupCommand;
const se_DeleteCACertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteCACertificateCommand = se_DeleteCACertificateCommand;
const se_DeleteCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = (0, smithy_client_1.map)({
        forceDelete: [() => input.forceDelete !== void 0, () => input.forceDelete.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteCertificateCommand = se_DeleteCertificateCommand;
const se_DeleteCustomMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteCustomMetricCommand = se_DeleteCustomMetricCommand;
const se_DeleteDimensionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "name", () => input.name, "{name}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteDimensionCommand = se_DeleteDimensionCommand;
const se_DeleteDomainConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainConfigurations/{domainConfigurationName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteDomainConfigurationCommand = se_DeleteDomainConfigurationCommand;
const se_DeleteDynamicThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = (0, smithy_client_1.map)({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteDynamicThingGroupCommand = se_DeleteDynamicThingGroupCommand;
const se_DeleteFleetMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    const query = (0, smithy_client_1.map)({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteFleetMetricCommand = se_DeleteFleetMetricCommand;
const se_DeleteJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = (0, smithy_client_1.map)({
        force: [() => input.force !== void 0, () => input.force.toString()],
        namespaceId: [, input.namespaceId],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteJobCommand = se_DeleteJobCommand;
const se_DeleteJobExecutionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/things/{thingName}/jobs/{jobId}/executionNumber/{executionNumber}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "executionNumber", () => input.executionNumber.toString(), "{executionNumber}", false);
    const query = (0, smithy_client_1.map)({
        force: [() => input.force !== void 0, () => input.force.toString()],
        namespaceId: [, input.namespaceId],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteJobExecutionCommand = se_DeleteJobExecutionCommand;
const se_DeleteJobTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteJobTemplateCommand = se_DeleteJobTemplateCommand;
const se_DeleteMitigationActionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "actionName", () => input.actionName, "{actionName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteMitigationActionCommand = se_DeleteMitigationActionCommand;
const se_DeleteOTAUpdateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    const query = (0, smithy_client_1.map)({
        deleteStream: [() => input.deleteStream !== void 0, () => input.deleteStream.toString()],
        forceDeleteAWSJob: [() => input.forceDeleteAWSJob !== void 0, () => input.forceDeleteAWSJob.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteOTAUpdateCommand = se_DeleteOTAUpdateCommand;
const se_DeletePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/packages/{packageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    const query = (0, smithy_client_1.map)({
        clientToken: [, input.clientToken ?? (0, uuid_1.v4)()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeletePackageCommand = se_DeletePackageCommand;
const se_DeletePackageVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/packages/{packageName}/versions/{versionName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "versionName", () => input.versionName, "{versionName}", false);
    const query = (0, smithy_client_1.map)({
        clientToken: [, input.clientToken ?? (0, uuid_1.v4)()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeletePackageVersionCommand = se_DeletePackageVersionCommand;
const se_DeletePolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeletePolicyCommand = se_DeletePolicyCommand;
const se_DeletePolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/policies/{policyName}/version/{policyVersionId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeletePolicyVersionCommand = se_DeletePolicyVersionCommand;
const se_DeleteProvisioningTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteProvisioningTemplateCommand = se_DeleteProvisioningTemplateCommand;
const se_DeleteProvisioningTemplateVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/versions/{versionId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "versionId", () => input.versionId.toString(), "{versionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteProvisioningTemplateVersionCommand = se_DeleteProvisioningTemplateVersionCommand;
const se_DeleteRegistrationCodeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/registrationcode";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteRegistrationCodeCommand = se_DeleteRegistrationCodeCommand;
const se_DeleteRoleAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteRoleAliasCommand = se_DeleteRoleAliasCommand;
const se_DeleteScheduledAuditCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/scheduledaudits/{scheduledAuditName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteScheduledAuditCommand = se_DeleteScheduledAuditCommand;
const se_DeleteSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = (0, smithy_client_1.map)({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteSecurityProfileCommand = se_DeleteSecurityProfileCommand;
const se_DeleteStreamCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "streamId", () => input.streamId, "{streamId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteStreamCommand = se_DeleteStreamCommand;
const se_DeleteThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = (0, smithy_client_1.map)({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteThingCommand = se_DeleteThingCommand;
const se_DeleteThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = (0, smithy_client_1.map)({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteThingGroupCommand = se_DeleteThingGroupCommand;
const se_DeleteThingTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteThingTypeCommand = se_DeleteThingTypeCommand;
const se_DeleteTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteTopicRuleCommand = se_DeleteTopicRuleCommand;
const se_DeleteTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations/{arn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "arn", () => input.arn, "{arn+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeleteTopicRuleDestinationCommand = se_DeleteTopicRuleDestinationCommand;
const se_DeleteV2LoggingLevelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
    const query = (0, smithy_client_1.map)({
        targetType: [, (0, smithy_client_1.expectNonNull)(input.targetType, `targetType`)],
        targetName: [, (0, smithy_client_1.expectNonNull)(input.targetName, `targetName`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DeleteV2LoggingLevelCommand = se_DeleteV2LoggingLevelCommand;
const se_DeprecateThingTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}/deprecate";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        undoDeprecate: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DeprecateThingTypeCommand = se_DeprecateThingTypeCommand;
const se_DescribeAccountAuditConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeAccountAuditConfigurationCommand = se_DescribeAccountAuditConfigurationCommand;
const se_DescribeAuditFindingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/findings/{findingId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "findingId", () => input.findingId, "{findingId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeAuditFindingCommand = se_DescribeAuditFindingCommand;
const se_DescribeAuditMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks/{taskId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeAuditMitigationActionsTaskCommand = se_DescribeAuditMitigationActionsTaskCommand;
const se_DescribeAuditSuppressionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/describe";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        checkName: [],
        resourceIdentifier: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeAuditSuppressionCommand = se_DescribeAuditSuppressionCommand;
const se_DescribeAuditTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks/{taskId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeAuditTaskCommand = se_DescribeAuditTaskCommand;
const se_DescribeAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeAuthorizerCommand = se_DescribeAuthorizerCommand;
const se_DescribeBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeBillingGroupCommand = se_DescribeBillingGroupCommand;
const se_DescribeCACertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeCACertificateCommand = se_DescribeCACertificateCommand;
const se_DescribeCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeCertificateCommand = se_DescribeCertificateCommand;
const se_DescribeCustomMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeCustomMetricCommand = se_DescribeCustomMetricCommand;
const se_DescribeDefaultAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeDefaultAuthorizerCommand = se_DescribeDefaultAuthorizerCommand;
const se_DescribeDetectMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks/{taskId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeDetectMitigationActionsTaskCommand = se_DescribeDetectMitigationActionsTaskCommand;
const se_DescribeDimensionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "name", () => input.name, "{name}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeDimensionCommand = se_DescribeDimensionCommand;
const se_DescribeDomainConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainConfigurations/{domainConfigurationName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeDomainConfigurationCommand = se_DescribeDomainConfigurationCommand;
const se_DescribeEndpointCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/endpoint";
    const query = (0, smithy_client_1.map)({
        endpointType: [, input.endpointType],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DescribeEndpointCommand = se_DescribeEndpointCommand;
const se_DescribeEventConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/event-configurations";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeEventConfigurationsCommand = se_DescribeEventConfigurationsCommand;
const se_DescribeFleetMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeFleetMetricCommand = se_DescribeFleetMetricCommand;
const se_DescribeIndexCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/{indexName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "indexName", () => input.indexName, "{indexName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeIndexCommand = se_DescribeIndexCommand;
const se_DescribeJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeJobCommand = se_DescribeJobCommand;
const se_DescribeJobExecutionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs/{jobId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = (0, smithy_client_1.map)({
        executionNumber: [() => input.executionNumber !== void 0, () => input.executionNumber.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DescribeJobExecutionCommand = se_DescribeJobExecutionCommand;
const se_DescribeJobTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates/{jobTemplateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobTemplateId", () => input.jobTemplateId, "{jobTemplateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeJobTemplateCommand = se_DescribeJobTemplateCommand;
const se_DescribeManagedJobTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/managed-job-templates/{templateName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    const query = (0, smithy_client_1.map)({
        templateVersion: [, input.templateVersion],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DescribeManagedJobTemplateCommand = se_DescribeManagedJobTemplateCommand;
const se_DescribeMitigationActionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "actionName", () => input.actionName, "{actionName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeMitigationActionCommand = se_DescribeMitigationActionCommand;
const se_DescribeProvisioningTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeProvisioningTemplateCommand = se_DescribeProvisioningTemplateCommand;
const se_DescribeProvisioningTemplateVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/versions/{versionId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "versionId", () => input.versionId.toString(), "{versionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeProvisioningTemplateVersionCommand = se_DescribeProvisioningTemplateVersionCommand;
const se_DescribeRoleAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeRoleAliasCommand = se_DescribeRoleAliasCommand;
const se_DescribeScheduledAuditCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/scheduledaudits/{scheduledAuditName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeScheduledAuditCommand = se_DescribeScheduledAuditCommand;
const se_DescribeSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeSecurityProfileCommand = se_DescribeSecurityProfileCommand;
const se_DescribeStreamCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "streamId", () => input.streamId, "{streamId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeStreamCommand = se_DescribeStreamCommand;
const se_DescribeThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeThingCommand = se_DescribeThingCommand;
const se_DescribeThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeThingGroupCommand = se_DescribeThingGroupCommand;
const se_DescribeThingRegistrationTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks/{taskId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeThingRegistrationTaskCommand = se_DescribeThingRegistrationTaskCommand;
const se_DescribeThingTypeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types/{thingTypeName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingTypeName", () => input.thingTypeName, "{thingTypeName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DescribeThingTypeCommand = se_DescribeThingTypeCommand;
const se_DetachPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/target-policies/{policyName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        target: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DetachPolicyCommand = se_DetachPolicyCommand;
const se_DetachPrincipalPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amzn-iot-principal": input.principal,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies/{policyName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DetachPrincipalPolicyCommand = se_DetachPrincipalPolicyCommand;
const se_DetachSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/security-profiles/{securityProfileName}/targets";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = (0, smithy_client_1.map)({
        securityProfileTargetArn: [, (0, smithy_client_1.expectNonNull)(input.securityProfileTargetArn, `securityProfileTargetArn`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_DetachSecurityProfileCommand = se_DetachSecurityProfileCommand;
const se_DetachThingPrincipalCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amzn-principal": input.principal,
    });
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "DELETE",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DetachThingPrincipalCommand = se_DetachThingPrincipalCommand;
const se_DisableTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}/disable";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_DisableTopicRuleCommand = se_DisableTopicRuleCommand;
const se_EnableTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}/enable";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_EnableTopicRuleCommand = se_EnableTopicRuleCommand;
const se_GetBehaviorModelTrainingSummariesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/behavior-model-training/summaries";
    const query = (0, smithy_client_1.map)({
        securityProfileName: [, input.securityProfileName],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetBehaviorModelTrainingSummariesCommand = se_GetBehaviorModelTrainingSummariesCommand;
const se_GetBucketsAggregationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/buckets";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        aggregationField: [],
        bucketsAggregationType: (_) => (0, smithy_client_1._json)(_),
        indexName: [],
        queryString: [],
        queryVersion: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetBucketsAggregationCommand = se_GetBucketsAggregationCommand;
const se_GetCardinalityCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/cardinality";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        aggregationField: [],
        indexName: [],
        queryString: [],
        queryVersion: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetCardinalityCommand = se_GetCardinalityCommand;
const se_GetEffectivePoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/effective-policies";
    const query = (0, smithy_client_1.map)({
        thingName: [, input.thingName],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        cognitoIdentityPoolId: [],
        principal: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_GetEffectivePoliciesCommand = se_GetEffectivePoliciesCommand;
const se_GetIndexingConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indexing/config";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetIndexingConfigurationCommand = se_GetIndexingConfigurationCommand;
const se_GetJobDocumentCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/job-document";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetJobDocumentCommand = se_GetJobDocumentCommand;
const se_GetLoggingOptionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/loggingOptions";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetLoggingOptionsCommand = se_GetLoggingOptionsCommand;
const se_GetOTAUpdateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates/{otaUpdateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "otaUpdateId", () => input.otaUpdateId, "{otaUpdateId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetOTAUpdateCommand = se_GetOTAUpdateCommand;
const se_GetPackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/packages/{packageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetPackageCommand = se_GetPackageCommand;
const se_GetPackageConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/package-configuration";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetPackageConfigurationCommand = se_GetPackageConfigurationCommand;
const se_GetPackageVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/packages/{packageName}/versions/{versionName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "versionName", () => input.versionName, "{versionName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetPackageVersionCommand = se_GetPackageVersionCommand;
const se_GetPercentilesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/percentiles";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        aggregationField: [],
        indexName: [],
        percents: (_) => se_PercentList(_, context),
        queryString: [],
        queryVersion: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetPercentilesCommand = se_GetPercentilesCommand;
const se_GetPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetPolicyCommand = se_GetPolicyCommand;
const se_GetPolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/policies/{policyName}/version/{policyVersionId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetPolicyVersionCommand = se_GetPolicyVersionCommand;
const se_GetRegistrationCodeCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/registrationcode";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetRegistrationCodeCommand = se_GetRegistrationCodeCommand;
const se_GetStatisticsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/statistics";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        aggregationField: [],
        indexName: [],
        queryString: [],
        queryVersion: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetStatisticsCommand = se_GetStatisticsCommand;
const se_GetTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetTopicRuleCommand = se_GetTopicRuleCommand;
const se_GetTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations/{arn+}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "arn", () => input.arn, "{arn+}", true);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetTopicRuleDestinationCommand = se_GetTopicRuleDestinationCommand;
const se_GetV2LoggingOptionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingOptions";
    let body;
    body = "";
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_GetV2LoggingOptionsCommand = se_GetV2LoggingOptionsCommand;
const se_ListActiveViolationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/active-violations";
    const query = (0, smithy_client_1.map)({
        thingName: [, input.thingName],
        securityProfileName: [, input.securityProfileName],
        behaviorCriteriaType: [, input.behaviorCriteriaType],
        listSuppressedAlerts: [() => input.listSuppressedAlerts !== void 0, () => input.listSuppressedAlerts.toString()],
        verificationState: [, input.verificationState],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListActiveViolationsCommand = se_ListActiveViolationsCommand;
const se_ListAttachedPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/attached-policies/{target}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "target", () => input.target, "{target}", false);
    const query = (0, smithy_client_1.map)({
        recursive: [() => input.recursive !== void 0, () => input.recursive.toString()],
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListAttachedPoliciesCommand = se_ListAttachedPoliciesCommand;
const se_ListAuditFindingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/findings";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        checkName: [],
        endTime: (_) => Math.round(_.getTime() / 1000),
        listSuppressedFindings: [],
        maxResults: [],
        nextToken: [],
        resourceIdentifier: (_) => (0, smithy_client_1._json)(_),
        startTime: (_) => Math.round(_.getTime() / 1000),
        taskId: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ListAuditFindingsCommand = se_ListAuditFindingsCommand;
const se_ListAuditMitigationActionsExecutionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/executions";
    const query = (0, smithy_client_1.map)({
        taskId: [, (0, smithy_client_1.expectNonNull)(input.taskId, `taskId`)],
        actionStatus: [, input.actionStatus],
        findingId: [, (0, smithy_client_1.expectNonNull)(input.findingId, `findingId`)],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListAuditMitigationActionsExecutionsCommand = se_ListAuditMitigationActionsExecutionsCommand;
const se_ListAuditMitigationActionsTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks";
    const query = (0, smithy_client_1.map)({
        auditTaskId: [, input.auditTaskId],
        findingId: [, input.findingId],
        taskStatus: [, input.taskStatus],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        startTime: [
            (0, smithy_client_1.expectNonNull)(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            (0, smithy_client_1.expectNonNull)(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListAuditMitigationActionsTasksCommand = se_ListAuditMitigationActionsTasksCommand;
const se_ListAuditSuppressionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/list";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        ascendingOrder: [],
        checkName: [],
        maxResults: [],
        nextToken: [],
        resourceIdentifier: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ListAuditSuppressionsCommand = se_ListAuditSuppressionsCommand;
const se_ListAuditTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks";
    const query = (0, smithy_client_1.map)({
        startTime: [
            (0, smithy_client_1.expectNonNull)(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            (0, smithy_client_1.expectNonNull)(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        taskType: [, input.taskType],
        taskStatus: [, input.taskStatus],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListAuditTasksCommand = se_ListAuditTasksCommand;
const se_ListAuthorizersCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizers";
    const query = (0, smithy_client_1.map)({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
        status: [, input.status],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListAuthorizersCommand = se_ListAuthorizersCommand;
const se_ListBillingGroupsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        namePrefixFilter: [, input.namePrefixFilter],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListBillingGroupsCommand = se_ListBillingGroupsCommand;
const se_ListCACertificatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificates";
    const query = (0, smithy_client_1.map)({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
        templateName: [, input.templateName],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListCACertificatesCommand = se_ListCACertificatesCommand;
const se_ListCertificatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates";
    const query = (0, smithy_client_1.map)({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListCertificatesCommand = se_ListCertificatesCommand;
const se_ListCertificatesByCACommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates-by-ca/{caCertificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "caCertificateId", () => input.caCertificateId, "{caCertificateId}", false);
    const query = (0, smithy_client_1.map)({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListCertificatesByCACommand = se_ListCertificatesByCACommand;
const se_ListCustomMetricsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metrics";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListCustomMetricsCommand = se_ListCustomMetricsCommand;
const se_ListDetectMitigationActionsExecutionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/executions";
    const query = (0, smithy_client_1.map)({
        taskId: [, input.taskId],
        violationId: [, input.violationId],
        thingName: [, input.thingName],
        startTime: [
            () => input.startTime !== void 0,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [() => input.endTime !== void 0, () => (input.endTime.toISOString().split(".")[0] + "Z").toString()],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListDetectMitigationActionsExecutionsCommand = se_ListDetectMitigationActionsExecutionsCommand;
const se_ListDetectMitigationActionsTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        startTime: [
            (0, smithy_client_1.expectNonNull)(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            (0, smithy_client_1.expectNonNull)(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListDetectMitigationActionsTasksCommand = se_ListDetectMitigationActionsTasksCommand;
const se_ListDimensionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListDimensionsCommand = se_ListDimensionsCommand;
const se_ListDomainConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/domainConfigurations";
    const query = (0, smithy_client_1.map)({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        serviceType: [, input.serviceType],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListDomainConfigurationsCommand = se_ListDomainConfigurationsCommand;
const se_ListFleetMetricsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metrics";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListFleetMetricsCommand = se_ListFleetMetricsCommand;
const se_ListIndicesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListIndicesCommand = se_ListIndicesCommand;
const se_ListJobExecutionsForJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}/things";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = (0, smithy_client_1.map)({
        status: [, input.status],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListJobExecutionsForJobCommand = se_ListJobExecutionsForJobCommand;
const se_ListJobExecutionsForThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/jobs";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = (0, smithy_client_1.map)({
        status: [, input.status],
        namespaceId: [, input.namespaceId],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        jobId: [, input.jobId],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListJobExecutionsForThingCommand = se_ListJobExecutionsForThingCommand;
const se_ListJobsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs";
    const query = (0, smithy_client_1.map)({
        status: [, input.status],
        targetSelection: [, input.targetSelection],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        thingGroupName: [, input.thingGroupName],
        thingGroupId: [, input.thingGroupId],
        namespaceId: [, input.namespaceId],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListJobsCommand = se_ListJobsCommand;
const se_ListJobTemplatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/job-templates";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListJobTemplatesCommand = se_ListJobTemplatesCommand;
const se_ListManagedJobTemplatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/managed-job-templates";
    const query = (0, smithy_client_1.map)({
        templateName: [, input.templateName],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListManagedJobTemplatesCommand = se_ListManagedJobTemplatesCommand;
const se_ListMetricValuesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/metric-values";
    const query = (0, smithy_client_1.map)({
        thingName: [, (0, smithy_client_1.expectNonNull)(input.thingName, `thingName`)],
        metricName: [, (0, smithy_client_1.expectNonNull)(input.metricName, `metricName`)],
        dimensionName: [, input.dimensionName],
        dimensionValueOperator: [, input.dimensionValueOperator],
        startTime: [
            (0, smithy_client_1.expectNonNull)(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            (0, smithy_client_1.expectNonNull)(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListMetricValuesCommand = se_ListMetricValuesCommand;
const se_ListMitigationActionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions";
    const query = (0, smithy_client_1.map)({
        actionType: [, input.actionType],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListMitigationActionsCommand = se_ListMitigationActionsCommand;
const se_ListOTAUpdatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/otaUpdates";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        otaUpdateStatus: [, input.otaUpdateStatus],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListOTAUpdatesCommand = se_ListOTAUpdatesCommand;
const se_ListOutgoingCertificatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates-out-going";
    const query = (0, smithy_client_1.map)({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListOutgoingCertificatesCommand = se_ListOutgoingCertificatesCommand;
const se_ListPackagesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/packages";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListPackagesCommand = se_ListPackagesCommand;
const se_ListPackageVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/packages/{packageName}/versions";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    const query = (0, smithy_client_1.map)({
        status: [, input.status],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListPackageVersionsCommand = se_ListPackageVersionsCommand;
const se_ListPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies";
    const query = (0, smithy_client_1.map)({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListPoliciesCommand = se_ListPoliciesCommand;
const se_ListPolicyPrincipalsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amzn-iot-policy": input.policyName,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policy-principals";
    const query = (0, smithy_client_1.map)({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListPolicyPrincipalsCommand = se_ListPolicyPrincipalsCommand;
const se_ListPolicyVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policies/{policyName}/version";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ListPolicyVersionsCommand = se_ListPolicyVersionsCommand;
const se_ListPrincipalPoliciesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amzn-iot-principal": input.principal,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principal-policies";
    const query = (0, smithy_client_1.map)({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListPrincipalPoliciesCommand = se_ListPrincipalPoliciesCommand;
const se_ListPrincipalThingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amzn-principal": input.principal,
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/principals/things";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListPrincipalThingsCommand = se_ListPrincipalThingsCommand;
const se_ListProvisioningTemplatesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListProvisioningTemplatesCommand = se_ListProvisioningTemplatesCommand;
const se_ListProvisioningTemplateVersionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/provisioning-templates/{templateName}/versions";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListProvisioningTemplateVersionsCommand = se_ListProvisioningTemplateVersionsCommand;
const se_ListRelatedResourcesForAuditFindingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/relatedResources";
    const query = (0, smithy_client_1.map)({
        findingId: [, (0, smithy_client_1.expectNonNull)(input.findingId, `findingId`)],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListRelatedResourcesForAuditFindingCommand = se_ListRelatedResourcesForAuditFindingCommand;
const se_ListRoleAliasesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases";
    const query = (0, smithy_client_1.map)({
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
        marker: [, input.marker],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListRoleAliasesCommand = se_ListRoleAliasesCommand;
const se_ListScheduledAuditsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/scheduledaudits";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListScheduledAuditsCommand = se_ListScheduledAuditsCommand;
const se_ListSecurityProfilesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        dimensionName: [, input.dimensionName],
        metricName: [, input.metricName],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListSecurityProfilesCommand = se_ListSecurityProfilesCommand;
const se_ListSecurityProfilesForTargetCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles-for-target";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        recursive: [() => input.recursive !== void 0, () => input.recursive.toString()],
        securityProfileTargetArn: [, (0, smithy_client_1.expectNonNull)(input.securityProfileTargetArn, `securityProfileTargetArn`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListSecurityProfilesForTargetCommand = se_ListSecurityProfilesForTargetCommand;
const se_ListStreamsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        isAscendingOrder: [() => input.ascendingOrder !== void 0, () => input.ascendingOrder.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListStreamsCommand = se_ListStreamsCommand;
const se_ListTagsForResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
    const query = (0, smithy_client_1.map)({
        resourceArn: [, (0, smithy_client_1.expectNonNull)(input.resourceArn, `resourceArn`)],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_ListTargetsForPolicyCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/policy-targets/{policyName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    const query = (0, smithy_client_1.map)({
        marker: [, input.marker],
        pageSize: [() => input.pageSize !== void 0, () => input.pageSize.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListTargetsForPolicyCommand = se_ListTargetsForPolicyCommand;
const se_ListTargetsForSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/security-profiles/{securityProfileName}/targets";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListTargetsForSecurityProfileCommand = se_ListTargetsForSecurityProfileCommand;
const se_ListThingGroupsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        parentGroup: [, input.parentGroup],
        namePrefixFilter: [, input.namePrefixFilter],
        recursive: [() => input.recursive !== void 0, () => input.recursive.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingGroupsCommand = se_ListThingGroupsCommand;
const se_ListThingGroupsForThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/thing-groups";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingGroupsForThingCommand = se_ListThingGroupsForThingCommand;
const se_ListThingPrincipalsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}/principals";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingPrincipalsCommand = se_ListThingPrincipalsCommand;
const se_ListThingRegistrationTaskReportsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/thing-registration-tasks/{taskId}/reports";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    const query = (0, smithy_client_1.map)({
        reportType: [, (0, smithy_client_1.expectNonNull)(input.reportType, `reportType`)],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingRegistrationTaskReportsCommand = se_ListThingRegistrationTaskReportsCommand;
const se_ListThingRegistrationTasksCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        status: [, input.status],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingRegistrationTasksCommand = se_ListThingRegistrationTasksCommand;
const se_ListThingsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        attributeName: [, input.attributeName],
        attributeValue: [, input.attributeValue],
        thingTypeName: [, input.thingTypeName],
        usePrefixAttributeValue: [
            () => input.usePrefixAttributeValue !== void 0,
            () => input.usePrefixAttributeValue.toString(),
        ],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingsCommand = se_ListThingsCommand;
const se_ListThingsInBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}/things";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingsInBillingGroupCommand = se_ListThingsInBillingGroupCommand;
const se_ListThingsInThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}/things";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    const query = (0, smithy_client_1.map)({
        recursive: [() => input.recursive !== void 0, () => input.recursive.toString()],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingsInThingGroupCommand = se_ListThingsInThingGroupCommand;
const se_ListThingTypesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-types";
    const query = (0, smithy_client_1.map)({
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        thingTypeName: [, input.thingTypeName],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListThingTypesCommand = se_ListThingTypesCommand;
const se_ListTopicRuleDestinationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
    const query = (0, smithy_client_1.map)({
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListTopicRuleDestinationsCommand = se_ListTopicRuleDestinationsCommand;
const se_ListTopicRulesCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules";
    const query = (0, smithy_client_1.map)({
        topic: [, input.topic],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
        nextToken: [, input.nextToken],
        ruleDisabled: [() => input.ruleDisabled !== void 0, () => input.ruleDisabled.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListTopicRulesCommand = se_ListTopicRulesCommand;
const se_ListV2LoggingLevelsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
    const query = (0, smithy_client_1.map)({
        targetType: [, input.targetType],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListV2LoggingLevelsCommand = se_ListV2LoggingLevelsCommand;
const se_ListViolationEventsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/violation-events";
    const query = (0, smithy_client_1.map)({
        startTime: [
            (0, smithy_client_1.expectNonNull)(input.startTime, `startTime`) != null,
            () => (input.startTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        endTime: [
            (0, smithy_client_1.expectNonNull)(input.endTime, `endTime`) != null,
            () => (input.endTime.toISOString().split(".")[0] + "Z").toString(),
        ],
        thingName: [, input.thingName],
        securityProfileName: [, input.securityProfileName],
        behaviorCriteriaType: [, input.behaviorCriteriaType],
        listSuppressedAlerts: [() => input.listSuppressedAlerts !== void 0, () => input.listSuppressedAlerts.toString()],
        verificationState: [, input.verificationState],
        nextToken: [, input.nextToken],
        maxResults: [() => input.maxResults !== void 0, () => input.maxResults.toString()],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_ListViolationEventsCommand = se_ListViolationEventsCommand;
const se_PutVerificationStateOnViolationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/violations/verification-state/{violationId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "violationId", () => input.violationId, "{violationId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        verificationState: [],
        verificationStateDescription: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_PutVerificationStateOnViolationCommand = se_PutVerificationStateOnViolationCommand;
const se_RegisterCACertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate";
    const query = (0, smithy_client_1.map)({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
        allowAutoRegistration: [
            () => input.allowAutoRegistration !== void 0,
            () => input.allowAutoRegistration.toString(),
        ],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        caCertificate: [],
        certificateMode: [],
        registrationConfig: (_) => (0, smithy_client_1._json)(_),
        tags: (_) => (0, smithy_client_1._json)(_),
        verificationCertificate: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_RegisterCACertificateCommand = se_RegisterCACertificateCommand;
const se_RegisterCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificate/register";
    const query = (0, smithy_client_1.map)({
        setAsActive: [() => input.setAsActive !== void 0, () => input.setAsActive.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        caCertificatePem: [],
        certificatePem: [],
        status: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_RegisterCertificateCommand = se_RegisterCertificateCommand;
const se_RegisterCertificateWithoutCACommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificate/register-no-ca";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        certificatePem: [],
        status: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RegisterCertificateWithoutCACommand = se_RegisterCertificateWithoutCACommand;
const se_RegisterThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        parameters: (_) => (0, smithy_client_1._json)(_),
        templateBody: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RegisterThingCommand = se_RegisterThingCommand;
const se_RejectCertificateTransferCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/reject-certificate-transfer/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        rejectReason: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RejectCertificateTransferCommand = se_RejectCertificateTransferCommand;
const se_RemoveThingFromBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/billing-groups/removeThingFromBillingGroup";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        billingGroupArn: [],
        billingGroupName: [],
        thingArn: [],
        thingName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RemoveThingFromBillingGroupCommand = se_RemoveThingFromBillingGroupCommand;
const se_RemoveThingFromThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/removeThingFromThingGroup";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        thingArn: [],
        thingGroupArn: [],
        thingGroupName: [],
        thingName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_RemoveThingFromThingGroupCommand = se_RemoveThingFromThingGroupCommand;
const se_ReplaceTopicRuleCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/rules/{ruleName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "ruleName", () => input.ruleName, "{ruleName}", false);
    let body;
    if (input.topicRulePayload !== undefined) {
        body = (0, smithy_client_1._json)(input.topicRulePayload);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ReplaceTopicRuleCommand = se_ReplaceTopicRuleCommand;
const se_SearchIndexCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indices/search";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        indexName: [],
        maxResults: [],
        nextToken: [],
        queryString: [],
        queryVersion: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_SearchIndexCommand = se_SearchIndexCommand;
const se_SetDefaultAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/default-authorizer";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authorizerName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_SetDefaultAuthorizerCommand = se_SetDefaultAuthorizerCommand;
const se_SetDefaultPolicyVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/policies/{policyName}/version/{policyVersionId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyName", () => input.policyName, "{policyName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "policyVersionId", () => input.policyVersionId, "{policyVersionId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_SetDefaultPolicyVersionCommand = se_SetDefaultPolicyVersionCommand;
const se_SetLoggingOptionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/loggingOptions";
    let body;
    if (input.loggingOptionsPayload !== undefined) {
        body = (0, smithy_client_1._json)(input.loggingOptionsPayload);
    }
    if (body === undefined) {
        body = {};
    }
    body = JSON.stringify(body);
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_SetLoggingOptionsCommand = se_SetLoggingOptionsCommand;
const se_SetV2LoggingLevelCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingLevel";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        logLevel: [],
        logTarget: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_SetV2LoggingLevelCommand = se_SetV2LoggingLevelCommand;
const se_SetV2LoggingOptionsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/v2LoggingOptions";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        defaultLogLevel: [],
        disableAllLogs: [],
        roleArn: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_SetV2LoggingOptionsCommand = se_SetV2LoggingOptionsCommand;
const se_StartAuditMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/mitigationactions/tasks/{taskId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        auditCheckToActionsMapping: (_) => (0, smithy_client_1._json)(_),
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        target: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_StartAuditMitigationActionsTaskCommand = se_StartAuditMitigationActionsTaskCommand;
const se_StartDetectMitigationActionsTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/detect/mitigationactions/tasks/{taskId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        actions: (_) => (0, smithy_client_1._json)(_),
        clientRequestToken: [true, (_) => _ ?? (0, uuid_1.v4)()],
        includeOnlyActiveViolations: [],
        includeSuppressedAlerts: [],
        target: (_) => (0, smithy_client_1._json)(_),
        violationEventOccurrenceRange: (_) => se_ViolationEventOccurrenceRange(_, context),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_StartDetectMitigationActionsTaskCommand = se_StartDetectMitigationActionsTaskCommand;
const se_StartOnDemandAuditTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/tasks";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        targetCheckNames: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_StartOnDemandAuditTaskCommand = se_StartOnDemandAuditTaskCommand;
const se_StartThingRegistrationTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        inputFileBucket: [],
        inputFileKey: [],
        roleArn: [],
        templateBody: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_StartThingRegistrationTaskCommand = se_StartThingRegistrationTaskCommand;
const se_StopThingRegistrationTaskCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-registration-tasks/{taskId}/cancel";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "taskId", () => input.taskId, "{taskId}", false);
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_StopThingRegistrationTaskCommand = se_StopThingRegistrationTaskCommand;
const se_TagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/tags";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        resourceArn: [],
        tags: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_TestAuthorizationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/test-authorization";
    const query = (0, smithy_client_1.map)({
        clientId: [, input.clientId],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authInfos: (_) => (0, smithy_client_1._json)(_),
        cognitoIdentityPoolId: [],
        policyNamesToAdd: (_) => (0, smithy_client_1._json)(_),
        policyNamesToSkip: (_) => (0, smithy_client_1._json)(_),
        principal: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_TestAuthorizationCommand = se_TestAuthorizationCommand;
const se_TestInvokeAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}/test";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        httpContext: (_) => (0, smithy_client_1._json)(_),
        mqttContext: (_) => se_MqttContext(_, context),
        tlsContext: (_) => (0, smithy_client_1._json)(_),
        token: [],
        tokenSignature: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_TestInvokeAuthorizerCommand = se_TestInvokeAuthorizerCommand;
const se_TransferCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/transfer-certificate/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = (0, smithy_client_1.map)({
        targetAwsAccount: [, (0, smithy_client_1.expectNonNull)(input.targetAwsAccount, `targetAwsAccount`)],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        transferMessage: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_TransferCertificateCommand = se_TransferCertificateCommand;
const se_UntagResourceCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/untag";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        resourceArn: [],
        tagKeys: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateAccountAuditConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/configuration";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        auditCheckConfigurations: (_) => (0, smithy_client_1._json)(_),
        auditNotificationTargetConfigurations: (_) => (0, smithy_client_1._json)(_),
        roleArn: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateAccountAuditConfigurationCommand = se_UpdateAccountAuditConfigurationCommand;
const se_UpdateAuditSuppressionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/audit/suppressions/update";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        checkName: [],
        description: [],
        expirationDate: (_) => Math.round(_.getTime() / 1000),
        resourceIdentifier: (_) => (0, smithy_client_1._json)(_),
        suppressIndefinitely: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateAuditSuppressionCommand = se_UpdateAuditSuppressionCommand;
const se_UpdateAuthorizerCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/authorizer/{authorizerName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "authorizerName", () => input.authorizerName, "{authorizerName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authorizerFunctionArn: [],
        enableCachingForHttp: [],
        status: [],
        tokenKeyName: [],
        tokenSigningPublicKeys: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateAuthorizerCommand = se_UpdateAuthorizerCommand;
const se_UpdateBillingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/billing-groups/{billingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "billingGroupName", () => input.billingGroupName, "{billingGroupName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        billingGroupProperties: (_) => (0, smithy_client_1._json)(_),
        expectedVersion: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateBillingGroupCommand = se_UpdateBillingGroupCommand;
const se_UpdateCACertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/cacertificate/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = (0, smithy_client_1.map)({
        newStatus: [, input.newStatus],
        newAutoRegistrationStatus: [, input.newAutoRegistrationStatus],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        registrationConfig: (_) => (0, smithy_client_1._json)(_),
        removeAutoRegistration: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UpdateCACertificateCommand = se_UpdateCACertificateCommand;
const se_UpdateCertificateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {};
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/certificates/{certificateId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "certificateId", () => input.certificateId, "{certificateId}", false);
    const query = (0, smithy_client_1.map)({
        newStatus: [, (0, smithy_client_1.expectNonNull)(input.newStatus, `newStatus`)],
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UpdateCertificateCommand = se_UpdateCertificateCommand;
const se_UpdateCustomMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/custom-metric/{metricName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        displayName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateCustomMetricCommand = se_UpdateCustomMetricCommand;
const se_UpdateDimensionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dimensions/{name}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "name", () => input.name, "{name}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        stringValues: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDimensionCommand = se_UpdateDimensionCommand;
const se_UpdateDomainConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/domainConfigurations/{domainConfigurationName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "domainConfigurationName", () => input.domainConfigurationName, "{domainConfigurationName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        authorizerConfig: (_) => (0, smithy_client_1._json)(_),
        domainConfigurationStatus: [],
        removeAuthorizerConfig: [],
        tlsConfig: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDomainConfigurationCommand = se_UpdateDomainConfigurationCommand;
const se_UpdateDynamicThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/dynamic-thing-groups/{thingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        expectedVersion: [],
        indexName: [],
        queryString: [],
        queryVersion: [],
        thingGroupProperties: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateDynamicThingGroupCommand = se_UpdateDynamicThingGroupCommand;
const se_UpdateEventConfigurationsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/event-configurations";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        eventConfigurations: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateEventConfigurationsCommand = se_UpdateEventConfigurationsCommand;
const se_UpdateFleetMetricCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/fleet-metric/{metricName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "metricName", () => input.metricName, "{metricName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        aggregationField: [],
        aggregationType: (_) => (0, smithy_client_1._json)(_),
        description: [],
        expectedVersion: [],
        indexName: [],
        period: [],
        queryString: [],
        queryVersion: [],
        unit: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateFleetMetricCommand = se_UpdateFleetMetricCommand;
const se_UpdateIndexingConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/indexing/config";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        thingGroupIndexingConfiguration: (_) => (0, smithy_client_1._json)(_),
        thingIndexingConfiguration: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateIndexingConfigurationCommand = se_UpdateIndexingConfigurationCommand;
const se_UpdateJobCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/jobs/{jobId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "jobId", () => input.jobId, "{jobId}", false);
    const query = (0, smithy_client_1.map)({
        namespaceId: [, input.namespaceId],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        abortConfig: (_) => se_AbortConfig(_, context),
        description: [],
        jobExecutionsRetryConfig: (_) => (0, smithy_client_1._json)(_),
        jobExecutionsRolloutConfig: (_) => se_JobExecutionsRolloutConfig(_, context),
        presignedUrlConfig: (_) => (0, smithy_client_1._json)(_),
        timeoutConfig: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UpdateJobCommand = se_UpdateJobCommand;
const se_UpdateMitigationActionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/mitigationactions/actions/{actionName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "actionName", () => input.actionName, "{actionName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        actionParams: (_) => (0, smithy_client_1._json)(_),
        roleArn: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateMitigationActionCommand = se_UpdateMitigationActionCommand;
const se_UpdatePackageCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/packages/{packageName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    const query = (0, smithy_client_1.map)({
        clientToken: [, input.clientToken ?? (0, uuid_1.v4)()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        defaultVersionName: [],
        description: [],
        unsetDefaultVersion: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UpdatePackageCommand = se_UpdatePackageCommand;
const se_UpdatePackageConfigurationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/package-configuration";
    const query = (0, smithy_client_1.map)({
        clientToken: [, input.clientToken ?? (0, uuid_1.v4)()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        versionUpdateByJobsConfig: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UpdatePackageConfigurationCommand = se_UpdatePackageConfigurationCommand;
const se_UpdatePackageVersionCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/packages/{packageName}/versions/{versionName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "packageName", () => input.packageName, "{packageName}", false);
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "versionName", () => input.versionName, "{versionName}", false);
    const query = (0, smithy_client_1.map)({
        clientToken: [, input.clientToken ?? (0, uuid_1.v4)()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        action: [],
        attributes: (_) => (0, smithy_client_1._json)(_),
        description: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UpdatePackageVersionCommand = se_UpdatePackageVersionCommand;
const se_UpdateProvisioningTemplateCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/provisioning-templates/{templateName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "templateName", () => input.templateName, "{templateName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        defaultVersionId: [],
        description: [],
        enabled: [],
        preProvisioningHook: (_) => (0, smithy_client_1._json)(_),
        provisioningRoleArn: [],
        removePreProvisioningHook: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateProvisioningTemplateCommand = se_UpdateProvisioningTemplateCommand;
const se_UpdateRoleAliasCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/role-aliases/{roleAlias}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "roleAlias", () => input.roleAlias, "{roleAlias}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        credentialDurationSeconds: [],
        roleArn: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateRoleAliasCommand = se_UpdateRoleAliasCommand;
const se_UpdateScheduledAuditCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` +
        "/audit/scheduledaudits/{scheduledAuditName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "scheduledAuditName", () => input.scheduledAuditName, "{scheduledAuditName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        dayOfMonth: [],
        dayOfWeek: [],
        frequency: [],
        targetCheckNames: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateScheduledAuditCommand = se_UpdateScheduledAuditCommand;
const se_UpdateSecurityProfileCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profiles/{securityProfileName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "securityProfileName", () => input.securityProfileName, "{securityProfileName}", false);
    const query = (0, smithy_client_1.map)({
        expectedVersion: [() => input.expectedVersion !== void 0, () => input.expectedVersion.toString()],
    });
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        additionalMetricsToRetain: (_) => (0, smithy_client_1._json)(_),
        additionalMetricsToRetainV2: (_) => (0, smithy_client_1._json)(_),
        alertTargets: (_) => (0, smithy_client_1._json)(_),
        behaviors: (_) => se_Behaviors(_, context),
        deleteAdditionalMetricsToRetain: [],
        deleteAlertTargets: [],
        deleteBehaviors: [],
        securityProfileDescription: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        query,
        body,
    });
};
exports.se_UpdateSecurityProfileCommand = se_UpdateSecurityProfileCommand;
const se_UpdateStreamCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/streams/{streamId}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "streamId", () => input.streamId, "{streamId}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        description: [],
        files: (_) => (0, smithy_client_1._json)(_),
        roleArn: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateStreamCommand = se_UpdateStreamCommand;
const se_UpdateThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/things/{thingName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingName", () => input.thingName, "{thingName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        attributePayload: (_) => (0, smithy_client_1._json)(_),
        expectedVersion: [],
        removeThingType: [],
        thingTypeName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateThingCommand = se_UpdateThingCommand;
const se_UpdateThingGroupCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    let resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/{thingGroupName}";
    resolvedPath = (0, smithy_client_1.resolvedPath)(resolvedPath, input, "thingGroupName", () => input.thingGroupName, "{thingGroupName}", false);
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        expectedVersion: [],
        thingGroupProperties: (_) => (0, smithy_client_1._json)(_),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateThingGroupCommand = se_UpdateThingGroupCommand;
const se_UpdateThingGroupsForThingCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/thing-groups/updateThingGroupsForThing";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        overrideDynamicGroups: [],
        thingGroupsToAdd: (_) => (0, smithy_client_1._json)(_),
        thingGroupsToRemove: (_) => (0, smithy_client_1._json)(_),
        thingName: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PUT",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateThingGroupsForThingCommand = se_UpdateThingGroupsForThingCommand;
const se_UpdateTopicRuleDestinationCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/destinations";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        arn: [],
        status: [],
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "PATCH",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_UpdateTopicRuleDestinationCommand = se_UpdateTopicRuleDestinationCommand;
const se_ValidateSecurityProfileBehaviorsCommand = async (input, context) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json",
    };
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/security-profile-behaviors/validate";
    let body;
    body = JSON.stringify((0, smithy_client_1.take)(input, {
        behaviors: (_) => se_Behaviors(_, context),
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body,
    });
};
exports.se_ValidateSecurityProfileBehaviorsCommand = se_ValidateSecurityProfileBehaviorsCommand;
const de_AcceptCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AcceptCertificateTransferCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AcceptCertificateTransferCommand = de_AcceptCertificateTransferCommand;
const de_AcceptCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await de_TransferAlreadyCompletedExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AddThingToBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AddThingToBillingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AddThingToBillingGroupCommand = de_AddThingToBillingGroupCommand;
const de_AddThingToBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AddThingToThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AddThingToThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AddThingToThingGroupCommand = de_AddThingToThingGroupCommand;
const de_AddThingToThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AssociateTargetsWithJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AssociateTargetsWithJobCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        jobArn: smithy_client_1.expectString,
        jobId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_AssociateTargetsWithJobCommand = de_AssociateTargetsWithJobCommand;
const de_AssociateTargetsWithJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AttachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AttachPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AttachPolicyCommand = de_AttachPolicyCommand;
const de_AttachPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AttachPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AttachPrincipalPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AttachPrincipalPolicyCommand = de_AttachPrincipalPolicyCommand;
const de_AttachPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AttachSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AttachSecurityProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AttachSecurityProfileCommand = de_AttachSecurityProfileCommand;
const de_AttachSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_AttachThingPrincipalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_AttachThingPrincipalCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_AttachThingPrincipalCommand = de_AttachThingPrincipalCommand;
const de_AttachThingPrincipalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CancelAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_CancelAuditMitigationActionsTaskCommand = de_CancelAuditMitigationActionsTaskCommand;
const de_CancelAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CancelAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelAuditTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_CancelAuditTaskCommand = de_CancelAuditTaskCommand;
const de_CancelAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CancelCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelCertificateTransferCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_CancelCertificateTransferCommand = de_CancelCertificateTransferCommand;
const de_CancelCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await de_TransferAlreadyCompletedExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CancelDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_CancelDetectMitigationActionsTaskCommand = de_CancelDetectMitigationActionsTaskCommand;
const de_CancelDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CancelJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelJobCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        jobArn: smithy_client_1.expectString,
        jobId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CancelJobCommand = de_CancelJobCommand;
const de_CancelJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CancelJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CancelJobExecutionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_CancelJobExecutionCommand = de_CancelJobExecutionCommand;
const de_CancelJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await de_InvalidStateTransitionExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ClearDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ClearDefaultAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_ClearDefaultAuthorizerCommand = de_ClearDefaultAuthorizerCommand;
const de_ClearDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ConfirmTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ConfirmTopicRuleDestinationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_ConfirmTopicRuleDestinationCommand = de_ConfirmTopicRuleDestinationCommand;
const de_ConfirmTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAuditSuppressionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_CreateAuditSuppressionCommand = de_CreateAuditSuppressionCommand;
const de_CreateAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorizerArn: smithy_client_1.expectString,
        authorizerName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateAuthorizerCommand = de_CreateAuthorizerCommand;
const de_CreateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateBillingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        billingGroupArn: smithy_client_1.expectString,
        billingGroupId: smithy_client_1.expectString,
        billingGroupName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateBillingGroupCommand = de_CreateBillingGroupCommand;
const de_CreateBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateCertificateFromCsrCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateCertificateFromCsrCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
        certificatePem: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateCertificateFromCsrCommand = de_CreateCertificateFromCsrCommand;
const de_CreateCertificateFromCsrCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateCustomMetricCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        metricArn: smithy_client_1.expectString,
        metricName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateCustomMetricCommand = de_CreateCustomMetricCommand;
const de_CreateCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateDimensionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        arn: smithy_client_1.expectString,
        name: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDimensionCommand = de_CreateDimensionCommand;
const de_CreateDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateDomainConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        domainConfigurationArn: smithy_client_1.expectString,
        domainConfigurationName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDomainConfigurationCommand = de_CreateDomainConfigurationCommand;
const de_CreateDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateDynamicThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        indexName: smithy_client_1.expectString,
        queryString: smithy_client_1.expectString,
        queryVersion: smithy_client_1.expectString,
        thingGroupArn: smithy_client_1.expectString,
        thingGroupId: smithy_client_1.expectString,
        thingGroupName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateDynamicThingGroupCommand = de_CreateDynamicThingGroupCommand;
const de_CreateDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateFleetMetricCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        metricArn: smithy_client_1.expectString,
        metricName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateFleetMetricCommand = de_CreateFleetMetricCommand;
const de_CreateFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateJobCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        jobArn: smithy_client_1.expectString,
        jobId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateJobCommand = de_CreateJobCommand;
const de_CreateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateJobTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        jobTemplateArn: smithy_client_1.expectString,
        jobTemplateId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateJobTemplateCommand = de_CreateJobTemplateCommand;
const de_CreateJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateKeysAndCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateKeysAndCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
        certificatePem: smithy_client_1.expectString,
        keyPair: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateKeysAndCertificateCommand = de_CreateKeysAndCertificateCommand;
const de_CreateKeysAndCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateMitigationActionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        actionArn: smithy_client_1.expectString,
        actionId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateMitigationActionCommand = de_CreateMitigationActionCommand;
const de_CreateMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateOTAUpdateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        awsIotJobArn: smithy_client_1.expectString,
        awsIotJobId: smithy_client_1.expectString,
        otaUpdateArn: smithy_client_1.expectString,
        otaUpdateId: smithy_client_1.expectString,
        otaUpdateStatus: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateOTAUpdateCommand = de_CreateOTAUpdateCommand;
const de_CreateOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreatePackageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        packageArn: smithy_client_1.expectString,
        packageName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreatePackageCommand = de_CreatePackageCommand;
const de_CreatePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.iot#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreatePackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreatePackageVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        attributes: smithy_client_1._json,
        description: smithy_client_1.expectString,
        errorReason: smithy_client_1.expectString,
        packageName: smithy_client_1.expectString,
        packageVersionArn: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        versionName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreatePackageVersionCommand = de_CreatePackageVersionCommand;
const de_CreatePackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.iot#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ServiceQuotaExceededException":
        case "com.amazonaws.iot#ServiceQuotaExceededException":
            throw await de_ServiceQuotaExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreatePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreatePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        policyArn: smithy_client_1.expectString,
        policyDocument: smithy_client_1.expectString,
        policyName: smithy_client_1.expectString,
        policyVersionId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreatePolicyCommand = de_CreatePolicyCommand;
const de_CreatePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "MalformedPolicyException":
        case "com.amazonaws.iot#MalformedPolicyException":
            throw await de_MalformedPolicyExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreatePolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreatePolicyVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        isDefaultVersion: smithy_client_1.expectBoolean,
        policyArn: smithy_client_1.expectString,
        policyDocument: smithy_client_1.expectString,
        policyVersionId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreatePolicyVersionCommand = de_CreatePolicyVersionCommand;
const de_CreatePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "MalformedPolicyException":
        case "com.amazonaws.iot#MalformedPolicyException":
            throw await de_MalformedPolicyExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionsLimitExceededException":
        case "com.amazonaws.iot#VersionsLimitExceededException":
            throw await de_VersionsLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateProvisioningClaimCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateProvisioningClaimCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateId: smithy_client_1.expectString,
        certificatePem: smithy_client_1.expectString,
        expiration: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        keyPair: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateProvisioningClaimCommand = de_CreateProvisioningClaimCommand;
const de_CreateProvisioningClaimCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateProvisioningTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        defaultVersionId: smithy_client_1.expectInt32,
        templateArn: smithy_client_1.expectString,
        templateName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateProvisioningTemplateCommand = de_CreateProvisioningTemplateCommand;
const de_CreateProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        isDefaultVersion: smithy_client_1.expectBoolean,
        templateArn: smithy_client_1.expectString,
        templateName: smithy_client_1.expectString,
        versionId: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateProvisioningTemplateVersionCommand = de_CreateProvisioningTemplateVersionCommand;
const de_CreateProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionsLimitExceededException":
        case "com.amazonaws.iot#VersionsLimitExceededException":
            throw await de_VersionsLimitExceededExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateRoleAliasCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        roleAlias: smithy_client_1.expectString,
        roleAliasArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateRoleAliasCommand = de_CreateRoleAliasCommand;
const de_CreateRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateScheduledAuditCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        scheduledAuditArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateScheduledAuditCommand = de_CreateScheduledAuditCommand;
const de_CreateScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateSecurityProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        securityProfileArn: smithy_client_1.expectString,
        securityProfileName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateSecurityProfileCommand = de_CreateSecurityProfileCommand;
const de_CreateSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateStreamCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        streamArn: smithy_client_1.expectString,
        streamId: smithy_client_1.expectString,
        streamVersion: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateStreamCommand = de_CreateStreamCommand;
const de_CreateStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateThingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        thingArn: smithy_client_1.expectString,
        thingId: smithy_client_1.expectString,
        thingName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateThingCommand = de_CreateThingCommand;
const de_CreateThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        thingGroupArn: smithy_client_1.expectString,
        thingGroupId: smithy_client_1.expectString,
        thingGroupName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateThingGroupCommand = de_CreateThingGroupCommand;
const de_CreateThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateThingTypeCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        thingTypeArn: smithy_client_1.expectString,
        thingTypeId: smithy_client_1.expectString,
        thingTypeName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateThingTypeCommand = de_CreateThingTypeCommand;
const de_CreateThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateTopicRuleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_CreateTopicRuleCommand = de_CreateTopicRuleCommand;
const de_CreateTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "SqlParseException":
        case "com.amazonaws.iot#SqlParseException":
            throw await de_SqlParseExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_CreateTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateTopicRuleDestinationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        topicRuleDestination: (_) => de_TopicRuleDestination(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_CreateTopicRuleDestinationCommand = de_CreateTopicRuleDestinationCommand;
const de_CreateTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAccountAuditConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteAccountAuditConfigurationCommand = de_DeleteAccountAuditConfigurationCommand;
const de_DeleteAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAuditSuppressionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteAuditSuppressionCommand = de_DeleteAuditSuppressionCommand;
const de_DeleteAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteAuthorizerCommand = de_DeleteAuthorizerCommand;
const de_DeleteAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteBillingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteBillingGroupCommand = de_DeleteBillingGroupCommand;
const de_DeleteBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteCACertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteCACertificateCommand = de_DeleteCACertificateCommand;
const de_DeleteCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteCertificateCommand = de_DeleteCertificateCommand;
const de_DeleteCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteCustomMetricCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteCustomMetricCommand = de_DeleteCustomMetricCommand;
const de_DeleteCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteDimensionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDimensionCommand = de_DeleteDimensionCommand;
const de_DeleteDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteDomainConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDomainConfigurationCommand = de_DeleteDomainConfigurationCommand;
const de_DeleteDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteDynamicThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteDynamicThingGroupCommand = de_DeleteDynamicThingGroupCommand;
const de_DeleteDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteFleetMetricCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteFleetMetricCommand = de_DeleteFleetMetricCommand;
const de_DeleteFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteJobCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteJobCommand = de_DeleteJobCommand;
const de_DeleteJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await de_InvalidStateTransitionExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteJobExecutionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteJobExecutionCommand = de_DeleteJobExecutionCommand;
const de_DeleteJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidStateTransitionException":
        case "com.amazonaws.iot#InvalidStateTransitionException":
            throw await de_InvalidStateTransitionExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteJobTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteJobTemplateCommand = de_DeleteJobTemplateCommand;
const de_DeleteJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteMitigationActionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteMitigationActionCommand = de_DeleteMitigationActionCommand;
const de_DeleteMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteOTAUpdateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteOTAUpdateCommand = de_DeleteOTAUpdateCommand;
const de_DeleteOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeletePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePackageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeletePackageCommand = de_DeletePackageCommand;
const de_DeletePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeletePackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePackageVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeletePackageVersionCommand = de_DeletePackageVersionCommand;
const de_DeletePackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeletePolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeletePolicyCommand = de_DeletePolicyCommand;
const de_DeletePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeletePolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeletePolicyVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeletePolicyVersionCommand = de_DeletePolicyVersionCommand;
const de_DeletePolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteProvisioningTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteProvisioningTemplateCommand = de_DeleteProvisioningTemplateCommand;
const de_DeleteProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteProvisioningTemplateVersionCommand = de_DeleteProvisioningTemplateVersionCommand;
const de_DeleteProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRegistrationCodeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteRegistrationCodeCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRegistrationCodeCommand = de_DeleteRegistrationCodeCommand;
const de_DeleteRegistrationCodeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteRoleAliasCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteRoleAliasCommand = de_DeleteRoleAliasCommand;
const de_DeleteRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteScheduledAuditCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteScheduledAuditCommand = de_DeleteScheduledAuditCommand;
const de_DeleteScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteSecurityProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteSecurityProfileCommand = de_DeleteSecurityProfileCommand;
const de_DeleteSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteStreamCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteStreamCommand = de_DeleteStreamCommand;
const de_DeleteStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "DeleteConflictException":
        case "com.amazonaws.iot#DeleteConflictException":
            throw await de_DeleteConflictExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteThingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteThingCommand = de_DeleteThingCommand;
const de_DeleteThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteThingGroupCommand = de_DeleteThingGroupCommand;
const de_DeleteThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteThingTypeCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteThingTypeCommand = de_DeleteThingTypeCommand;
const de_DeleteThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteTopicRuleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteTopicRuleCommand = de_DeleteTopicRuleCommand;
const de_DeleteTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteTopicRuleDestinationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteTopicRuleDestinationCommand = de_DeleteTopicRuleDestinationCommand;
const de_DeleteTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeleteV2LoggingLevelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeleteV2LoggingLevelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeleteV2LoggingLevelCommand = de_DeleteV2LoggingLevelCommand;
const de_DeleteV2LoggingLevelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DeprecateThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DeprecateThingTypeCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DeprecateThingTypeCommand = de_DeprecateThingTypeCommand;
const de_DeprecateThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAccountAuditConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        auditCheckConfigurations: smithy_client_1._json,
        auditNotificationTargetConfigurations: smithy_client_1._json,
        roleArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeAccountAuditConfigurationCommand = de_DescribeAccountAuditConfigurationCommand;
const de_DescribeAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeAuditFindingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuditFindingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        finding: (_) => de_AuditFinding(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeAuditFindingCommand = de_DescribeAuditFindingCommand;
const de_DescribeAuditFindingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        actionsDefinition: smithy_client_1._json,
        auditCheckToActionsMapping: smithy_client_1._json,
        endTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        startTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        target: smithy_client_1._json,
        taskStatistics: smithy_client_1._json,
        taskStatus: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeAuditMitigationActionsTaskCommand = de_DescribeAuditMitigationActionsTaskCommand;
const de_DescribeAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuditSuppressionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        checkName: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        expirationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        resourceIdentifier: smithy_client_1._json,
        suppressIndefinitely: smithy_client_1.expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeAuditSuppressionCommand = de_DescribeAuditSuppressionCommand;
const de_DescribeAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuditTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        auditDetails: smithy_client_1._json,
        scheduledAuditName: smithy_client_1.expectString,
        taskStartTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        taskStatistics: smithy_client_1._json,
        taskStatus: smithy_client_1.expectString,
        taskType: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeAuditTaskCommand = de_DescribeAuditTaskCommand;
const de_DescribeAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorizerDescription: (_) => de_AuthorizerDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeAuthorizerCommand = de_DescribeAuthorizerCommand;
const de_DescribeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeBillingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        billingGroupArn: smithy_client_1.expectString,
        billingGroupId: smithy_client_1.expectString,
        billingGroupMetadata: (_) => de_BillingGroupMetadata(_, context),
        billingGroupName: smithy_client_1.expectString,
        billingGroupProperties: smithy_client_1._json,
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeBillingGroupCommand = de_DescribeBillingGroupCommand;
const de_DescribeBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeCACertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateDescription: (_) => de_CACertificateDescription(_, context),
        registrationConfig: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeCACertificateCommand = de_DescribeCACertificateCommand;
const de_DescribeCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateDescription: (_) => de_CertificateDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeCertificateCommand = de_DescribeCertificateCommand;
const de_DescribeCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeCustomMetricCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        displayName: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        metricArn: smithy_client_1.expectString,
        metricName: smithy_client_1.expectString,
        metricType: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeCustomMetricCommand = de_DescribeCustomMetricCommand;
const de_DescribeCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeDefaultAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorizerDescription: (_) => de_AuthorizerDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeDefaultAuthorizerCommand = de_DescribeDefaultAuthorizerCommand;
const de_DescribeDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        taskSummary: (_) => de_DetectMitigationActionsTaskSummary(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeDetectMitigationActionsTaskCommand = de_DescribeDetectMitigationActionsTaskCommand;
const de_DescribeDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeDimensionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        arn: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        name: smithy_client_1.expectString,
        stringValues: smithy_client_1._json,
        type: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeDimensionCommand = de_DescribeDimensionCommand;
const de_DescribeDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeDomainConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorizerConfig: smithy_client_1._json,
        domainConfigurationArn: smithy_client_1.expectString,
        domainConfigurationName: smithy_client_1.expectString,
        domainConfigurationStatus: smithy_client_1.expectString,
        domainName: smithy_client_1.expectString,
        domainType: smithy_client_1.expectString,
        lastStatusChangeDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        serverCertificates: smithy_client_1._json,
        serviceType: smithy_client_1.expectString,
        tlsConfig: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeDomainConfigurationCommand = de_DescribeDomainConfigurationCommand;
const de_DescribeDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeEndpointCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeEndpointCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        endpointAddress: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeEndpointCommand = de_DescribeEndpointCommand;
const de_DescribeEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeEventConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeEventConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        eventConfigurations: smithy_client_1._json,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeEventConfigurationsCommand = de_DescribeEventConfigurationsCommand;
const de_DescribeEventConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeFleetMetricCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        aggregationField: smithy_client_1.expectString,
        aggregationType: smithy_client_1._json,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        indexName: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        metricArn: smithy_client_1.expectString,
        metricName: smithy_client_1.expectString,
        period: smithy_client_1.expectInt32,
        queryString: smithy_client_1.expectString,
        queryVersion: smithy_client_1.expectString,
        unit: smithy_client_1.expectString,
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeFleetMetricCommand = de_DescribeFleetMetricCommand;
const de_DescribeFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeIndexCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        indexName: smithy_client_1.expectString,
        indexStatus: smithy_client_1.expectString,
        schema: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeIndexCommand = de_DescribeIndexCommand;
const de_DescribeIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeJobCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        documentSource: smithy_client_1.expectString,
        job: (_) => de_Job(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeJobCommand = de_DescribeJobCommand;
const de_DescribeJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeJobExecutionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeJobExecutionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        execution: (_) => de_JobExecution(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeJobExecutionCommand = de_DescribeJobExecutionCommand;
const de_DescribeJobExecutionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeJobTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        abortConfig: (_) => de_AbortConfig(_, context),
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        destinationPackageVersions: smithy_client_1._json,
        document: smithy_client_1.expectString,
        documentSource: smithy_client_1.expectString,
        jobExecutionsRetryConfig: smithy_client_1._json,
        jobExecutionsRolloutConfig: (_) => de_JobExecutionsRolloutConfig(_, context),
        jobTemplateArn: smithy_client_1.expectString,
        jobTemplateId: smithy_client_1.expectString,
        maintenanceWindows: smithy_client_1._json,
        presignedUrlConfig: smithy_client_1._json,
        timeoutConfig: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeJobTemplateCommand = de_DescribeJobTemplateCommand;
const de_DescribeJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeManagedJobTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeManagedJobTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        document: smithy_client_1.expectString,
        documentParameters: smithy_client_1._json,
        environments: smithy_client_1._json,
        templateArn: smithy_client_1.expectString,
        templateName: smithy_client_1.expectString,
        templateVersion: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeManagedJobTemplateCommand = de_DescribeManagedJobTemplateCommand;
const de_DescribeManagedJobTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeMitigationActionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        actionArn: smithy_client_1.expectString,
        actionId: smithy_client_1.expectString,
        actionName: smithy_client_1.expectString,
        actionParams: smithy_client_1._json,
        actionType: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        roleArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeMitigationActionCommand = de_DescribeMitigationActionCommand;
const de_DescribeMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeProvisioningTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        defaultVersionId: smithy_client_1.expectInt32,
        description: smithy_client_1.expectString,
        enabled: smithy_client_1.expectBoolean,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        preProvisioningHook: smithy_client_1._json,
        provisioningRoleArn: smithy_client_1.expectString,
        templateArn: smithy_client_1.expectString,
        templateBody: smithy_client_1.expectString,
        templateName: smithy_client_1.expectString,
        type: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeProvisioningTemplateCommand = de_DescribeProvisioningTemplateCommand;
const de_DescribeProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeProvisioningTemplateVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeProvisioningTemplateVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        isDefaultVersion: smithy_client_1.expectBoolean,
        templateBody: smithy_client_1.expectString,
        versionId: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeProvisioningTemplateVersionCommand = de_DescribeProvisioningTemplateVersionCommand;
const de_DescribeProvisioningTemplateVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeRoleAliasCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        roleAliasDescription: (_) => de_RoleAliasDescription(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeRoleAliasCommand = de_DescribeRoleAliasCommand;
const de_DescribeRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeScheduledAuditCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        dayOfMonth: smithy_client_1.expectString,
        dayOfWeek: smithy_client_1.expectString,
        frequency: smithy_client_1.expectString,
        scheduledAuditArn: smithy_client_1.expectString,
        scheduledAuditName: smithy_client_1.expectString,
        targetCheckNames: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeScheduledAuditCommand = de_DescribeScheduledAuditCommand;
const de_DescribeScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeSecurityProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        additionalMetricsToRetain: smithy_client_1._json,
        additionalMetricsToRetainV2: smithy_client_1._json,
        alertTargets: smithy_client_1._json,
        behaviors: (_) => de_Behaviors(_, context),
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        securityProfileArn: smithy_client_1.expectString,
        securityProfileDescription: smithy_client_1.expectString,
        securityProfileName: smithy_client_1.expectString,
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeSecurityProfileCommand = de_DescribeSecurityProfileCommand;
const de_DescribeSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeStreamCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        streamInfo: (_) => de_StreamInfo(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeStreamCommand = de_DescribeStreamCommand;
const de_DescribeStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeThingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        attributes: smithy_client_1._json,
        billingGroupName: smithy_client_1.expectString,
        defaultClientId: smithy_client_1.expectString,
        thingArn: smithy_client_1.expectString,
        thingId: smithy_client_1.expectString,
        thingName: smithy_client_1.expectString,
        thingTypeName: smithy_client_1.expectString,
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeThingCommand = de_DescribeThingCommand;
const de_DescribeThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        indexName: smithy_client_1.expectString,
        queryString: smithy_client_1.expectString,
        queryVersion: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        thingGroupArn: smithy_client_1.expectString,
        thingGroupId: smithy_client_1.expectString,
        thingGroupMetadata: (_) => de_ThingGroupMetadata(_, context),
        thingGroupName: smithy_client_1.expectString,
        thingGroupProperties: smithy_client_1._json,
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeThingGroupCommand = de_DescribeThingGroupCommand;
const de_DescribeThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeThingRegistrationTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        failureCount: smithy_client_1.expectInt32,
        inputFileBucket: smithy_client_1.expectString,
        inputFileKey: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        message: smithy_client_1.expectString,
        percentageProgress: smithy_client_1.expectInt32,
        roleArn: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        successCount: smithy_client_1.expectInt32,
        taskId: smithy_client_1.expectString,
        templateBody: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeThingRegistrationTaskCommand = de_DescribeThingRegistrationTaskCommand;
const de_DescribeThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DescribeThingTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DescribeThingTypeCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        thingTypeArn: smithy_client_1.expectString,
        thingTypeId: smithy_client_1.expectString,
        thingTypeMetadata: (_) => de_ThingTypeMetadata(_, context),
        thingTypeName: smithy_client_1.expectString,
        thingTypeProperties: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_DescribeThingTypeCommand = de_DescribeThingTypeCommand;
const de_DescribeThingTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DetachPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DetachPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DetachPolicyCommand = de_DetachPolicyCommand;
const de_DetachPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DetachPrincipalPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DetachPrincipalPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DetachPrincipalPolicyCommand = de_DetachPrincipalPolicyCommand;
const de_DetachPrincipalPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DetachSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DetachSecurityProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DetachSecurityProfileCommand = de_DetachSecurityProfileCommand;
const de_DetachSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DetachThingPrincipalCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DetachThingPrincipalCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DetachThingPrincipalCommand = de_DetachThingPrincipalCommand;
const de_DetachThingPrincipalCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_DisableTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_DisableTopicRuleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_DisableTopicRuleCommand = de_DisableTopicRuleCommand;
const de_DisableTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_EnableTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_EnableTopicRuleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_EnableTopicRuleCommand = de_EnableTopicRuleCommand;
const de_EnableTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetBehaviorModelTrainingSummariesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBehaviorModelTrainingSummariesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        summaries: (_) => de_BehaviorModelTrainingSummaries(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetBehaviorModelTrainingSummariesCommand = de_GetBehaviorModelTrainingSummariesCommand;
const de_GetBehaviorModelTrainingSummariesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetBucketsAggregationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetBucketsAggregationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        buckets: smithy_client_1._json,
        totalCount: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetBucketsAggregationCommand = de_GetBucketsAggregationCommand;
const de_GetBucketsAggregationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetCardinalityCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetCardinalityCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        cardinality: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetCardinalityCommand = de_GetCardinalityCommand;
const de_GetCardinalityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetEffectivePoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetEffectivePoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        effectivePolicies: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetEffectivePoliciesCommand = de_GetEffectivePoliciesCommand;
const de_GetEffectivePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetIndexingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetIndexingConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        thingGroupIndexingConfiguration: smithy_client_1._json,
        thingIndexingConfiguration: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetIndexingConfigurationCommand = de_GetIndexingConfigurationCommand;
const de_GetIndexingConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetJobDocumentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetJobDocumentCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        document: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetJobDocumentCommand = de_GetJobDocumentCommand;
const de_GetJobDocumentCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetLoggingOptionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        logLevel: smithy_client_1.expectString,
        roleArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetLoggingOptionsCommand = de_GetLoggingOptionsCommand;
const de_GetLoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetOTAUpdateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetOTAUpdateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        otaUpdateInfo: (_) => de_OTAUpdateInfo(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetOTAUpdateCommand = de_GetOTAUpdateCommand;
const de_GetOTAUpdateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPackageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        defaultVersionName: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        packageArn: smithy_client_1.expectString,
        packageName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetPackageCommand = de_GetPackageCommand;
const de_GetPackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPackageConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPackageConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        versionUpdateByJobsConfig: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetPackageConfigurationCommand = de_GetPackageConfigurationCommand;
const de_GetPackageConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPackageVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        attributes: smithy_client_1._json,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        errorReason: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        packageName: smithy_client_1.expectString,
        packageVersionArn: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        versionName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetPackageVersionCommand = de_GetPackageVersionCommand;
const de_GetPackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPercentilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPercentilesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        percentiles: (_) => de_Percentiles(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetPercentilesCommand = de_GetPercentilesCommand;
const de_GetPercentilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        defaultVersionId: smithy_client_1.expectString,
        generationId: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        policyArn: smithy_client_1.expectString,
        policyDocument: smithy_client_1.expectString,
        policyName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetPolicyCommand = de_GetPolicyCommand;
const de_GetPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetPolicyVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        generationId: smithy_client_1.expectString,
        isDefaultVersion: smithy_client_1.expectBoolean,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        policyArn: smithy_client_1.expectString,
        policyDocument: smithy_client_1.expectString,
        policyName: smithy_client_1.expectString,
        policyVersionId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetPolicyVersionCommand = de_GetPolicyVersionCommand;
const de_GetPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetRegistrationCodeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRegistrationCodeCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        registrationCode: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRegistrationCodeCommand = de_GetRegistrationCodeCommand;
const de_GetRegistrationCodeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetStatisticsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetStatisticsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        statistics: (_) => de_Statistics(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetStatisticsCommand = de_GetStatisticsCommand;
const de_GetStatisticsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTopicRuleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        rule: (_) => de_TopicRule(_, context),
        ruleArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetTopicRuleCommand = de_GetTopicRuleCommand;
const de_GetTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetTopicRuleDestinationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        topicRuleDestination: (_) => de_TopicRuleDestination(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetTopicRuleDestinationCommand = de_GetTopicRuleDestinationCommand;
const de_GetTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_GetV2LoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetV2LoggingOptionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        defaultLogLevel: smithy_client_1.expectString,
        disableAllLogs: smithy_client_1.expectBoolean,
        roleArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetV2LoggingOptionsCommand = de_GetV2LoggingOptionsCommand;
const de_GetV2LoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await de_NotConfiguredExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListActiveViolationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListActiveViolationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        activeViolations: (_) => de_ActiveViolations(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListActiveViolationsCommand = de_ListActiveViolationsCommand;
const de_ListActiveViolationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAttachedPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAttachedPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextMarker: smithy_client_1.expectString,
        policies: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAttachedPoliciesCommand = de_ListAttachedPoliciesCommand;
const de_ListAttachedPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAuditFindingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditFindingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        findings: (_) => de_AuditFindings(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAuditFindingsCommand = de_ListAuditFindingsCommand;
const de_ListAuditFindingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAuditMitigationActionsExecutionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditMitigationActionsExecutionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        actionsExecutions: (_) => de_AuditMitigationActionExecutionMetadataList(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAuditMitigationActionsExecutionsCommand = de_ListAuditMitigationActionsExecutionsCommand;
const de_ListAuditMitigationActionsExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAuditMitigationActionsTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditMitigationActionsTasksCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        tasks: (_) => de_AuditMitigationActionsTaskMetadataList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAuditMitigationActionsTasksCommand = de_ListAuditMitigationActionsTasksCommand;
const de_ListAuditMitigationActionsTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAuditSuppressionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditSuppressionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        suppressions: (_) => de_AuditSuppressionList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAuditSuppressionsCommand = de_ListAuditSuppressionsCommand;
const de_ListAuditSuppressionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAuditTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuditTasksCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        tasks: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAuditTasksCommand = de_ListAuditTasksCommand;
const de_ListAuditTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAuthorizersCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorizers: smithy_client_1._json,
        nextMarker: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAuthorizersCommand = de_ListAuthorizersCommand;
const de_ListAuthorizersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListBillingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListBillingGroupsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        billingGroups: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListBillingGroupsCommand = de_ListBillingGroupsCommand;
const de_ListBillingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListCACertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCACertificatesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificates: (_) => de_CACertificates(_, context),
        nextMarker: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListCACertificatesCommand = de_ListCACertificatesCommand;
const de_ListCACertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCertificatesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificates: (_) => de_Certificates(_, context),
        nextMarker: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListCertificatesCommand = de_ListCertificatesCommand;
const de_ListCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListCertificatesByCACommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCertificatesByCACommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificates: (_) => de_Certificates(_, context),
        nextMarker: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListCertificatesByCACommand = de_ListCertificatesByCACommand;
const de_ListCertificatesByCACommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListCustomMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListCustomMetricsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        metricNames: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListCustomMetricsCommand = de_ListCustomMetricsCommand;
const de_ListCustomMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDetectMitigationActionsExecutionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDetectMitigationActionsExecutionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        actionsExecutions: (_) => de_DetectMitigationActionExecutionList(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListDetectMitigationActionsExecutionsCommand = de_ListDetectMitigationActionsExecutionsCommand;
const de_ListDetectMitigationActionsExecutionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDetectMitigationActionsTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDetectMitigationActionsTasksCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        tasks: (_) => de_DetectMitigationActionsTaskSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListDetectMitigationActionsTasksCommand = de_ListDetectMitigationActionsTasksCommand;
const de_ListDetectMitigationActionsTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDimensionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDimensionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        dimensionNames: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListDimensionsCommand = de_ListDimensionsCommand;
const de_ListDimensionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListDomainConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListDomainConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        domainConfigurations: smithy_client_1._json,
        nextMarker: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListDomainConfigurationsCommand = de_ListDomainConfigurationsCommand;
const de_ListDomainConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListFleetMetricsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListFleetMetricsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        fleetMetrics: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListFleetMetricsCommand = de_ListFleetMetricsCommand;
const de_ListFleetMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListIndicesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListIndicesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        indexNames: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListIndicesCommand = de_ListIndicesCommand;
const de_ListIndicesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListJobExecutionsForJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobExecutionsForJobCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        executionSummaries: (_) => de_JobExecutionSummaryForJobList(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListJobExecutionsForJobCommand = de_ListJobExecutionsForJobCommand;
const de_ListJobExecutionsForJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListJobExecutionsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobExecutionsForThingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        executionSummaries: (_) => de_JobExecutionSummaryForThingList(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListJobExecutionsForThingCommand = de_ListJobExecutionsForThingCommand;
const de_ListJobExecutionsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListJobsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        jobs: (_) => de_JobSummaryList(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListJobsCommand = de_ListJobsCommand;
const de_ListJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListJobTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListJobTemplatesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        jobTemplates: (_) => de_JobTemplateSummaryList(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListJobTemplatesCommand = de_ListJobTemplatesCommand;
const de_ListJobTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListManagedJobTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListManagedJobTemplatesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        managedJobTemplates: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListManagedJobTemplatesCommand = de_ListManagedJobTemplatesCommand;
const de_ListManagedJobTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListMetricValuesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListMetricValuesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        metricDatumList: (_) => de_MetricDatumList(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListMetricValuesCommand = de_ListMetricValuesCommand;
const de_ListMetricValuesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListMitigationActionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListMitigationActionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        actionIdentifiers: (_) => de_MitigationActionIdentifierList(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListMitigationActionsCommand = de_ListMitigationActionsCommand;
const de_ListMitigationActionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListOTAUpdatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOTAUpdatesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        otaUpdates: (_) => de_OTAUpdatesSummary(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListOTAUpdatesCommand = de_ListOTAUpdatesCommand;
const de_ListOTAUpdatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListOutgoingCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListOutgoingCertificatesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextMarker: smithy_client_1.expectString,
        outgoingCertificates: (_) => de_OutgoingCertificates(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListOutgoingCertificatesCommand = de_ListOutgoingCertificatesCommand;
const de_ListOutgoingCertificatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListPackagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPackagesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        packageSummaries: (_) => de_PackageSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListPackagesCommand = de_ListPackagesCommand;
const de_ListPackagesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListPackageVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPackageVersionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        packageVersionSummaries: (_) => de_PackageVersionSummaryList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListPackageVersionsCommand = de_ListPackageVersionsCommand;
const de_ListPackageVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextMarker: smithy_client_1.expectString,
        policies: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListPoliciesCommand = de_ListPoliciesCommand;
const de_ListPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListPolicyPrincipalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPolicyPrincipalsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextMarker: smithy_client_1.expectString,
        principals: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListPolicyPrincipalsCommand = de_ListPolicyPrincipalsCommand;
const de_ListPolicyPrincipalsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListPolicyVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPolicyVersionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        policyVersions: (_) => de_PolicyVersions(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListPolicyVersionsCommand = de_ListPolicyVersionsCommand;
const de_ListPolicyVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListPrincipalPoliciesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPrincipalPoliciesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextMarker: smithy_client_1.expectString,
        policies: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListPrincipalPoliciesCommand = de_ListPrincipalPoliciesCommand;
const de_ListPrincipalPoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListPrincipalThingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListPrincipalThingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        things: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListPrincipalThingsCommand = de_ListPrincipalThingsCommand;
const de_ListPrincipalThingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListProvisioningTemplatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListProvisioningTemplatesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        templates: (_) => de_ProvisioningTemplateListing(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListProvisioningTemplatesCommand = de_ListProvisioningTemplatesCommand;
const de_ListProvisioningTemplatesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListProvisioningTemplateVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListProvisioningTemplateVersionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        versions: (_) => de_ProvisioningTemplateVersionListing(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListProvisioningTemplateVersionsCommand = de_ListProvisioningTemplateVersionsCommand;
const de_ListProvisioningTemplateVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListRelatedResourcesForAuditFindingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListRelatedResourcesForAuditFindingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        relatedResources: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListRelatedResourcesForAuditFindingCommand = de_ListRelatedResourcesForAuditFindingCommand;
const de_ListRelatedResourcesForAuditFindingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListRoleAliasesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListRoleAliasesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextMarker: smithy_client_1.expectString,
        roleAliases: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListRoleAliasesCommand = de_ListRoleAliasesCommand;
const de_ListRoleAliasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListScheduledAuditsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListScheduledAuditsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        scheduledAudits: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListScheduledAuditsCommand = de_ListScheduledAuditsCommand;
const de_ListScheduledAuditsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListSecurityProfilesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListSecurityProfilesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        securityProfileIdentifiers: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListSecurityProfilesCommand = de_ListSecurityProfilesCommand;
const de_ListSecurityProfilesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListSecurityProfilesForTargetCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListSecurityProfilesForTargetCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        securityProfileTargetMappings: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListSecurityProfilesForTargetCommand = de_ListSecurityProfilesForTargetCommand;
const de_ListSecurityProfilesForTargetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListStreamsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListStreamsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        streams: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListStreamsCommand = de_ListStreamsCommand;
const de_ListStreamsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        tags: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTargetsForPolicyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTargetsForPolicyCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextMarker: smithy_client_1.expectString,
        targets: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListTargetsForPolicyCommand = de_ListTargetsForPolicyCommand;
const de_ListTargetsForPolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTargetsForSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTargetsForSecurityProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        securityProfileTargets: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListTargetsForSecurityProfileCommand = de_ListTargetsForSecurityProfileCommand;
const de_ListTargetsForSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingGroupsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingGroupsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        thingGroups: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingGroupsCommand = de_ListThingGroupsCommand;
const de_ListThingGroupsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingGroupsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingGroupsForThingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        thingGroups: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingGroupsForThingCommand = de_ListThingGroupsForThingCommand;
const de_ListThingGroupsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingPrincipalsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingPrincipalsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        principals: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingPrincipalsCommand = de_ListThingPrincipalsCommand;
const de_ListThingPrincipalsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingRegistrationTaskReportsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingRegistrationTaskReportsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        reportType: smithy_client_1.expectString,
        resourceLinks: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingRegistrationTaskReportsCommand = de_ListThingRegistrationTaskReportsCommand;
const de_ListThingRegistrationTaskReportsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingRegistrationTasksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingRegistrationTasksCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        taskIds: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingRegistrationTasksCommand = de_ListThingRegistrationTasksCommand;
const de_ListThingRegistrationTasksCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        things: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingsCommand = de_ListThingsCommand;
const de_ListThingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingsInBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingsInBillingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        things: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingsInBillingGroupCommand = de_ListThingsInBillingGroupCommand;
const de_ListThingsInBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingsInThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingsInThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        things: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingsInThingGroupCommand = de_ListThingsInThingGroupCommand;
const de_ListThingsInThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListThingTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListThingTypesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        thingTypes: (_) => de_ThingTypeList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListThingTypesCommand = de_ListThingTypesCommand;
const de_ListThingTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTopicRuleDestinationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTopicRuleDestinationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        destinationSummaries: (_) => de_TopicRuleDestinationSummaries(_, context),
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListTopicRuleDestinationsCommand = de_ListTopicRuleDestinationsCommand;
const de_ListTopicRuleDestinationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListTopicRulesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListTopicRulesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        rules: (_) => de_TopicRuleList(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListTopicRulesCommand = de_ListTopicRulesCommand;
const de_ListTopicRulesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListV2LoggingLevelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListV2LoggingLevelsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        logTargetConfigurations: smithy_client_1._json,
        nextToken: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListV2LoggingLevelsCommand = de_ListV2LoggingLevelsCommand;
const de_ListV2LoggingLevelsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await de_NotConfiguredExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ListViolationEventsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListViolationEventsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        violationEvents: (_) => de_ViolationEvents(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListViolationEventsCommand = de_ListViolationEventsCommand;
const de_ListViolationEventsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_PutVerificationStateOnViolationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_PutVerificationStateOnViolationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_PutVerificationStateOnViolationCommand = de_PutVerificationStateOnViolationCommand;
const de_PutVerificationStateOnViolationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RegisterCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterCACertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_RegisterCACertificateCommand = de_RegisterCACertificateCommand;
const de_RegisterCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "RegistrationCodeValidationException":
        case "com.amazonaws.iot#RegistrationCodeValidationException":
            throw await de_RegistrationCodeValidationExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RegisterCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_RegisterCertificateCommand = de_RegisterCertificateCommand;
const de_RegisterCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateConflictException":
        case "com.amazonaws.iot#CertificateConflictException":
            throw await de_CertificateConflictExceptionRes(parsedOutput, context);
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RegisterCertificateWithoutCACommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterCertificateWithoutCACommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_RegisterCertificateWithoutCACommand = de_RegisterCertificateWithoutCACommand;
const de_RegisterCertificateWithoutCACommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RegisterThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterThingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        certificatePem: smithy_client_1.expectString,
        resourceArns: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_RegisterThingCommand = de_RegisterThingCommand;
const de_RegisterThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceRegistrationFailureException":
        case "com.amazonaws.iot#ResourceRegistrationFailureException":
            throw await de_ResourceRegistrationFailureExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RejectCertificateTransferCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RejectCertificateTransferCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_RejectCertificateTransferCommand = de_RejectCertificateTransferCommand;
const de_RejectCertificateTransferCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TransferAlreadyCompletedException":
        case "com.amazonaws.iot#TransferAlreadyCompletedException":
            throw await de_TransferAlreadyCompletedExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RemoveThingFromBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RemoveThingFromBillingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_RemoveThingFromBillingGroupCommand = de_RemoveThingFromBillingGroupCommand;
const de_RemoveThingFromBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_RemoveThingFromThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RemoveThingFromThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_RemoveThingFromThingGroupCommand = de_RemoveThingFromThingGroupCommand;
const de_RemoveThingFromThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ReplaceTopicRuleCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ReplaceTopicRuleCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_ReplaceTopicRuleCommand = de_ReplaceTopicRuleCommand;
const de_ReplaceTopicRuleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "SqlParseException":
        case "com.amazonaws.iot#SqlParseException":
            throw await de_SqlParseExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SearchIndexCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SearchIndexCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        thingGroups: smithy_client_1._json,
        things: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_SearchIndexCommand = de_SearchIndexCommand;
const de_SearchIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SetDefaultAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetDefaultAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorizerArn: smithy_client_1.expectString,
        authorizerName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_SetDefaultAuthorizerCommand = de_SetDefaultAuthorizerCommand;
const de_SetDefaultAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceAlreadyExistsException":
        case "com.amazonaws.iot#ResourceAlreadyExistsException":
            throw await de_ResourceAlreadyExistsExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SetDefaultPolicyVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetDefaultPolicyVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_SetDefaultPolicyVersionCommand = de_SetDefaultPolicyVersionCommand;
const de_SetDefaultPolicyVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SetLoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetLoggingOptionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_SetLoggingOptionsCommand = de_SetLoggingOptionsCommand;
const de_SetLoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SetV2LoggingLevelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetV2LoggingLevelCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_SetV2LoggingLevelCommand = de_SetV2LoggingLevelCommand;
const de_SetV2LoggingLevelCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotConfiguredException":
        case "com.amazonaws.iot#NotConfiguredException":
            throw await de_NotConfiguredExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_SetV2LoggingOptionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_SetV2LoggingOptionsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_SetV2LoggingOptionsCommand = de_SetV2LoggingOptionsCommand;
const de_SetV2LoggingOptionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartAuditMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartAuditMitigationActionsTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        taskId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_StartAuditMitigationActionsTaskCommand = de_StartAuditMitigationActionsTaskCommand;
const de_StartAuditMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TaskAlreadyExistsException":
        case "com.amazonaws.iot#TaskAlreadyExistsException":
            throw await de_TaskAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartDetectMitigationActionsTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartDetectMitigationActionsTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        taskId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_StartDetectMitigationActionsTaskCommand = de_StartDetectMitigationActionsTaskCommand;
const de_StartDetectMitigationActionsTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "TaskAlreadyExistsException":
        case "com.amazonaws.iot#TaskAlreadyExistsException":
            throw await de_TaskAlreadyExistsExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartOnDemandAuditTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartOnDemandAuditTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        taskId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_StartOnDemandAuditTaskCommand = de_StartOnDemandAuditTaskCommand;
const de_StartOnDemandAuditTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StartThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartThingRegistrationTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        taskId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_StartThingRegistrationTaskCommand = de_StartThingRegistrationTaskCommand;
const de_StartThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_StopThingRegistrationTaskCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StopThingRegistrationTaskCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_StopThingRegistrationTaskCommand = de_StopThingRegistrationTaskCommand;
const de_StopThingRegistrationTaskCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TestAuthorizationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestAuthorizationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authResults: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_TestAuthorizationCommand = de_TestAuthorizationCommand;
const de_TestAuthorizationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TestInvokeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TestInvokeAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        disconnectAfterInSeconds: smithy_client_1.expectInt32,
        isAuthenticated: smithy_client_1.expectBoolean,
        policyDocuments: smithy_client_1._json,
        principalId: smithy_client_1.expectString,
        refreshAfterInSeconds: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_TestInvokeAuthorizerCommand = de_TestInvokeAuthorizerCommand;
const de_TestInvokeAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidResponseException":
        case "com.amazonaws.iot#InvalidResponseException":
            throw await de_InvalidResponseExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_TransferCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_TransferCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        transferredCertificateArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_TransferCertificateCommand = de_TransferCertificateCommand;
const de_TransferCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "TransferConflictException":
        case "com.amazonaws.iot#TransferConflictException":
            throw await de_TransferConflictExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateAccountAuditConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAccountAuditConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateAccountAuditConfigurationCommand = de_UpdateAccountAuditConfigurationCommand;
const de_UpdateAccountAuditConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateAuditSuppressionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAuditSuppressionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateAuditSuppressionCommand = de_UpdateAuditSuppressionCommand;
const de_UpdateAuditSuppressionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateAuthorizerCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        authorizerArn: smithy_client_1.expectString,
        authorizerName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateAuthorizerCommand = de_UpdateAuthorizerCommand;
const de_UpdateAuthorizerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.iot#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateBillingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateBillingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateBillingGroupCommand = de_UpdateBillingGroupCommand;
const de_UpdateBillingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateCACertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCACertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateCACertificateCommand = de_UpdateCACertificateCommand;
const de_UpdateCACertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCertificateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateCertificateCommand = de_UpdateCertificateCommand;
const de_UpdateCertificateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateStateException":
        case "com.amazonaws.iot#CertificateStateException":
            throw await de_CertificateStateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateCustomMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateCustomMetricCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        displayName: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        metricArn: smithy_client_1.expectString,
        metricName: smithy_client_1.expectString,
        metricType: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateCustomMetricCommand = de_UpdateCustomMetricCommand;
const de_UpdateCustomMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDimensionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDimensionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        arn: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        name: smithy_client_1.expectString,
        stringValues: smithy_client_1._json,
        type: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDimensionCommand = de_UpdateDimensionCommand;
const de_UpdateDimensionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDomainConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDomainConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        domainConfigurationArn: smithy_client_1.expectString,
        domainConfigurationName: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDomainConfigurationCommand = de_UpdateDomainConfigurationCommand;
const de_UpdateDomainConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CertificateValidationException":
        case "com.amazonaws.iot#CertificateValidationException":
            throw await de_CertificateValidationExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateDynamicThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateDynamicThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateDynamicThingGroupCommand = de_UpdateDynamicThingGroupCommand;
const de_UpdateDynamicThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateEventConfigurationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateEventConfigurationsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateEventConfigurationsCommand = de_UpdateEventConfigurationsCommand;
const de_UpdateEventConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateFleetMetricCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateFleetMetricCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateFleetMetricCommand = de_UpdateFleetMetricCommand;
const de_UpdateFleetMetricCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "IndexNotReadyException":
        case "com.amazonaws.iot#IndexNotReadyException":
            throw await de_IndexNotReadyExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidAggregationException":
        case "com.amazonaws.iot#InvalidAggregationException":
            throw await de_InvalidAggregationExceptionRes(parsedOutput, context);
        case "InvalidQueryException":
        case "com.amazonaws.iot#InvalidQueryException":
            throw await de_InvalidQueryExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateIndexingConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateIndexingConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateIndexingConfigurationCommand = de_UpdateIndexingConfigurationCommand;
const de_UpdateIndexingConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateJobCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateJobCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateJobCommand = de_UpdateJobCommand;
const de_UpdateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateMitigationActionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateMitigationActionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        actionArn: smithy_client_1.expectString,
        actionId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateMitigationActionCommand = de_UpdateMitigationActionCommand;
const de_UpdateMitigationActionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePackageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdatePackageCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdatePackageCommand = de_UpdatePackageCommand;
const de_UpdatePackageCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePackageConfigurationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdatePackageConfigurationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdatePackageConfigurationCommand = de_UpdatePackageConfigurationCommand;
const de_UpdatePackageConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdatePackageVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdatePackageVersionCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdatePackageVersionCommand = de_UpdatePackageVersionCommand;
const de_UpdatePackageVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServerException":
        case "com.amazonaws.iot#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.iot#ValidationException":
            throw await de_ValidationExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateProvisioningTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateProvisioningTemplateCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateProvisioningTemplateCommand = de_UpdateProvisioningTemplateCommand;
const de_UpdateProvisioningTemplateCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateRoleAliasCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateRoleAliasCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        roleAlias: smithy_client_1.expectString,
        roleAliasArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateRoleAliasCommand = de_UpdateRoleAliasCommand;
const de_UpdateRoleAliasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateScheduledAuditCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateScheduledAuditCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        scheduledAuditArn: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateScheduledAuditCommand = de_UpdateScheduledAuditCommand;
const de_UpdateScheduledAuditCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateSecurityProfileCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateSecurityProfileCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        additionalMetricsToRetain: smithy_client_1._json,
        additionalMetricsToRetainV2: smithy_client_1._json,
        alertTargets: smithy_client_1._json,
        behaviors: (_) => de_Behaviors(_, context),
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        securityProfileArn: smithy_client_1.expectString,
        securityProfileDescription: smithy_client_1.expectString,
        securityProfileName: smithy_client_1.expectString,
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateSecurityProfileCommand = de_UpdateSecurityProfileCommand;
const de_UpdateSecurityProfileCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateStreamCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateStreamCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        description: smithy_client_1.expectString,
        streamArn: smithy_client_1.expectString,
        streamId: smithy_client_1.expectString,
        streamVersion: smithy_client_1.expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateStreamCommand = de_UpdateStreamCommand;
const de_UpdateStreamCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateThingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateThingCommand = de_UpdateThingCommand;
const de_UpdateThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateThingGroupCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateThingGroupCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        version: smithy_client_1.expectLong,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_UpdateThingGroupCommand = de_UpdateThingGroupCommand;
const de_UpdateThingGroupCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        case "VersionConflictException":
        case "com.amazonaws.iot#VersionConflictException":
            throw await de_VersionConflictExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateThingGroupsForThingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateThingGroupsForThingCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateThingGroupsForThingCommand = de_UpdateThingGroupsForThingCommand;
const de_UpdateThingGroupsForThingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.iot#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_UpdateTopicRuleDestinationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_UpdateTopicRuleDestinationCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_UpdateTopicRuleDestinationCommand = de_UpdateTopicRuleDestinationCommand;
const de_UpdateTopicRuleDestinationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictingResourceUpdateException":
        case "com.amazonaws.iot#ConflictingResourceUpdateException":
            throw await de_ConflictingResourceUpdateExceptionRes(parsedOutput, context);
        case "InternalException":
        case "com.amazonaws.iot#InternalException":
            throw await de_InternalExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.iot#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.iot#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const de_ValidateSecurityProfileBehaviorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ValidateSecurityProfileBehaviorsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output),
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        valid: smithy_client_1.expectBoolean,
        validationErrors: smithy_client_1._json,
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ValidateSecurityProfileBehaviorsCommand = de_ValidateSecurityProfileBehaviorsCommand;
const de_ValidateSecurityProfileBehaviorsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalFailureException":
        case "com.amazonaws.iot#InternalFailureException":
            throw await de_InternalFailureExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.iot#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ThrottlingException":
        case "com.amazonaws.iot#ThrottlingException":
            throw await de_ThrottlingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(IoTServiceException_1.IoTServiceException);
const de_CertificateConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_2_1.CertificateConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_CertificateStateExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.CertificateStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_CertificateValidationExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.CertificateValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
        resourceId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ConflictingResourceUpdateExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ConflictingResourceUpdateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_DeleteConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.DeleteConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_IndexNotReadyExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.IndexNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InternalExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InternalException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InternalFailureExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InternalFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InternalServerExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidAggregationExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidAggregationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidQueryExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidQueryException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidRequestExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidResponseExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_2_1.InvalidResponseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_InvalidStateTransitionExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidStateTransitionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_MalformedPolicyExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.MalformedPolicyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_NotConfiguredExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_1_1.NotConfiguredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_RegistrationCodeValidationExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_2_1.RegistrationCodeValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
        resourceArn: smithy_client_1.expectString,
        resourceId: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ResourceAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceRegistrationFailureExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_2_1.ResourceRegistrationFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ServiceQuotaExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ServiceQuotaExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_SqlParseExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.SqlParseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TaskAlreadyExistsExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_2_1.TaskAlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ThrottlingExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ThrottlingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TransferAlreadyCompletedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TransferAlreadyCompletedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TransferConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_2_1.TransferConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ValidationExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_VersionConflictExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.VersionConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_VersionsLimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString,
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.VersionsLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const se_AbortConfig = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        criteriaList: (_) => se_AbortCriteriaList(_, context),
    });
};
const se_AbortCriteria = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        action: [],
        failureType: [],
        minNumberOfExecutedThings: [],
        thresholdPercentage: smithy_client_1.serializeFloat,
    });
};
const se_AbortCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AbortCriteria(entry, context);
    });
};
const se_AwsJobAbortConfig = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        abortCriteriaList: (_) => se_AwsJobAbortCriteriaList(_, context),
    });
};
const se_AwsJobAbortCriteria = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        action: [],
        failureType: [],
        minNumberOfExecutedThings: [],
        thresholdPercentage: smithy_client_1.serializeFloat,
    });
};
const se_AwsJobAbortCriteriaList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_AwsJobAbortCriteria(entry, context);
    });
};
const se_AwsJobExecutionsRolloutConfig = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        exponentialRate: (_) => se_AwsJobExponentialRolloutRate(_, context),
        maximumPerMinute: [],
    });
};
const se_AwsJobExponentialRolloutRate = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        baseRatePerMinute: [],
        incrementFactor: smithy_client_1.serializeFloat,
        rateIncreaseCriteria: smithy_client_1._json,
    });
};
const se_Behavior = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        criteria: (_) => se_BehaviorCriteria(_, context),
        metric: [],
        metricDimension: smithy_client_1._json,
        name: [],
        suppressAlerts: [],
    });
};
const se_BehaviorCriteria = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        comparisonOperator: [],
        consecutiveDatapointsToAlarm: [],
        consecutiveDatapointsToClear: [],
        durationSeconds: [],
        mlDetectionConfig: smithy_client_1._json,
        statisticalThreshold: smithy_client_1._json,
        value: (_) => se_MetricValue(_, context),
    });
};
const se_Behaviors = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_Behavior(entry, context);
    });
};
const se_CodeSigning = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        awsSignerJobId: [],
        customCodeSigning: (_) => se_CustomCodeSigning(_, context),
        startSigningJobParameter: smithy_client_1._json,
    });
};
const se_CodeSigningSignature = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        inlineDocument: context.base64Encoder,
    });
};
const se_CustomCodeSigning = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        certificateChain: smithy_client_1._json,
        hashAlgorithm: [],
        signature: (_) => se_CodeSigningSignature(_, context),
        signatureAlgorithm: [],
    });
};
const se_ExponentialRolloutRate = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        baseRatePerMinute: [],
        incrementFactor: smithy_client_1.serializeFloat,
        rateIncreaseCriteria: smithy_client_1._json,
    });
};
const se_JobExecutionsRolloutConfig = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        exponentialRate: (_) => se_ExponentialRolloutRate(_, context),
        maximumPerMinute: [],
    });
};
const se_MetricValue = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        cidrs: smithy_client_1._json,
        count: [],
        number: smithy_client_1.serializeFloat,
        numbers: (_) => se_NumberList(_, context),
        ports: smithy_client_1._json,
        strings: smithy_client_1._json,
    });
};
const se_MqttContext = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        clientId: [],
        password: context.base64Encoder,
        username: [],
    });
};
const se_NumberList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.serializeFloat)(entry);
    });
};
const se_OTAUpdateFile = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        attributes: smithy_client_1._json,
        codeSigning: (_) => se_CodeSigning(_, context),
        fileLocation: smithy_client_1._json,
        fileName: [],
        fileType: [],
        fileVersion: [],
    });
};
const se_OTAUpdateFiles = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_OTAUpdateFile(entry, context);
    });
};
const se_PercentList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.serializeFloat)(entry);
    });
};
const se_ViolationEventOccurrenceRange = (input, context) => {
    return (0, smithy_client_1.take)(input, {
        endTime: (_) => Math.round(_.getTime() / 1000),
        startTime: (_) => Math.round(_.getTime() / 1000),
    });
};
const de_AbortConfig = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        criteriaList: (_) => de_AbortCriteriaList(_, context),
    });
};
const de_AbortCriteria = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        action: smithy_client_1.expectString,
        failureType: smithy_client_1.expectString,
        minNumberOfExecutedThings: smithy_client_1.expectInt32,
        thresholdPercentage: smithy_client_1.limitedParseDouble,
    });
};
const de_AbortCriteriaList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AbortCriteria(entry, context);
    });
    return retVal;
};
const de_ActiveViolation = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        behavior: (_) => de_Behavior(_, context),
        lastViolationTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastViolationValue: (_) => de_MetricValue(_, context),
        securityProfileName: smithy_client_1.expectString,
        thingName: smithy_client_1.expectString,
        verificationState: smithy_client_1.expectString,
        verificationStateDescription: smithy_client_1.expectString,
        violationEventAdditionalInfo: smithy_client_1._json,
        violationId: smithy_client_1.expectString,
        violationStartTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_ActiveViolations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ActiveViolation(entry, context);
    });
    return retVal;
};
const de_AuditFinding = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        checkName: smithy_client_1.expectString,
        findingId: smithy_client_1.expectString,
        findingTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        isSuppressed: smithy_client_1.expectBoolean,
        nonCompliantResource: smithy_client_1._json,
        reasonForNonCompliance: smithy_client_1.expectString,
        reasonForNonComplianceCode: smithy_client_1.expectString,
        relatedResources: smithy_client_1._json,
        severity: smithy_client_1.expectString,
        taskId: smithy_client_1.expectString,
        taskStartTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_AuditFindings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuditFinding(entry, context);
    });
    return retVal;
};
const de_AuditMitigationActionExecutionMetadata = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        actionId: smithy_client_1.expectString,
        actionName: smithy_client_1.expectString,
        endTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        errorCode: smithy_client_1.expectString,
        findingId: smithy_client_1.expectString,
        message: smithy_client_1.expectString,
        startTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
        taskId: smithy_client_1.expectString,
    });
};
const de_AuditMitigationActionExecutionMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuditMitigationActionExecutionMetadata(entry, context);
    });
    return retVal;
};
const de_AuditMitigationActionsTaskMetadata = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        startTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        taskId: smithy_client_1.expectString,
        taskStatus: smithy_client_1.expectString,
    });
};
const de_AuditMitigationActionsTaskMetadataList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuditMitigationActionsTaskMetadata(entry, context);
    });
    return retVal;
};
const de_AuditSuppression = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        checkName: smithy_client_1.expectString,
        description: smithy_client_1.expectString,
        expirationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        resourceIdentifier: smithy_client_1._json,
        suppressIndefinitely: smithy_client_1.expectBoolean,
    });
};
const de_AuditSuppressionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_AuditSuppression(entry, context);
    });
    return retVal;
};
const de_AuthorizerDescription = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        authorizerArn: smithy_client_1.expectString,
        authorizerFunctionArn: smithy_client_1.expectString,
        authorizerName: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        enableCachingForHttp: smithy_client_1.expectBoolean,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        signingDisabled: smithy_client_1.expectBoolean,
        status: smithy_client_1.expectString,
        tokenKeyName: smithy_client_1.expectString,
        tokenSigningPublicKeys: smithy_client_1._json,
    });
};
const de_AwsJobExecutionsRolloutConfig = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        exponentialRate: (_) => de_AwsJobExponentialRolloutRate(_, context),
        maximumPerMinute: smithy_client_1.expectInt32,
    });
};
const de_AwsJobExponentialRolloutRate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        baseRatePerMinute: smithy_client_1.expectInt32,
        incrementFactor: smithy_client_1.limitedParseDouble,
        rateIncreaseCriteria: smithy_client_1._json,
    });
};
const de_Behavior = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        criteria: (_) => de_BehaviorCriteria(_, context),
        metric: smithy_client_1.expectString,
        metricDimension: smithy_client_1._json,
        name: smithy_client_1.expectString,
        suppressAlerts: smithy_client_1.expectBoolean,
    });
};
const de_BehaviorCriteria = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        comparisonOperator: smithy_client_1.expectString,
        consecutiveDatapointsToAlarm: smithy_client_1.expectInt32,
        consecutiveDatapointsToClear: smithy_client_1.expectInt32,
        durationSeconds: smithy_client_1.expectInt32,
        mlDetectionConfig: smithy_client_1._json,
        statisticalThreshold: smithy_client_1._json,
        value: (_) => de_MetricValue(_, context),
    });
};
const de_BehaviorModelTrainingSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_BehaviorModelTrainingSummary(entry, context);
    });
    return retVal;
};
const de_BehaviorModelTrainingSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        behaviorName: smithy_client_1.expectString,
        datapointsCollectionPercentage: smithy_client_1.limitedParseDouble,
        lastModelRefreshDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        modelStatus: smithy_client_1.expectString,
        securityProfileName: smithy_client_1.expectString,
        trainingDataCollectionStartDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_Behaviors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Behavior(entry, context);
    });
    return retVal;
};
const de_BillingGroupMetadata = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_CACertificate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
    });
};
const de_CACertificateDescription = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        autoRegistrationStatus: smithy_client_1.expectString,
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
        certificateMode: smithy_client_1.expectString,
        certificatePem: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        customerVersion: smithy_client_1.expectInt32,
        generationId: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        ownedBy: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        validity: (_) => de_CertificateValidity(_, context),
    });
};
const de_CACertificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_CACertificate(entry, context);
    });
    return retVal;
};
const de_Certificate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
        certificateMode: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
    });
};
const de_CertificateDescription = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        caCertificateId: smithy_client_1.expectString,
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
        certificateMode: smithy_client_1.expectString,
        certificatePem: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        customerVersion: smithy_client_1.expectInt32,
        generationId: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        ownedBy: smithy_client_1.expectString,
        previousOwnedBy: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        transferData: (_) => de_TransferData(_, context),
        validity: (_) => de_CertificateValidity(_, context),
    });
};
const de_Certificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Certificate(entry, context);
    });
    return retVal;
};
const de_CertificateValidity = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        notAfter: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        notBefore: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_CodeSigning = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        awsSignerJobId: smithy_client_1.expectString,
        customCodeSigning: (_) => de_CustomCodeSigning(_, context),
        startSigningJobParameter: smithy_client_1._json,
    });
};
const de_CodeSigningSignature = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        inlineDocument: context.base64Decoder,
    });
};
const de_CustomCodeSigning = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        certificateChain: smithy_client_1._json,
        hashAlgorithm: smithy_client_1.expectString,
        signature: (_) => de_CodeSigningSignature(_, context),
        signatureAlgorithm: smithy_client_1.expectString,
    });
};
const de_DetectMitigationActionExecution = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        actionName: smithy_client_1.expectString,
        errorCode: smithy_client_1.expectString,
        executionEndDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        executionStartDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        message: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        taskId: smithy_client_1.expectString,
        thingName: smithy_client_1.expectString,
        violationId: smithy_client_1.expectString,
    });
};
const de_DetectMitigationActionExecutionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DetectMitigationActionExecution(entry, context);
    });
    return retVal;
};
const de_DetectMitigationActionsTaskSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        actionsDefinition: smithy_client_1._json,
        onlyActiveViolationsIncluded: smithy_client_1.expectBoolean,
        suppressedAlertsIncluded: smithy_client_1.expectBoolean,
        target: smithy_client_1._json,
        taskEndTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        taskId: smithy_client_1.expectString,
        taskStartTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        taskStatistics: smithy_client_1._json,
        taskStatus: smithy_client_1.expectString,
        violationEventOccurrenceRange: (_) => de_ViolationEventOccurrenceRange(_, context),
    });
};
const de_DetectMitigationActionsTaskSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DetectMitigationActionsTaskSummary(entry, context);
    });
    return retVal;
};
const de_ExponentialRolloutRate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        baseRatePerMinute: smithy_client_1.expectInt32,
        incrementFactor: smithy_client_1.limitedParseDouble,
        rateIncreaseCriteria: smithy_client_1._json,
    });
};
const de_Job = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        abortConfig: (_) => de_AbortConfig(_, context),
        comment: smithy_client_1.expectString,
        completedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        destinationPackageVersions: smithy_client_1._json,
        documentParameters: smithy_client_1._json,
        forceCanceled: smithy_client_1.expectBoolean,
        isConcurrent: smithy_client_1.expectBoolean,
        jobArn: smithy_client_1.expectString,
        jobExecutionsRetryConfig: smithy_client_1._json,
        jobExecutionsRolloutConfig: (_) => de_JobExecutionsRolloutConfig(_, context),
        jobId: smithy_client_1.expectString,
        jobProcessDetails: smithy_client_1._json,
        jobTemplateArn: smithy_client_1.expectString,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        namespaceId: smithy_client_1.expectString,
        presignedUrlConfig: smithy_client_1._json,
        reasonCode: smithy_client_1.expectString,
        scheduledJobRollouts: smithy_client_1._json,
        schedulingConfig: smithy_client_1._json,
        status: smithy_client_1.expectString,
        targetSelection: smithy_client_1.expectString,
        targets: smithy_client_1._json,
        timeoutConfig: smithy_client_1._json,
    });
};
const de_JobExecution = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        approximateSecondsBeforeTimedOut: smithy_client_1.expectLong,
        executionNumber: smithy_client_1.expectLong,
        forceCanceled: smithy_client_1.expectBoolean,
        jobId: smithy_client_1.expectString,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        queuedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        startedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
        statusDetails: smithy_client_1._json,
        thingArn: smithy_client_1.expectString,
        versionNumber: smithy_client_1.expectLong,
    });
};
const de_JobExecutionsRolloutConfig = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        exponentialRate: (_) => de_ExponentialRolloutRate(_, context),
        maximumPerMinute: smithy_client_1.expectInt32,
    });
};
const de_JobExecutionSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        executionNumber: smithy_client_1.expectLong,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        queuedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        retryAttempt: smithy_client_1.expectInt32,
        startedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
    });
};
const de_JobExecutionSummaryForJob = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        jobExecutionSummary: (_) => de_JobExecutionSummary(_, context),
        thingArn: smithy_client_1.expectString,
    });
};
const de_JobExecutionSummaryForJobList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobExecutionSummaryForJob(entry, context);
    });
    return retVal;
};
const de_JobExecutionSummaryForThing = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        jobExecutionSummary: (_) => de_JobExecutionSummary(_, context),
        jobId: smithy_client_1.expectString,
    });
};
const de_JobExecutionSummaryForThingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobExecutionSummaryForThing(entry, context);
    });
    return retVal;
};
const de_JobSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        completedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        isConcurrent: smithy_client_1.expectBoolean,
        jobArn: smithy_client_1.expectString,
        jobId: smithy_client_1.expectString,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
        targetSelection: smithy_client_1.expectString,
        thingGroupId: smithy_client_1.expectString,
    });
};
const de_JobSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobSummary(entry, context);
    });
    return retVal;
};
const de_JobTemplateSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        jobTemplateArn: smithy_client_1.expectString,
        jobTemplateId: smithy_client_1.expectString,
    });
};
const de_JobTemplateSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_JobTemplateSummary(entry, context);
    });
    return retVal;
};
const de_MetricDatum = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        timestamp: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        value: (_) => de_MetricValue(_, context),
    });
};
const de_MetricDatumList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MetricDatum(entry, context);
    });
    return retVal;
};
const de_MetricValue = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        cidrs: smithy_client_1._json,
        count: smithy_client_1.expectLong,
        number: smithy_client_1.limitedParseDouble,
        numbers: (_) => de_NumberList(_, context),
        ports: smithy_client_1._json,
        strings: smithy_client_1._json,
    });
};
const de_MitigationActionIdentifier = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        actionArn: smithy_client_1.expectString,
        actionName: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_MitigationActionIdentifierList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_MitigationActionIdentifier(entry, context);
    });
    return retVal;
};
const de_NumberList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return (0, smithy_client_1.limitedParseDouble)(entry);
    });
    return retVal;
};
const de_OTAUpdateFile = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        attributes: smithy_client_1._json,
        codeSigning: (_) => de_CodeSigning(_, context),
        fileLocation: smithy_client_1._json,
        fileName: smithy_client_1.expectString,
        fileType: smithy_client_1.expectInt32,
        fileVersion: smithy_client_1.expectString,
    });
};
const de_OTAUpdateFiles = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OTAUpdateFile(entry, context);
    });
    return retVal;
};
const de_OTAUpdateInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        additionalParameters: smithy_client_1._json,
        awsIotJobArn: smithy_client_1.expectString,
        awsIotJobId: smithy_client_1.expectString,
        awsJobExecutionsRolloutConfig: (_) => de_AwsJobExecutionsRolloutConfig(_, context),
        awsJobPresignedUrlConfig: smithy_client_1._json,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        errorInfo: smithy_client_1._json,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        otaUpdateArn: smithy_client_1.expectString,
        otaUpdateFiles: (_) => de_OTAUpdateFiles(_, context),
        otaUpdateId: smithy_client_1.expectString,
        otaUpdateStatus: smithy_client_1.expectString,
        protocols: smithy_client_1._json,
        targetSelection: smithy_client_1.expectString,
        targets: smithy_client_1._json,
    });
};
const de_OTAUpdatesSummary = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OTAUpdateSummary(entry, context);
    });
    return retVal;
};
const de_OTAUpdateSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        otaUpdateArn: smithy_client_1.expectString,
        otaUpdateId: smithy_client_1.expectString,
    });
};
const de_OutgoingCertificate = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        certificateArn: smithy_client_1.expectString,
        certificateId: smithy_client_1.expectString,
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        transferDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        transferMessage: smithy_client_1.expectString,
        transferredTo: smithy_client_1.expectString,
    });
};
const de_OutgoingCertificates = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_OutgoingCertificate(entry, context);
    });
    return retVal;
};
const de_PackageSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        defaultVersionName: smithy_client_1.expectString,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        packageName: smithy_client_1.expectString,
    });
};
const de_PackageSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackageSummary(entry, context);
    });
    return retVal;
};
const de_PackageVersionSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        packageName: smithy_client_1.expectString,
        status: smithy_client_1.expectString,
        versionName: smithy_client_1.expectString,
    });
};
const de_PackageVersionSummaryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PackageVersionSummary(entry, context);
    });
    return retVal;
};
const de_Percentiles = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PercentPair(entry, context);
    });
    return retVal;
};
const de_PercentPair = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        percent: smithy_client_1.limitedParseDouble,
        value: smithy_client_1.limitedParseDouble,
    });
};
const de_PolicyVersion = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        createDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        isDefaultVersion: smithy_client_1.expectBoolean,
        versionId: smithy_client_1.expectString,
    });
};
const de_PolicyVersions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_PolicyVersion(entry, context);
    });
    return retVal;
};
const de_ProvisioningTemplateListing = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProvisioningTemplateSummary(entry, context);
    });
    return retVal;
};
const de_ProvisioningTemplateSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        enabled: smithy_client_1.expectBoolean,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        templateArn: smithy_client_1.expectString,
        templateName: smithy_client_1.expectString,
        type: smithy_client_1.expectString,
    });
};
const de_ProvisioningTemplateVersionListing = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ProvisioningTemplateVersionSummary(entry, context);
    });
    return retVal;
};
const de_ProvisioningTemplateVersionSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        isDefaultVersion: smithy_client_1.expectBoolean,
        versionId: smithy_client_1.expectInt32,
    });
};
const de_RoleAliasDescription = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        credentialDurationSeconds: smithy_client_1.expectInt32,
        lastModifiedDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        owner: smithy_client_1.expectString,
        roleAlias: smithy_client_1.expectString,
        roleAliasArn: smithy_client_1.expectString,
        roleArn: smithy_client_1.expectString,
    });
};
const de_Statistics = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        average: smithy_client_1.limitedParseDouble,
        count: smithy_client_1.expectInt32,
        maximum: smithy_client_1.limitedParseDouble,
        minimum: smithy_client_1.limitedParseDouble,
        stdDeviation: smithy_client_1.limitedParseDouble,
        sum: smithy_client_1.limitedParseDouble,
        sumOfSquares: smithy_client_1.limitedParseDouble,
        variance: smithy_client_1.limitedParseDouble,
    });
};
const de_StreamInfo = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        files: smithy_client_1._json,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        roleArn: smithy_client_1.expectString,
        streamArn: smithy_client_1.expectString,
        streamId: smithy_client_1.expectString,
        streamVersion: smithy_client_1.expectInt32,
    });
};
const de_ThingGroupMetadata = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        parentGroupName: smithy_client_1.expectString,
        rootToParentThingGroups: smithy_client_1._json,
    });
};
const de_ThingTypeDefinition = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        thingTypeArn: smithy_client_1.expectString,
        thingTypeMetadata: (_) => de_ThingTypeMetadata(_, context),
        thingTypeName: smithy_client_1.expectString,
        thingTypeProperties: smithy_client_1._json,
    });
};
const de_ThingTypeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ThingTypeDefinition(entry, context);
    });
    return retVal;
};
const de_ThingTypeMetadata = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        creationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        deprecated: smithy_client_1.expectBoolean,
        deprecationDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_TopicRule = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        actions: smithy_client_1._json,
        awsIotSqlVersion: smithy_client_1.expectString,
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        description: smithy_client_1.expectString,
        errorAction: smithy_client_1._json,
        ruleDisabled: smithy_client_1.expectBoolean,
        ruleName: smithy_client_1.expectString,
        sql: smithy_client_1.expectString,
    });
};
const de_TopicRuleDestination = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        arn: smithy_client_1.expectString,
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        httpUrlProperties: smithy_client_1._json,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
        statusReason: smithy_client_1.expectString,
        vpcProperties: smithy_client_1._json,
    });
};
const de_TopicRuleDestinationSummaries = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TopicRuleDestinationSummary(entry, context);
    });
    return retVal;
};
const de_TopicRuleDestinationSummary = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        arn: smithy_client_1.expectString,
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        httpUrlSummary: smithy_client_1._json,
        lastUpdatedAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        status: smithy_client_1.expectString,
        statusReason: smithy_client_1.expectString,
        vpcDestinationSummary: smithy_client_1._json,
    });
};
const de_TopicRuleList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_TopicRuleListItem(entry, context);
    });
    return retVal;
};
const de_TopicRuleListItem = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        createdAt: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        ruleArn: smithy_client_1.expectString,
        ruleDisabled: smithy_client_1.expectBoolean,
        ruleName: smithy_client_1.expectString,
        topicPattern: smithy_client_1.expectString,
    });
};
const de_TransferData = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        acceptDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        rejectDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        rejectReason: smithy_client_1.expectString,
        transferDate: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        transferMessage: smithy_client_1.expectString,
    });
};
const de_ViolationEvent = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        behavior: (_) => de_Behavior(_, context),
        metricValue: (_) => de_MetricValue(_, context),
        securityProfileName: smithy_client_1.expectString,
        thingName: smithy_client_1.expectString,
        verificationState: smithy_client_1.expectString,
        verificationStateDescription: smithy_client_1.expectString,
        violationEventAdditionalInfo: smithy_client_1._json,
        violationEventTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        violationEventType: smithy_client_1.expectString,
        violationId: smithy_client_1.expectString,
    });
};
const de_ViolationEventOccurrenceRange = (output, context) => {
    return (0, smithy_client_1.take)(output, {
        endTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        startTime: (_) => (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
    });
};
const de_ViolationEvents = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ViolationEvent(entry, context);
    });
    return retVal;
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => (0, smithy_client_1.collectBody)(streamBody, context).then((body) => context.utf8Encoder(body));
const isSerializableHeaderValue = (value) => value !== undefined &&
    value !== null &&
    value !== "" &&
    (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) &&
    (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
